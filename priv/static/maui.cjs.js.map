{
  "version": 3,
  "sources": ["../../assets/js/index.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/constants.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/entry_uploader.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/utils.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/browser.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/dom.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/upload_entry.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/live_uploader.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/aria.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/hooks.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/element_ref.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/dom_post_morph_restorer.js", "../../deps/phoenix_live_view/node_modules/morphdom/dist/morphdom-esm.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/dom_patch.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/rendered.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/js.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/js_commands.ts", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/view_hook.ts", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/view.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/live_socket.js", "../../deps/phoenix_live_view/assets/js/phoenix_live_view/index.ts", "../../assets/vendor/floating-ui.js", "../../assets/js/popover.js"],
  "sourcesContent": ["import Popover from \"./popover\";\n\nexport const Hooks = {\n  Popover,\n  Select,\n};\n", "export const CONSECUTIVE_RELOADS = \"consecutive-reloads\";\nexport const MAX_RELOADS = 10;\nexport const RELOAD_JITTER_MIN = 5000;\nexport const RELOAD_JITTER_MAX = 10000;\nexport const FAILSAFE_JITTER = 30000;\nexport const PHX_EVENT_CLASSES = [\n  \"phx-click-loading\",\n  \"phx-change-loading\",\n  \"phx-submit-loading\",\n  \"phx-keydown-loading\",\n  \"phx-keyup-loading\",\n  \"phx-blur-loading\",\n  \"phx-focus-loading\",\n  \"phx-hook-loading\",\n];\nexport const PHX_COMPONENT = \"data-phx-component\";\nexport const PHX_VIEW_REF = \"data-phx-view\";\nexport const PHX_LIVE_LINK = \"data-phx-link\";\nexport const PHX_TRACK_STATIC = \"track-static\";\nexport const PHX_LINK_STATE = \"data-phx-link-state\";\nexport const PHX_REF_LOADING = \"data-phx-ref-loading\";\nexport const PHX_REF_SRC = \"data-phx-ref-src\";\nexport const PHX_REF_LOCK = \"data-phx-ref-lock\";\nexport const PHX_PENDING_REFS = \"phx-pending-refs\";\nexport const PHX_TRACK_UPLOADS = \"track-uploads\";\nexport const PHX_UPLOAD_REF = \"data-phx-upload-ref\";\nexport const PHX_PREFLIGHTED_REFS = \"data-phx-preflighted-refs\";\nexport const PHX_DONE_REFS = \"data-phx-done-refs\";\nexport const PHX_DROP_TARGET = \"drop-target\";\nexport const PHX_ACTIVE_ENTRY_REFS = \"data-phx-active-refs\";\nexport const PHX_LIVE_FILE_UPDATED = \"phx:live-file:updated\";\nexport const PHX_SKIP = \"data-phx-skip\";\nexport const PHX_MAGIC_ID = \"data-phx-id\";\nexport const PHX_PRUNE = \"data-phx-prune\";\nexport const PHX_CONNECTED_CLASS = \"phx-connected\";\nexport const PHX_LOADING_CLASS = \"phx-loading\";\nexport const PHX_ERROR_CLASS = \"phx-error\";\nexport const PHX_CLIENT_ERROR_CLASS = \"phx-client-error\";\nexport const PHX_SERVER_ERROR_CLASS = \"phx-server-error\";\nexport const PHX_PARENT_ID = \"data-phx-parent-id\";\nexport const PHX_MAIN = \"data-phx-main\";\nexport const PHX_ROOT_ID = \"data-phx-root-id\";\nexport const PHX_VIEWPORT_TOP = \"viewport-top\";\nexport const PHX_VIEWPORT_BOTTOM = \"viewport-bottom\";\nexport const PHX_TRIGGER_ACTION = \"trigger-action\";\nexport const PHX_HAS_FOCUSED = \"phx-has-focused\";\nexport const FOCUSABLE_INPUTS = [\n  \"text\",\n  \"textarea\",\n  \"number\",\n  \"email\",\n  \"password\",\n  \"search\",\n  \"tel\",\n  \"url\",\n  \"date\",\n  \"time\",\n  \"datetime-local\",\n  \"color\",\n  \"range\",\n];\nexport const CHECKABLE_INPUTS = [\"checkbox\", \"radio\"];\nexport const PHX_HAS_SUBMITTED = \"phx-has-submitted\";\nexport const PHX_SESSION = \"data-phx-session\";\nexport const PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;\nexport const PHX_STICKY = \"data-phx-sticky\";\nexport const PHX_STATIC = \"data-phx-static\";\nexport const PHX_READONLY = \"data-phx-readonly\";\nexport const PHX_DISABLED = \"data-phx-disabled\";\nexport const PHX_DISABLE_WITH = \"disable-with\";\nexport const PHX_DISABLE_WITH_RESTORE = \"data-phx-disable-with-restore\";\nexport const PHX_HOOK = \"hook\";\nexport const PHX_DEBOUNCE = \"debounce\";\nexport const PHX_THROTTLE = \"throttle\";\nexport const PHX_UPDATE = \"update\";\nexport const PHX_STREAM = \"stream\";\nexport const PHX_STREAM_REF = \"data-phx-stream\";\nexport const PHX_PORTAL = \"data-phx-portal\";\nexport const PHX_TELEPORTED_REF = \"data-phx-teleported\";\nexport const PHX_TELEPORTED_SRC = \"data-phx-teleported-src\";\nexport const PHX_RUNTIME_HOOK = \"data-phx-runtime-hook\";\nexport const PHX_LV_PID = \"data-phx-pid\";\nexport const PHX_KEY = \"key\";\nexport const PHX_PRIVATE = \"phxPrivate\";\nexport const PHX_AUTO_RECOVER = \"auto-recover\";\nexport const PHX_LV_DEBUG = \"phx:live-socket:debug\";\nexport const PHX_LV_PROFILE = \"phx:live-socket:profiling\";\nexport const PHX_LV_LATENCY_SIM = \"phx:live-socket:latency-sim\";\nexport const PHX_LV_HISTORY_POSITION = \"phx:nav-history-position\";\nexport const PHX_PROGRESS = \"progress\";\nexport const PHX_MOUNTED = \"mounted\";\nexport const PHX_RELOAD_STATUS = \"__phoenix_reload_status__\";\nexport const LOADER_TIMEOUT = 1;\nexport const MAX_CHILD_JOIN_ATTEMPTS = 3;\nexport const BEFORE_UNLOAD_LOADER_TIMEOUT = 200;\nexport const DISCONNECTED_TIMEOUT = 500;\nexport const BINDING_PREFIX = \"phx-\";\nexport const PUSH_TIMEOUT = 30000;\nexport const LINK_HEADER = \"x-requested-with\";\nexport const RESPONSE_URL_HEADER = \"x-response-url\";\nexport const DEBOUNCE_TRIGGER = \"debounce-trigger\";\nexport const THROTTLED = \"throttled\";\nexport const DEBOUNCE_PREV_KEY = \"debounce-prev-key\";\nexport const DEFAULTS = {\n  debounce: 300,\n  throttle: 300,\n};\nexport const PHX_PENDING_ATTRS = [PHX_REF_LOADING, PHX_REF_SRC, PHX_REF_LOCK];\n// Rendered\nexport const STATIC = \"s\";\nexport const ROOT = \"r\";\nexport const COMPONENTS = \"c\";\nexport const KEYED = \"k\";\nexport const KEYED_COUNT = \"kc\";\nexport const EVENTS = \"e\";\nexport const REPLY = \"r\";\nexport const TITLE = \"t\";\nexport const TEMPLATES = \"p\";\nexport const STREAM = \"stream\";\n", "import { logError } from \"./utils\";\n\nexport default class EntryUploader {\n  constructor(entry, config, liveSocket) {\n    const { chunk_size, chunk_timeout } = config;\n    this.liveSocket = liveSocket;\n    this.entry = entry;\n    this.offset = 0;\n    this.chunkSize = chunk_size;\n    this.chunkTimeout = chunk_timeout;\n    this.chunkTimer = null;\n    this.errored = false;\n    this.uploadChannel = liveSocket.channel(`lvu:${entry.ref}`, {\n      token: entry.metadata(),\n    });\n  }\n\n  error(reason) {\n    if (this.errored) {\n      return;\n    }\n    this.uploadChannel.leave();\n    this.errored = true;\n    clearTimeout(this.chunkTimer);\n    this.entry.error(reason);\n  }\n\n  upload() {\n    this.uploadChannel.onError((reason) => this.error(reason));\n    this.uploadChannel\n      .join()\n      .receive(\"ok\", (_data) => this.readNextChunk())\n      .receive(\"error\", (reason) => this.error(reason));\n  }\n\n  isDone() {\n    return this.offset >= this.entry.file.size;\n  }\n\n  readNextChunk() {\n    const reader = new window.FileReader();\n    const blob = this.entry.file.slice(\n      this.offset,\n      this.chunkSize + this.offset,\n    );\n    reader.onload = (e) => {\n      if (e.target.error === null) {\n        this.offset += /** @type {ArrayBuffer} */ (e.target.result).byteLength;\n        this.pushChunk(/** @type {ArrayBuffer} */ (e.target.result));\n      } else {\n        return logError(\"Read error: \" + e.target.error);\n      }\n    };\n    reader.readAsArrayBuffer(blob);\n  }\n\n  pushChunk(chunk) {\n    if (!this.uploadChannel.isJoined()) {\n      return;\n    }\n    this.uploadChannel\n      .push(\"chunk\", chunk, this.chunkTimeout)\n      .receive(\"ok\", () => {\n        this.entry.progress((this.offset / this.entry.file.size) * 100);\n        if (!this.isDone()) {\n          this.chunkTimer = setTimeout(\n            () => this.readNextChunk(),\n            this.liveSocket.getLatencySim() || 0,\n          );\n        }\n      })\n      .receive(\"error\", ({ reason }) => this.error(reason));\n  }\n}\n", "import { PHX_VIEW_SELECTOR } from \"./constants\";\n\nimport EntryUploader from \"./entry_uploader\";\n\nexport const logError = (msg, obj) => console.error && console.error(msg, obj);\n\nexport const isCid = (cid) => {\n  const type = typeof cid;\n  return type === \"number\" || (type === \"string\" && /^(0|[1-9]\\d*)$/.test(cid));\n};\n\nexport function detectDuplicateIds() {\n  const ids = new Set();\n  const elems = document.querySelectorAll(\"*[id]\");\n  for (let i = 0, len = elems.length; i < len; i++) {\n    if (ids.has(elems[i].id)) {\n      console.error(\n        `Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`,\n      );\n    } else {\n      ids.add(elems[i].id);\n    }\n  }\n}\n\nexport function detectInvalidStreamInserts(inserts) {\n  const errors = new Set();\n  Object.keys(inserts).forEach((id) => {\n    const streamEl = document.getElementById(id);\n    if (\n      streamEl &&\n      streamEl.parentElement &&\n      streamEl.parentElement.getAttribute(\"phx-update\") !== \"stream\"\n    ) {\n      errors.add(\n        `The stream container with id \"${streamEl.parentElement.id}\" is missing the phx-update=\"stream\" attribute. Ensure it is set for streams to work properly.`,\n      );\n    }\n  });\n  errors.forEach((error) => console.error(error));\n}\n\nexport const debug = (view, kind, msg, obj) => {\n  if (view.liveSocket.isDebugEnabled()) {\n    console.log(`${view.id} ${kind}: ${msg} - `, obj);\n  }\n};\n\n// wraps value in closure or returns closure\nexport const closure = (val) =>\n  typeof val === \"function\"\n    ? val\n    : function () {\n        return val;\n      };\n\nexport const clone = (obj) => {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nexport const closestPhxBinding = (el, binding, borderEl) => {\n  do {\n    if (el.matches(`[${binding}]`) && !el.disabled) {\n      return el;\n    }\n    el = el.parentElement || el.parentNode;\n  } while (\n    el !== null &&\n    el.nodeType === 1 &&\n    !((borderEl && borderEl.isSameNode(el)) || el.matches(PHX_VIEW_SELECTOR))\n  );\n  return null;\n};\n\nexport const isObject = (obj) => {\n  return obj !== null && typeof obj === \"object\" && !(obj instanceof Array);\n};\n\nexport const isEqualObj = (obj1, obj2) =>\n  JSON.stringify(obj1) === JSON.stringify(obj2);\n\nexport const isEmpty = (obj) => {\n  for (const x in obj) {\n    return false;\n  }\n  return true;\n};\n\nexport const maybe = (el, callback) => el && callback(el);\n\nexport const channelUploader = function (entries, onError, resp, liveSocket) {\n  entries.forEach((entry) => {\n    const entryUploader = new EntryUploader(entry, resp.config, liveSocket);\n    entryUploader.upload();\n  });\n};\n", "const Browser = {\n  canPushState() {\n    return typeof history.pushState !== \"undefined\";\n  },\n\n  dropLocal(localStorage, namespace, subkey) {\n    return localStorage.removeItem(this.localKey(namespace, subkey));\n  },\n\n  updateLocal(localStorage, namespace, subkey, initial, func) {\n    const current = this.getLocal(localStorage, namespace, subkey);\n    const key = this.localKey(namespace, subkey);\n    const newVal = current === null ? initial : func(current);\n    localStorage.setItem(key, JSON.stringify(newVal));\n    return newVal;\n  },\n\n  getLocal(localStorage, namespace, subkey) {\n    return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));\n  },\n\n  updateCurrentState(callback) {\n    if (!this.canPushState()) {\n      return;\n    }\n    history.replaceState(\n      callback(history.state || {}),\n      \"\",\n      window.location.href,\n    );\n  },\n\n  pushState(kind, meta, to) {\n    if (this.canPushState()) {\n      if (to !== window.location.href) {\n        if (meta.type == \"redirect\" && meta.scroll) {\n          // If we're redirecting store the current scrollY for the current history state.\n          const currentState = history.state || {};\n          currentState.scroll = meta.scroll;\n          history.replaceState(currentState, \"\", window.location.href);\n        }\n\n        delete meta.scroll; // Only store the scroll in the redirect case.\n        history[kind + \"State\"](meta, \"\", to || null); // IE will coerce undefined to string\n\n        // when using navigate, we'd call pushState immediately before patching the DOM,\n        // jumping back to the top of the page, effectively ignoring the scrollIntoView;\n        // therefore we wait for the next frame (after the DOM patch) and only then try\n        // to scroll to the hashEl\n        window.requestAnimationFrame(() => {\n          const hashEl = this.getHashTargetEl(window.location.hash);\n\n          if (hashEl) {\n            hashEl.scrollIntoView();\n          } else if (meta.type === \"redirect\") {\n            window.scroll(0, 0);\n          }\n        });\n      }\n    } else {\n      this.redirect(to);\n    }\n  },\n\n  setCookie(name, value, maxAgeSeconds) {\n    const expires =\n      typeof maxAgeSeconds === \"number\" ? ` max-age=${maxAgeSeconds};` : \"\";\n    document.cookie = `${name}=${value};${expires} path=/`;\n  },\n\n  getCookie(name) {\n    return document.cookie.replace(\n      new RegExp(`(?:(?:^|.*;\\s*)${name}\\s*\\=\\s*([^;]*).*$)|^.*$`),\n      \"$1\",\n    );\n  },\n\n  deleteCookie(name) {\n    document.cookie = `${name}=; max-age=-1; path=/`;\n  },\n\n  redirect(\n    toURL,\n    flash,\n    navigate = (url) => {\n      window.location.href = url;\n    },\n  ) {\n    if (flash) {\n      this.setCookie(\"__phoenix_flash__\", flash, 60);\n    }\n    navigate(toURL);\n  },\n\n  localKey(namespace, subkey) {\n    return `${namespace}-${subkey}`;\n  },\n\n  getHashTargetEl(maybeHash) {\n    const hash = maybeHash.toString().substring(1);\n    if (hash === \"\") {\n      return;\n    }\n    return (\n      document.getElementById(hash) ||\n      document.querySelector(`a[name=\"${hash}\"]`)\n    );\n  },\n};\n\nexport default Browser;\n", "import {\n  CHECKABLE_INPUTS,\n  DEBOUNCE_PREV_KEY,\n  DEBOUNCE_TRIGGER,\n  FOCUSABLE_INPUTS,\n  PHX_COMPONENT,\n  PHX_VIEW_REF,\n  PHX_TELEPORTED_REF,\n  PHX_HAS_FOCUSED,\n  PHX_HAS_SUBMITTED,\n  PHX_MAIN,\n  PHX_PARENT_ID,\n  PHX_PRIVATE,\n  PHX_REF_SRC,\n  PHX_REF_LOCK,\n  PHX_PENDING_ATTRS,\n  PHX_ROOT_ID,\n  PHX_SESSION,\n  PHX_STATIC,\n  PHX_UPLOAD_REF,\n  PHX_VIEW_SELECTOR,\n  PHX_STICKY,\n  PHX_EVENT_CLASSES,\n  THROTTLED,\n  PHX_PORTAL,\n  PHX_STREAM,\n} from \"./constants\";\n\nimport { logError } from \"./utils\";\n\nconst DOM = {\n  byId(id) {\n    return document.getElementById(id) || logError(`no id found for ${id}`);\n  },\n\n  removeClass(el, className) {\n    el.classList.remove(className);\n    if (el.classList.length === 0) {\n      el.removeAttribute(\"class\");\n    }\n  },\n\n  all(node, query, callback) {\n    if (!node) {\n      return [];\n    }\n    const array = Array.from(node.querySelectorAll(query));\n    if (callback) {\n      array.forEach(callback);\n    }\n    return array;\n  },\n\n  childNodeLength(html) {\n    const template = document.createElement(\"template\");\n    template.innerHTML = html;\n    return template.content.childElementCount;\n  },\n\n  isUploadInput(el) {\n    return el.type === \"file\" && el.getAttribute(PHX_UPLOAD_REF) !== null;\n  },\n\n  isAutoUpload(inputEl) {\n    return inputEl.hasAttribute(\"data-phx-auto-upload\");\n  },\n\n  findUploadInputs(node) {\n    const formId = node.id;\n    const inputsOutsideForm = this.all(\n      document,\n      `input[type=\"file\"][${PHX_UPLOAD_REF}][form=\"${formId}\"]`,\n    );\n    return this.all(node, `input[type=\"file\"][${PHX_UPLOAD_REF}]`).concat(\n      inputsOutsideForm,\n    );\n  },\n\n  findComponentNodeList(viewId, cid, doc = document) {\n    return this.all(\n      doc,\n      `[${PHX_VIEW_REF}=\"${viewId}\"][${PHX_COMPONENT}=\"${cid}\"]`,\n    );\n  },\n\n  isPhxDestroyed(node) {\n    return node.id && DOM.private(node, \"destroyed\") ? true : false;\n  },\n\n  wantsNewTab(e) {\n    const wantsNewTab =\n      e.ctrlKey || e.shiftKey || e.metaKey || (e.button && e.button === 1);\n    const isDownload =\n      e.target instanceof HTMLAnchorElement &&\n      e.target.hasAttribute(\"download\");\n    const isTargetBlank =\n      e.target.hasAttribute(\"target\") &&\n      e.target.getAttribute(\"target\").toLowerCase() === \"_blank\";\n    const isTargetNamedTab =\n      e.target.hasAttribute(\"target\") &&\n      !e.target.getAttribute(\"target\").startsWith(\"_\");\n    return wantsNewTab || isTargetBlank || isDownload || isTargetNamedTab;\n  },\n\n  isUnloadableFormSubmit(e) {\n    // Ignore form submissions intended to close a native <dialog> element\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog#usage_notes\n    const isDialogSubmit =\n      (e.target && e.target.getAttribute(\"method\") === \"dialog\") ||\n      (e.submitter && e.submitter.getAttribute(\"formmethod\") === \"dialog\");\n\n    if (isDialogSubmit) {\n      return false;\n    } else {\n      return !e.defaultPrevented && !this.wantsNewTab(e);\n    }\n  },\n\n  isNewPageClick(e, currentLocation) {\n    const href =\n      e.target instanceof HTMLAnchorElement\n        ? e.target.getAttribute(\"href\")\n        : null;\n    let url;\n\n    if (e.defaultPrevented || href === null || this.wantsNewTab(e)) {\n      return false;\n    }\n    if (href.startsWith(\"mailto:\") || href.startsWith(\"tel:\")) {\n      return false;\n    }\n    if (e.target.isContentEditable) {\n      return false;\n    }\n\n    try {\n      url = new URL(href);\n    } catch {\n      try {\n        url = new URL(href, currentLocation);\n      } catch {\n        // bad URL, fallback to let browser try it as external\n        return true;\n      }\n    }\n\n    if (\n      url.host === currentLocation.host &&\n      url.protocol === currentLocation.protocol\n    ) {\n      if (\n        url.pathname === currentLocation.pathname &&\n        url.search === currentLocation.search\n      ) {\n        return url.hash === \"\" && !url.href.endsWith(\"#\");\n      }\n    }\n    return url.protocol.startsWith(\"http\");\n  },\n\n  markPhxChildDestroyed(el) {\n    if (this.isPhxChild(el)) {\n      el.setAttribute(PHX_SESSION, \"\");\n    }\n    this.putPrivate(el, \"destroyed\", true);\n  },\n\n  findPhxChildrenInFragment(html, parentId) {\n    const template = document.createElement(\"template\");\n    template.innerHTML = html;\n    return this.findPhxChildren(template.content, parentId);\n  },\n\n  isIgnored(el, phxUpdate) {\n    return (\n      (el.getAttribute(phxUpdate) || el.getAttribute(\"data-phx-update\")) ===\n      \"ignore\"\n    );\n  },\n\n  isPhxUpdate(el, phxUpdate, updateTypes) {\n    return (\n      el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0\n    );\n  },\n\n  findPhxSticky(el) {\n    return this.all(el, `[${PHX_STICKY}]`);\n  },\n\n  findPhxChildren(el, parentId) {\n    return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}=\"${parentId}\"]`);\n  },\n\n  findExistingParentCIDs(viewId, cids) {\n    // we only want to find parents that exist on the page\n    // if a cid is not on the page, the only way it can be added back to the page\n    // is if a parent adds it back, therefore if a cid does not exist on the page,\n    // we should not try to render it by itself (because it would be rendered twice,\n    // one by the parent, and a second time by itself)\n    const parentCids = new Set();\n    const childrenCids = new Set();\n\n    cids.forEach((cid) => {\n      this.all(\n        document,\n        `[${PHX_VIEW_REF}=\"${viewId}\"][${PHX_COMPONENT}=\"${cid}\"]`,\n      ).forEach((parent) => {\n        parentCids.add(cid);\n        this.all(parent, `[${PHX_VIEW_REF}=\"${viewId}\"][${PHX_COMPONENT}]`)\n          .map((el) => parseInt(el.getAttribute(PHX_COMPONENT)))\n          .forEach((childCID) => childrenCids.add(childCID));\n      });\n    });\n\n    childrenCids.forEach((childCid) => parentCids.delete(childCid));\n\n    return parentCids;\n  },\n\n  private(el, key) {\n    return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];\n  },\n\n  deletePrivate(el, key) {\n    el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];\n  },\n\n  putPrivate(el, key, value) {\n    if (!el[PHX_PRIVATE]) {\n      el[PHX_PRIVATE] = {};\n    }\n    el[PHX_PRIVATE][key] = value;\n  },\n\n  updatePrivate(el, key, defaultVal, updateFunc) {\n    const existing = this.private(el, key);\n    if (existing === undefined) {\n      this.putPrivate(el, key, updateFunc(defaultVal));\n    } else {\n      this.putPrivate(el, key, updateFunc(existing));\n    }\n  },\n\n  syncPendingAttrs(fromEl, toEl) {\n    if (!fromEl.hasAttribute(PHX_REF_SRC)) {\n      return;\n    }\n    PHX_EVENT_CLASSES.forEach((className) => {\n      fromEl.classList.contains(className) && toEl.classList.add(className);\n    });\n    PHX_PENDING_ATTRS.filter((attr) => fromEl.hasAttribute(attr)).forEach(\n      (attr) => {\n        toEl.setAttribute(attr, fromEl.getAttribute(attr));\n      },\n    );\n  },\n\n  copyPrivates(target, source) {\n    if (source[PHX_PRIVATE]) {\n      target[PHX_PRIVATE] = source[PHX_PRIVATE];\n    }\n  },\n\n  putTitle(str) {\n    const titleEl = document.querySelector(\"title\");\n    if (titleEl) {\n      const { prefix, suffix, default: defaultTitle } = titleEl.dataset;\n      const isEmpty = typeof str !== \"string\" || str.trim() === \"\";\n      if (isEmpty && typeof defaultTitle !== \"string\") {\n        return;\n      }\n\n      const inner = isEmpty ? defaultTitle : str;\n      document.title = `${prefix || \"\"}${inner || \"\"}${suffix || \"\"}`;\n    } else {\n      document.title = str;\n    }\n  },\n\n  debounce(\n    el,\n    event,\n    phxDebounce,\n    defaultDebounce,\n    phxThrottle,\n    defaultThrottle,\n    asyncFilter,\n    callback,\n  ) {\n    let debounce = el.getAttribute(phxDebounce);\n    let throttle = el.getAttribute(phxThrottle);\n\n    if (debounce === \"\") {\n      debounce = defaultDebounce;\n    }\n    if (throttle === \"\") {\n      throttle = defaultThrottle;\n    }\n    const value = debounce || throttle;\n    switch (value) {\n      case null:\n        return callback();\n\n      case \"blur\":\n        this.incCycle(el, \"debounce-blur-cycle\", () => {\n          if (asyncFilter()) {\n            callback();\n          }\n        });\n        if (this.once(el, \"debounce-blur\")) {\n          el.addEventListener(\"blur\", () =>\n            this.triggerCycle(el, \"debounce-blur-cycle\"),\n          );\n        }\n        return;\n\n      default:\n        const timeout = parseInt(value);\n        const trigger = () =>\n          throttle ? this.deletePrivate(el, THROTTLED) : callback();\n        const currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);\n        if (isNaN(timeout)) {\n          return logError(`invalid throttle/debounce value: ${value}`);\n        }\n        if (throttle) {\n          let newKeyDown = false;\n          if (event.type === \"keydown\") {\n            const prevKey = this.private(el, DEBOUNCE_PREV_KEY);\n            this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);\n            newKeyDown = prevKey !== event.key;\n          }\n\n          if (!newKeyDown && this.private(el, THROTTLED)) {\n            return false;\n          } else {\n            callback();\n            const t = setTimeout(() => {\n              if (asyncFilter()) {\n                this.triggerCycle(el, DEBOUNCE_TRIGGER);\n              }\n            }, timeout);\n            this.putPrivate(el, THROTTLED, t);\n          }\n        } else {\n          setTimeout(() => {\n            if (asyncFilter()) {\n              this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);\n            }\n          }, timeout);\n        }\n\n        const form = el.form;\n        if (form && this.once(form, \"bind-debounce\")) {\n          form.addEventListener(\"submit\", () => {\n            Array.from(new FormData(form).entries(), ([name]) => {\n              const input = form.querySelector(`[name=\"${name}\"]`);\n              this.incCycle(input, DEBOUNCE_TRIGGER);\n              this.deletePrivate(input, THROTTLED);\n            });\n          });\n        }\n        if (this.once(el, \"bind-debounce\")) {\n          el.addEventListener(\"blur\", () => {\n            // because we trigger the callback here,\n            // we also clear the throttle timeout to prevent the callback\n            // from being called again after the timeout fires\n            clearTimeout(this.private(el, THROTTLED));\n            this.triggerCycle(el, DEBOUNCE_TRIGGER);\n          });\n        }\n    }\n  },\n\n  triggerCycle(el, key, currentCycle) {\n    const [cycle, trigger] = this.private(el, key);\n    if (!currentCycle) {\n      currentCycle = cycle;\n    }\n    if (currentCycle === cycle) {\n      this.incCycle(el, key);\n      trigger();\n    }\n  },\n\n  once(el, key) {\n    if (this.private(el, key) === true) {\n      return false;\n    }\n    this.putPrivate(el, key, true);\n    return true;\n  },\n\n  incCycle(el, key, trigger = function () {}) {\n    let [currentCycle] = this.private(el, key) || [0, trigger];\n    currentCycle++;\n    this.putPrivate(el, key, [currentCycle, trigger]);\n    return currentCycle;\n  },\n\n  // maintains or adds privately used hook information\n  // fromEl and toEl can be the same element in the case of a newly added node\n  // fromEl and toEl can be any HTML node type, so we need to check if it's an element node\n  maintainPrivateHooks(fromEl, toEl, phxViewportTop, phxViewportBottom) {\n    // maintain the hooks created with createHook\n    if (\n      fromEl.hasAttribute &&\n      fromEl.hasAttribute(\"data-phx-hook\") &&\n      !toEl.hasAttribute(\"data-phx-hook\")\n    ) {\n      toEl.setAttribute(\"data-phx-hook\", fromEl.getAttribute(\"data-phx-hook\"));\n    }\n    // add hooks to elements with viewport attributes\n    if (\n      toEl.hasAttribute &&\n      (toEl.hasAttribute(phxViewportTop) ||\n        toEl.hasAttribute(phxViewportBottom))\n    ) {\n      toEl.setAttribute(\"data-phx-hook\", \"Phoenix.InfiniteScroll\");\n    }\n  },\n\n  putCustomElHook(el, hook) {\n    if (el.isConnected) {\n      el.setAttribute(\"data-phx-hook\", \"\");\n    } else {\n      console.error(`\n        hook attached to non-connected DOM element\n        ensure you are calling createHook within your connectedCallback. ${el.outerHTML}\n      `);\n    }\n    this.putPrivate(el, \"custom-el-hook\", hook);\n  },\n\n  getCustomElHook(el) {\n    return this.private(el, \"custom-el-hook\");\n  },\n\n  isUsedInput(el) {\n    return (\n      el.nodeType === Node.ELEMENT_NODE &&\n      (this.private(el, PHX_HAS_FOCUSED) || this.private(el, PHX_HAS_SUBMITTED))\n    );\n  },\n\n  resetForm(form) {\n    Array.from(form.elements).forEach((input) => {\n      this.deletePrivate(input, PHX_HAS_FOCUSED);\n      this.deletePrivate(input, PHX_HAS_SUBMITTED);\n    });\n  },\n\n  isPhxChild(node) {\n    return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\n  },\n\n  isPhxSticky(node) {\n    return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;\n  },\n\n  isChildOfAny(el, parents) {\n    return !!parents.find((parent) => parent.contains(el));\n  },\n\n  firstPhxChild(el) {\n    return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];\n  },\n\n  isPortalTemplate(el) {\n    return el.tagName === \"TEMPLATE\" && el.hasAttribute(PHX_PORTAL);\n  },\n\n  closestViewEl(el) {\n    // find the closest portal or view element, whichever comes first\n    const portalOrViewEl = el.closest(\n      `[${PHX_TELEPORTED_REF}],${PHX_VIEW_SELECTOR}`,\n    );\n    if (!portalOrViewEl) {\n      return null;\n    }\n    if (portalOrViewEl.hasAttribute(PHX_TELEPORTED_REF)) {\n      // PHX_TELEPORTED_REF is set to the id of the view that owns the portal element\n      return this.byId(portalOrViewEl.getAttribute(PHX_TELEPORTED_REF));\n    } else if (portalOrViewEl.hasAttribute(PHX_SESSION)) {\n      return portalOrViewEl;\n    }\n    return null;\n  },\n\n  dispatchEvent(target, name, opts = {}) {\n    let defaultBubble = true;\n    const isUploadTarget =\n      target.nodeName === \"INPUT\" && target.type === \"file\";\n    if (isUploadTarget && name === \"click\") {\n      defaultBubble = false;\n    }\n    const bubbles = opts.bubbles === undefined ? defaultBubble : !!opts.bubbles;\n    const eventOpts = {\n      bubbles: bubbles,\n      cancelable: true,\n      detail: opts.detail || {},\n    };\n    const event =\n      name === \"click\"\n        ? new MouseEvent(\"click\", eventOpts)\n        : new CustomEvent(name, eventOpts);\n    target.dispatchEvent(event);\n  },\n\n  cloneNode(node, html) {\n    if (typeof html === \"undefined\") {\n      return node.cloneNode(true);\n    } else {\n      const cloned = node.cloneNode(false);\n      cloned.innerHTML = html;\n      return cloned;\n    }\n  },\n\n  // merge attributes from source to target\n  // if an element is ignored, we only merge data attributes\n  // including removing data attributes that are no longer in the source\n  mergeAttrs(target, source, opts = {}) {\n    const exclude = new Set(opts.exclude || []);\n    const isIgnored = opts.isIgnored;\n    const sourceAttrs = source.attributes;\n    for (let i = sourceAttrs.length - 1; i >= 0; i--) {\n      const name = sourceAttrs[i].name;\n      if (!exclude.has(name)) {\n        const sourceValue = source.getAttribute(name);\n        if (\n          target.getAttribute(name) !== sourceValue &&\n          (!isIgnored || (isIgnored && name.startsWith(\"data-\")))\n        ) {\n          target.setAttribute(name, sourceValue);\n        }\n      } else {\n        // We exclude the value from being merged on focused inputs, because the\n        // user's input should always win.\n        // We can still assign it as long as the value property is the same, though.\n        // This prevents a situation where the updated hook is not being triggered\n        // when an input is back in its \"original state\", because the attribute\n        // was never changed, see:\n        // https://github.com/phoenixframework/phoenix_live_view/issues/2163\n        if (name === \"value\" && target.value === source.value) {\n          // actually set the value attribute to sync it with the value property\n          target.setAttribute(\"value\", source.getAttribute(name));\n        }\n      }\n    }\n\n    const targetAttrs = target.attributes;\n    for (let i = targetAttrs.length - 1; i >= 0; i--) {\n      const name = targetAttrs[i].name;\n      if (isIgnored) {\n        if (\n          name.startsWith(\"data-\") &&\n          !source.hasAttribute(name) &&\n          !PHX_PENDING_ATTRS.includes(name)\n        ) {\n          target.removeAttribute(name);\n        }\n      } else {\n        if (!source.hasAttribute(name)) {\n          target.removeAttribute(name);\n        }\n      }\n    }\n  },\n\n  mergeFocusedInput(target, source) {\n    // skip selects because FF will reset highlighted index for any setAttribute\n    if (!(target instanceof HTMLSelectElement)) {\n      DOM.mergeAttrs(target, source, { exclude: [\"value\"] });\n    }\n\n    if (source.readOnly) {\n      target.setAttribute(\"readonly\", true);\n    } else {\n      target.removeAttribute(\"readonly\");\n    }\n  },\n\n  hasSelectionRange(el) {\n    return (\n      el.setSelectionRange && (el.type === \"text\" || el.type === \"textarea\")\n    );\n  },\n\n  restoreFocus(focused, selectionStart, selectionEnd) {\n    if (focused instanceof HTMLSelectElement) {\n      focused.focus();\n    }\n    if (!DOM.isTextualInput(focused)) {\n      return;\n    }\n\n    const wasFocused = focused.matches(\":focus\");\n    if (!wasFocused) {\n      focused.focus();\n    }\n    if (this.hasSelectionRange(focused)) {\n      focused.setSelectionRange(selectionStart, selectionEnd);\n    }\n  },\n\n  isFormInput(el) {\n    if (el.localName && customElements.get(el.localName)) {\n      // Custom Elements may be form associated. This allows them\n      // to participate within a form's lifecycle, including form\n      // validity and form submissions.\n      // The spec for Form Associated custom elements requires the\n      // custom element's class to contain a static boolean value of `formAssociated`\n      // which identifies this class as allowed to associate to a form.\n      // See https://html.spec.whatwg.org/dev/custom-elements.html#custom-elements-face-example\n      // for details.\n      return customElements.get(el.localName)[`formAssociated`];\n    }\n\n    return (\n      /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== \"button\"\n    );\n  },\n\n  syncAttrsToProps(el) {\n    if (\n      el instanceof HTMLInputElement &&\n      CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0\n    ) {\n      el.checked = el.getAttribute(\"checked\") !== null;\n    }\n  },\n\n  isTextualInput(el) {\n    return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\n  },\n\n  isNowTriggerFormExternal(el, phxTriggerExternal) {\n    return (\n      el.getAttribute &&\n      el.getAttribute(phxTriggerExternal) !== null &&\n      document.body.contains(el)\n    );\n  },\n\n  cleanChildNodes(container, phxUpdate) {\n    if (\n      DOM.isPhxUpdate(container, phxUpdate, [\"append\", \"prepend\", PHX_STREAM])\n    ) {\n      const toRemove = [];\n      container.childNodes.forEach((childNode) => {\n        if (!childNode.id) {\n          // Skip warning if it's an empty text node (e.g. a new-line)\n          const isEmptyTextNode =\n            childNode.nodeType === Node.TEXT_NODE &&\n            childNode.nodeValue.trim() === \"\";\n          if (!isEmptyTextNode && childNode.nodeType !== Node.COMMENT_NODE) {\n            logError(\n              \"only HTML element tags with an id are allowed inside containers with phx-update.\\n\\n\" +\n                `removing illegal node: \"${(childNode.outerHTML || childNode.nodeValue).trim()}\"\\n\\n`,\n            );\n          }\n          toRemove.push(childNode);\n        }\n      });\n      toRemove.forEach((childNode) => childNode.remove());\n    }\n  },\n\n  replaceRootContainer(container, tagName, attrs) {\n    const retainedAttrs = new Set([\n      \"id\",\n      PHX_SESSION,\n      PHX_STATIC,\n      PHX_MAIN,\n      PHX_ROOT_ID,\n    ]);\n    if (container.tagName.toLowerCase() === tagName.toLowerCase()) {\n      Array.from(container.attributes)\n        .filter((attr) => !retainedAttrs.has(attr.name.toLowerCase()))\n        .forEach((attr) => container.removeAttribute(attr.name));\n\n      Object.keys(attrs)\n        .filter((name) => !retainedAttrs.has(name.toLowerCase()))\n        .forEach((attr) => container.setAttribute(attr, attrs[attr]));\n\n      return container;\n    } else {\n      const newContainer = document.createElement(tagName);\n      Object.keys(attrs).forEach((attr) =>\n        newContainer.setAttribute(attr, attrs[attr]),\n      );\n      retainedAttrs.forEach((attr) =>\n        newContainer.setAttribute(attr, container.getAttribute(attr)),\n      );\n      newContainer.innerHTML = container.innerHTML;\n      container.replaceWith(newContainer);\n      return newContainer;\n    }\n  },\n\n  getSticky(el, name, defaultVal) {\n    const op = (DOM.private(el, \"sticky\") || []).find(\n      ([existingName]) => name === existingName,\n    );\n    if (op) {\n      const [_name, _op, stashedResult] = op;\n      return stashedResult;\n    } else {\n      return typeof defaultVal === \"function\" ? defaultVal() : defaultVal;\n    }\n  },\n\n  deleteSticky(el, name) {\n    this.updatePrivate(el, \"sticky\", [], (ops) => {\n      return ops.filter(([existingName, _]) => existingName !== name);\n    });\n  },\n\n  putSticky(el, name, op) {\n    const stashedResult = op(el);\n    this.updatePrivate(el, \"sticky\", [], (ops) => {\n      const existingIndex = ops.findIndex(\n        ([existingName]) => name === existingName,\n      );\n      if (existingIndex >= 0) {\n        ops[existingIndex] = [name, op, stashedResult];\n      } else {\n        ops.push([name, op, stashedResult]);\n      }\n      return ops;\n    });\n  },\n\n  applyStickyOperations(el) {\n    const ops = DOM.private(el, \"sticky\");\n    if (!ops) {\n      return;\n    }\n\n    ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));\n  },\n\n  isLocked(el) {\n    return el.hasAttribute && el.hasAttribute(PHX_REF_LOCK);\n  },\n};\n\nexport default DOM;\n", "import {\n  PHX_ACTIVE_ENTRY_REFS,\n  PHX_LIVE_FILE_UPDATED,\n  PHX_PREFLIGHTED_REFS,\n} from \"./constants\";\n\nimport { channelUploader, logError } from \"./utils\";\n\nimport LiveUploader from \"./live_uploader\";\n\nexport default class UploadEntry {\n  static isActive(fileEl, file) {\n    const isNew = file._phxRef === undefined;\n    const activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n    const isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n    return file.size > 0 && (isNew || isActive);\n  }\n\n  static isPreflighted(fileEl, file) {\n    const preflightedRefs = fileEl\n      .getAttribute(PHX_PREFLIGHTED_REFS)\n      .split(\",\");\n    const isPreflighted =\n      preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n    return isPreflighted && this.isActive(fileEl, file);\n  }\n\n  static isPreflightInProgress(file) {\n    return file._preflightInProgress === true;\n  }\n\n  static markPreflightInProgress(file) {\n    file._preflightInProgress = true;\n  }\n\n  constructor(fileEl, file, view, autoUpload) {\n    this.ref = LiveUploader.genFileRef(file);\n    this.fileEl = fileEl;\n    this.file = file;\n    this.view = view;\n    this.meta = null;\n    this._isCancelled = false;\n    this._isDone = false;\n    this._progress = 0;\n    this._lastProgressSent = -1;\n    this._onDone = function () {};\n    this._onElUpdated = this.onElUpdated.bind(this);\n    this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n    this.autoUpload = autoUpload;\n  }\n\n  metadata() {\n    return this.meta;\n  }\n\n  progress(progress) {\n    this._progress = Math.floor(progress);\n    if (this._progress > this._lastProgressSent) {\n      if (this._progress >= 100) {\n        this._progress = 100;\n        this._lastProgressSent = 100;\n        this._isDone = true;\n        this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {\n          LiveUploader.untrackFile(this.fileEl, this.file);\n          this._onDone();\n        });\n      } else {\n        this._lastProgressSent = this._progress;\n        this.view.pushFileProgress(this.fileEl, this.ref, this._progress);\n      }\n    }\n  }\n\n  isCancelled() {\n    return this._isCancelled;\n  }\n\n  cancel() {\n    this.file._preflightInProgress = false;\n    this._isCancelled = true;\n    this._isDone = true;\n    this._onDone();\n  }\n\n  isDone() {\n    return this._isDone;\n  }\n\n  error(reason = \"failed\") {\n    this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n    this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });\n    if (!this.isAutoUpload()) {\n      LiveUploader.clearFiles(this.fileEl);\n    }\n  }\n\n  isAutoUpload() {\n    return this.autoUpload;\n  }\n\n  //private\n\n  onDone(callback) {\n    this._onDone = () => {\n      this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n      callback();\n    };\n  }\n\n  onElUpdated() {\n    const activeRefs = this.fileEl\n      .getAttribute(PHX_ACTIVE_ENTRY_REFS)\n      .split(\",\");\n    if (activeRefs.indexOf(this.ref) === -1) {\n      LiveUploader.untrackFile(this.fileEl, this.file);\n      this.cancel();\n    }\n  }\n\n  toPreflightPayload() {\n    return {\n      last_modified: this.file.lastModified,\n      name: this.file.name,\n      relative_path: this.file.webkitRelativePath,\n      size: this.file.size,\n      type: this.file.type,\n      ref: this.ref,\n      meta: typeof this.file.meta === \"function\" ? this.file.meta() : undefined,\n    };\n  }\n\n  uploader(uploaders) {\n    if (this.meta.uploader) {\n      const callback =\n        uploaders[this.meta.uploader] ||\n        logError(`no uploader configured for ${this.meta.uploader}`);\n      return { name: this.meta.uploader, callback: callback };\n    } else {\n      return { name: \"channel\", callback: channelUploader };\n    }\n  }\n\n  zipPostFlight(resp) {\n    this.meta = resp.entries[this.ref];\n    if (!this.meta) {\n      logError(`no preflight upload response returned with ref ${this.ref}`, {\n        input: this.fileEl,\n        response: resp,\n      });\n    }\n  }\n}\n", "import {\n  PHX_DONE_REFS,\n  PHX_PREFLIGHTED_REFS,\n  PHX_UPLOAD_REF,\n} from \"./constants\";\n\nimport {} from \"./utils\";\n\nimport DOM from \"./dom\";\nimport UploadEntry from \"./upload_entry\";\n\nlet liveUploaderFileRef = 0;\n\nexport default class LiveUploader {\n  static genFileRef(file) {\n    const ref = file._phxRef;\n    if (ref !== undefined) {\n      return ref;\n    } else {\n      file._phxRef = (liveUploaderFileRef++).toString();\n      return file._phxRef;\n    }\n  }\n\n  static getEntryDataURL(inputEl, ref, callback) {\n    const file = this.activeFiles(inputEl).find(\n      (file) => this.genFileRef(file) === ref,\n    );\n    callback(URL.createObjectURL(file));\n  }\n\n  static hasUploadsInProgress(formEl) {\n    let active = 0;\n    DOM.findUploadInputs(formEl).forEach((input) => {\n      if (\n        input.getAttribute(PHX_PREFLIGHTED_REFS) !==\n        input.getAttribute(PHX_DONE_REFS)\n      ) {\n        active++;\n      }\n    });\n    return active > 0;\n  }\n\n  static serializeUploads(inputEl) {\n    const files = this.activeFiles(inputEl);\n    const fileData = {};\n    files.forEach((file) => {\n      const entry = { path: inputEl.name };\n      const uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);\n      fileData[uploadRef] = fileData[uploadRef] || [];\n      entry.ref = this.genFileRef(file);\n      entry.last_modified = file.lastModified;\n      entry.name = file.name || entry.ref;\n      entry.relative_path = file.webkitRelativePath;\n      entry.type = file.type;\n      entry.size = file.size;\n      if (typeof file.meta === \"function\") {\n        entry.meta = file.meta();\n      }\n      fileData[uploadRef].push(entry);\n    });\n    return fileData;\n  }\n\n  static clearFiles(inputEl) {\n    inputEl.value = null;\n    inputEl.removeAttribute(PHX_UPLOAD_REF);\n    DOM.putPrivate(inputEl, \"files\", []);\n  }\n\n  static untrackFile(inputEl, file) {\n    DOM.putPrivate(\n      inputEl,\n      \"files\",\n      DOM.private(inputEl, \"files\").filter((f) => !Object.is(f, file)),\n    );\n  }\n\n  /**\n   * @param {HTMLInputElement} inputEl\n   * @param {Array<File|Blob>} files\n   * @param {DataTransfer} [dataTransfer]\n   */\n  static trackFiles(inputEl, files, dataTransfer) {\n    if (inputEl.getAttribute(\"multiple\") !== null) {\n      const newFiles = files.filter(\n        (file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)),\n      );\n      DOM.updatePrivate(inputEl, \"files\", [], (existing) =>\n        existing.concat(newFiles),\n      );\n      inputEl.value = null;\n    } else {\n      // Reset inputEl files to align output with programmatic changes (i.e. drag and drop)\n      if (dataTransfer && dataTransfer.files.length > 0) {\n        inputEl.files = dataTransfer.files;\n      }\n      DOM.putPrivate(inputEl, \"files\", files);\n    }\n  }\n\n  static activeFileInputs(formEl) {\n    const fileInputs = DOM.findUploadInputs(formEl);\n    return Array.from(fileInputs).filter(\n      (el) => el.files && this.activeFiles(el).length > 0,\n    );\n  }\n\n  static activeFiles(input) {\n    return (DOM.private(input, \"files\") || []).filter((f) =>\n      UploadEntry.isActive(input, f),\n    );\n  }\n\n  static inputsAwaitingPreflight(formEl) {\n    const fileInputs = DOM.findUploadInputs(formEl);\n    return Array.from(fileInputs).filter(\n      (input) => this.filesAwaitingPreflight(input).length > 0,\n    );\n  }\n\n  static filesAwaitingPreflight(input) {\n    return this.activeFiles(input).filter(\n      (f) =>\n        !UploadEntry.isPreflighted(input, f) &&\n        !UploadEntry.isPreflightInProgress(f),\n    );\n  }\n\n  static markPreflightInProgress(entries) {\n    entries.forEach((entry) => UploadEntry.markPreflightInProgress(entry.file));\n  }\n\n  constructor(inputEl, view, onComplete) {\n    this.autoUpload = DOM.isAutoUpload(inputEl);\n    this.view = view;\n    this.onComplete = onComplete;\n    this._entries = Array.from(\n      LiveUploader.filesAwaitingPreflight(inputEl) || [],\n    ).map((file) => new UploadEntry(inputEl, file, view, this.autoUpload));\n\n    // prevent sending duplicate preflight requests\n    LiveUploader.markPreflightInProgress(this._entries);\n\n    this.numEntriesInProgress = this._entries.length;\n  }\n\n  isAutoUpload() {\n    return this.autoUpload;\n  }\n\n  entries() {\n    return this._entries;\n  }\n\n  initAdapterUpload(resp, onError, liveSocket) {\n    this._entries = this._entries.map((entry) => {\n      if (entry.isCancelled()) {\n        this.numEntriesInProgress--;\n        if (this.numEntriesInProgress === 0) {\n          this.onComplete();\n        }\n      } else {\n        entry.zipPostFlight(resp);\n        entry.onDone(() => {\n          this.numEntriesInProgress--;\n          if (this.numEntriesInProgress === 0) {\n            this.onComplete();\n          }\n        });\n      }\n      return entry;\n    });\n\n    const groupedEntries = this._entries.reduce((acc, entry) => {\n      if (!entry.meta) {\n        return acc;\n      }\n      const { name, callback } = entry.uploader(liveSocket.uploaders);\n      acc[name] = acc[name] || { callback: callback, entries: [] };\n      acc[name].entries.push(entry);\n      return acc;\n    }, {});\n\n    for (const name in groupedEntries) {\n      const { callback, entries } = groupedEntries[name];\n      callback(entries, onError, resp, liveSocket);\n    }\n  }\n}\n", "const ARIA = {\n  anyOf(instance, classes) {\n    return classes.find((name) => instance instanceof name);\n  },\n\n  isFocusable(el, interactiveOnly) {\n    return (\n      (el instanceof HTMLAnchorElement && el.rel !== \"ignore\") ||\n      (el instanceof HTMLAreaElement && el.href !== undefined) ||\n      (!el.disabled &&\n        this.anyOf(el, [\n          HTMLInputElement,\n          HTMLSelectElement,\n          HTMLTextAreaElement,\n          HTMLButtonElement,\n        ])) ||\n      el instanceof HTMLIFrameElement ||\n      (el.tabIndex >= 0 && el.getAttribute(\"aria-hidden\") !== \"true\") ||\n      (!interactiveOnly &&\n        el.getAttribute(\"tabindex\") !== null &&\n        el.getAttribute(\"aria-hidden\") !== \"true\")\n    );\n  },\n\n  attemptFocus(el, interactiveOnly) {\n    if (this.isFocusable(el, interactiveOnly)) {\n      try {\n        el.focus();\n      } catch {\n        // that's fine\n      }\n    }\n    return !!document.activeElement && document.activeElement.isSameNode(el);\n  },\n\n  focusFirstInteractive(el) {\n    let child = el.firstElementChild;\n    while (child) {\n      if (this.attemptFocus(child, true) || this.focusFirstInteractive(child)) {\n        return true;\n      }\n      child = child.nextElementSibling;\n    }\n  },\n\n  focusFirst(el) {\n    let child = el.firstElementChild;\n    while (child) {\n      if (this.attemptFocus(child) || this.focusFirst(child)) {\n        return true;\n      }\n      child = child.nextElementSibling;\n    }\n  },\n\n  focusLast(el) {\n    let child = el.lastElementChild;\n    while (child) {\n      if (this.attemptFocus(child) || this.focusLast(child)) {\n        return true;\n      }\n      child = child.previousElementSibling;\n    }\n  },\n};\nexport default ARIA;\n", "import {\n  PHX_ACTIVE_ENTRY_REFS,\n  PHX_LIVE_FILE_UPDATED,\n  PHX_PREFLIGHTED_REFS,\n  PHX_UPLOAD_REF,\n} from \"./constants\";\n\nimport LiveUploader from \"./live_uploader\";\nimport ARIA from \"./aria\";\n\nconst Hooks = {\n  LiveFileUpload: {\n    activeRefs() {\n      return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);\n    },\n\n    preflightedRefs() {\n      return this.el.getAttribute(PHX_PREFLIGHTED_REFS);\n    },\n\n    mounted() {\n      this.preflightedWas = this.preflightedRefs();\n    },\n\n    updated() {\n      const newPreflights = this.preflightedRefs();\n      if (this.preflightedWas !== newPreflights) {\n        this.preflightedWas = newPreflights;\n        if (newPreflights === \"\") {\n          this.__view().cancelSubmit(this.el.form);\n        }\n      }\n\n      if (this.activeRefs() === \"\") {\n        this.el.value = null;\n      }\n      this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));\n    },\n  },\n\n  LiveImgPreview: {\n    mounted() {\n      this.ref = this.el.getAttribute(\"data-phx-entry-ref\");\n      this.inputEl = document.getElementById(\n        this.el.getAttribute(PHX_UPLOAD_REF),\n      );\n      LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {\n        this.url = url;\n        this.el.src = url;\n      });\n    },\n    destroyed() {\n      URL.revokeObjectURL(this.url);\n    },\n  },\n  FocusWrap: {\n    mounted() {\n      this.focusStart = this.el.firstElementChild;\n      this.focusEnd = this.el.lastElementChild;\n      this.focusStart.addEventListener(\"focus\", (e) => {\n        if (!e.relatedTarget || !this.el.contains(e.relatedTarget)) {\n          // Handle focus entering from outside (e.g. Tab when body is focused)\n          // https://github.com/phoenixframework/phoenix_live_view/issues/3636\n          const nextFocus = e.target.nextElementSibling;\n          ARIA.attemptFocus(nextFocus) || ARIA.focusFirst(nextFocus);\n        } else {\n          ARIA.focusLast(this.el);\n        }\n      });\n      this.focusEnd.addEventListener(\"focus\", (e) => {\n        if (!e.relatedTarget || !this.el.contains(e.relatedTarget)) {\n          // Handle focus entering from outside (e.g. Shift+Tab when body is focused)\n          // https://github.com/phoenixframework/phoenix_live_view/issues/3636\n          const nextFocus = e.target.previousElementSibling;\n          ARIA.attemptFocus(nextFocus) || ARIA.focusLast(nextFocus);\n        } else {\n          ARIA.focusFirst(this.el);\n        }\n      });\n      // only try to change the focus if it is not already inside\n      if (!this.el.contains(document.activeElement)) {\n        this.el.addEventListener(\"phx:show-end\", () => this.el.focus());\n        if (window.getComputedStyle(this.el).display !== \"none\") {\n          ARIA.focusFirst(this.el);\n        }\n      }\n    },\n  },\n};\n\nconst findScrollContainer = (el) => {\n  // the scroll event won't be fired on the html/body element even if overflow is set\n  // therefore we return null to instead listen for scroll events on document\n  if ([\"HTML\", \"BODY\"].indexOf(el.nodeName.toUpperCase()) >= 0) return null;\n  if ([\"scroll\", \"auto\"].indexOf(getComputedStyle(el).overflowY) >= 0)\n    return el;\n  return findScrollContainer(el.parentElement);\n};\n\nconst scrollTop = (scrollContainer) => {\n  if (scrollContainer) {\n    return scrollContainer.scrollTop;\n  } else {\n    return document.documentElement.scrollTop || document.body.scrollTop;\n  }\n};\n\nconst bottom = (scrollContainer) => {\n  if (scrollContainer) {\n    return scrollContainer.getBoundingClientRect().bottom;\n  } else {\n    // when we have no container, the whole page scrolls,\n    // therefore the bottom coordinate is the viewport height\n    return window.innerHeight || document.documentElement.clientHeight;\n  }\n};\n\nconst top = (scrollContainer) => {\n  if (scrollContainer) {\n    return scrollContainer.getBoundingClientRect().top;\n  } else {\n    // when we have no container the whole page scrolls,\n    // therefore the top coordinate is 0\n    return 0;\n  }\n};\n\nconst isAtViewportTop = (el, scrollContainer) => {\n  const rect = el.getBoundingClientRect();\n  return (\n    Math.ceil(rect.top) >= top(scrollContainer) &&\n    Math.ceil(rect.left) >= 0 &&\n    Math.floor(rect.top) <= bottom(scrollContainer)\n  );\n};\n\nconst isAtViewportBottom = (el, scrollContainer) => {\n  const rect = el.getBoundingClientRect();\n  return (\n    Math.ceil(rect.bottom) >= top(scrollContainer) &&\n    Math.ceil(rect.left) >= 0 &&\n    Math.floor(rect.bottom) <= bottom(scrollContainer)\n  );\n};\n\nconst isWithinViewport = (el, scrollContainer) => {\n  const rect = el.getBoundingClientRect();\n  return (\n    Math.ceil(rect.top) >= top(scrollContainer) &&\n    Math.ceil(rect.left) >= 0 &&\n    Math.floor(rect.top) <= bottom(scrollContainer)\n  );\n};\n\nHooks.InfiniteScroll = {\n  mounted() {\n    this.scrollContainer = findScrollContainer(this.el);\n    let scrollBefore = scrollTop(this.scrollContainer);\n    let topOverran = false;\n    const throttleInterval = 500;\n    let pendingOp = null;\n\n    const onTopOverrun = this.throttle(\n      throttleInterval,\n      (topEvent, firstChild) => {\n        pendingOp = () => true;\n        this.liveSocket.js().push(this.el, topEvent, {\n          value: { id: firstChild.id, _overran: true },\n          callback: () => {\n            pendingOp = null;\n          },\n        });\n      },\n    );\n\n    const onFirstChildAtTop = this.throttle(\n      throttleInterval,\n      (topEvent, firstChild) => {\n        pendingOp = () => firstChild.scrollIntoView({ block: \"start\" });\n        this.liveSocket.js().push(this.el, topEvent, {\n          value: { id: firstChild.id },\n          callback: () => {\n            pendingOp = null;\n            // make sure that the DOM is patched by waiting for the next tick\n            window.requestAnimationFrame(() => {\n              if (!isWithinViewport(firstChild, this.scrollContainer)) {\n                firstChild.scrollIntoView({ block: \"start\" });\n              }\n            });\n          },\n        });\n      },\n    );\n\n    const onLastChildAtBottom = this.throttle(\n      throttleInterval,\n      (bottomEvent, lastChild) => {\n        pendingOp = () => lastChild.scrollIntoView({ block: \"end\" });\n        this.liveSocket.js().push(this.el, bottomEvent, {\n          value: { id: lastChild.id },\n          callback: () => {\n            pendingOp = null;\n            // make sure that the DOM is patched by waiting for the next tick\n            window.requestAnimationFrame(() => {\n              if (!isWithinViewport(lastChild, this.scrollContainer)) {\n                lastChild.scrollIntoView({ block: \"end\" });\n              }\n            });\n          },\n        });\n      },\n    );\n\n    this.onScroll = (_e) => {\n      const scrollNow = scrollTop(this.scrollContainer);\n\n      if (pendingOp) {\n        scrollBefore = scrollNow;\n        return pendingOp();\n      }\n      const rect = this.el.getBoundingClientRect();\n      const topEvent = this.el.getAttribute(\n        this.liveSocket.binding(\"viewport-top\"),\n      );\n      const bottomEvent = this.el.getAttribute(\n        this.liveSocket.binding(\"viewport-bottom\"),\n      );\n      const lastChild = this.el.lastElementChild;\n      const firstChild = this.el.firstElementChild;\n      const isScrollingUp = scrollNow < scrollBefore;\n      const isScrollingDown = scrollNow > scrollBefore;\n\n      // el overran while scrolling up\n      if (isScrollingUp && topEvent && !topOverran && rect.top >= 0) {\n        topOverran = true;\n        onTopOverrun(topEvent, firstChild);\n      } else if (isScrollingDown && topOverran && rect.top <= 0) {\n        topOverran = false;\n      }\n\n      if (\n        topEvent &&\n        isScrollingUp &&\n        isAtViewportTop(firstChild, this.scrollContainer)\n      ) {\n        onFirstChildAtTop(topEvent, firstChild);\n      } else if (\n        bottomEvent &&\n        isScrollingDown &&\n        isAtViewportBottom(lastChild, this.scrollContainer)\n      ) {\n        onLastChildAtBottom(bottomEvent, lastChild);\n      }\n      scrollBefore = scrollNow;\n    };\n\n    if (this.scrollContainer) {\n      this.scrollContainer.addEventListener(\"scroll\", this.onScroll);\n    } else {\n      window.addEventListener(\"scroll\", this.onScroll);\n    }\n  },\n\n  destroyed() {\n    if (this.scrollContainer) {\n      this.scrollContainer.removeEventListener(\"scroll\", this.onScroll);\n    } else {\n      window.removeEventListener(\"scroll\", this.onScroll);\n    }\n  },\n\n  throttle(interval, callback) {\n    let lastCallAt = 0;\n    let timer;\n\n    return (...args) => {\n      const now = Date.now();\n      const remainingTime = interval - (now - lastCallAt);\n\n      if (remainingTime <= 0 || remainingTime > interval) {\n        if (timer) {\n          clearTimeout(timer);\n          timer = null;\n        }\n        lastCallAt = now;\n        callback(...args);\n      } else if (!timer) {\n        timer = setTimeout(() => {\n          lastCallAt = Date.now();\n          timer = null;\n          callback(...args);\n        }, remainingTime);\n      }\n    };\n  },\n};\nexport default Hooks;\n", "import {\n  PHX_REF_LOADING,\n  PHX_REF_LOCK,\n  PHX_REF_SRC,\n  PHX_PENDING_REFS,\n  PHX_EVENT_CLASSES,\n  PHX_DISABLED,\n  PHX_READONLY,\n  PHX_DISABLE_WITH_RESTORE,\n} from \"./constants\";\n\nimport DOM from \"./dom\";\n\nexport default class ElementRef {\n  static onUnlock(el, callback) {\n    if (!DOM.isLocked(el) && !el.closest(`[${PHX_REF_LOCK}]`)) {\n      return callback();\n    }\n    const closestLock = el.closest(`[${PHX_REF_LOCK}]`);\n    const ref = closestLock\n      .closest(`[${PHX_REF_LOCK}]`)\n      .getAttribute(PHX_REF_LOCK);\n    closestLock.addEventListener(\n      `phx:undo-lock:${ref}`,\n      () => {\n        callback();\n      },\n      { once: true },\n    );\n  }\n\n  constructor(el) {\n    this.el = el;\n    this.loadingRef = el.hasAttribute(PHX_REF_LOADING)\n      ? parseInt(el.getAttribute(PHX_REF_LOADING), 10)\n      : null;\n    this.lockRef = el.hasAttribute(PHX_REF_LOCK)\n      ? parseInt(el.getAttribute(PHX_REF_LOCK), 10)\n      : null;\n  }\n\n  // public\n\n  maybeUndo(ref, phxEvent, eachCloneCallback) {\n    if (!this.isWithin(ref)) {\n      // we cannot undo the lock / loading now, as there is a newer one already set;\n      // we need to store the original ref we tried to send the undo event later\n      DOM.updatePrivate(this.el, PHX_PENDING_REFS, [], (pendingRefs) => {\n        pendingRefs.push(ref);\n        return pendingRefs;\n      });\n      return;\n    }\n\n    // undo locks and apply clones\n    this.undoLocks(ref, phxEvent, eachCloneCallback);\n\n    // undo loading states\n    this.undoLoading(ref, phxEvent);\n\n    // ensure undo events are fired for pending refs that\n    // are resolved by the current ref, otherwise we'd leak event listeners\n    DOM.updatePrivate(this.el, PHX_PENDING_REFS, [], (pendingRefs) => {\n      return pendingRefs.filter((pendingRef) => {\n        let opts = {\n          detail: { ref: pendingRef, event: phxEvent },\n          bubbles: true,\n          cancelable: false,\n        };\n        if (this.loadingRef && this.loadingRef > pendingRef) {\n          this.el.dispatchEvent(\n            new CustomEvent(`phx:undo-loading:${pendingRef}`, opts),\n          );\n        }\n        if (this.lockRef && this.lockRef > pendingRef) {\n          this.el.dispatchEvent(\n            new CustomEvent(`phx:undo-lock:${pendingRef}`, opts),\n          );\n        }\n        return pendingRef > ref;\n      });\n    });\n\n    // clean up if fully resolved\n    if (this.isFullyResolvedBy(ref)) {\n      this.el.removeAttribute(PHX_REF_SRC);\n    }\n  }\n\n  // private\n\n  isWithin(ref) {\n    return !(\n      this.loadingRef !== null &&\n      this.loadingRef > ref &&\n      this.lockRef !== null &&\n      this.lockRef > ref\n    );\n  }\n\n  // Check for cloned PHX_REF_LOCK element that has been morphed behind\n  // the scenes while this element was locked in the DOM.\n  // When we apply the cloned tree to the active DOM element, we must\n  //\n  //   1. execute pending mounted hooks for nodes now in the DOM\n  //   2. undo any ref inside the cloned tree that has since been ack'd\n  undoLocks(ref, phxEvent, eachCloneCallback) {\n    if (!this.isLockUndoneBy(ref)) {\n      return;\n    }\n\n    const clonedTree = DOM.private(this.el, PHX_REF_LOCK);\n    if (clonedTree) {\n      eachCloneCallback(clonedTree);\n      DOM.deletePrivate(this.el, PHX_REF_LOCK);\n    }\n    this.el.removeAttribute(PHX_REF_LOCK);\n\n    const opts = {\n      detail: { ref: ref, event: phxEvent },\n      bubbles: true,\n      cancelable: false,\n    };\n    this.el.dispatchEvent(\n      new CustomEvent(`phx:undo-lock:${this.lockRef}`, opts),\n    );\n  }\n\n  undoLoading(ref, phxEvent) {\n    if (!this.isLoadingUndoneBy(ref)) {\n      if (\n        this.canUndoLoading(ref) &&\n        this.el.classList.contains(\"phx-submit-loading\")\n      ) {\n        this.el.classList.remove(\"phx-change-loading\");\n      }\n      return;\n    }\n\n    if (this.canUndoLoading(ref)) {\n      this.el.removeAttribute(PHX_REF_LOADING);\n      const disabledVal = this.el.getAttribute(PHX_DISABLED);\n      const readOnlyVal = this.el.getAttribute(PHX_READONLY);\n      // restore inputs\n      if (readOnlyVal !== null) {\n        this.el.readOnly = readOnlyVal === \"true\" ? true : false;\n        this.el.removeAttribute(PHX_READONLY);\n      }\n      if (disabledVal !== null) {\n        this.el.disabled = disabledVal === \"true\" ? true : false;\n        this.el.removeAttribute(PHX_DISABLED);\n      }\n      // restore disables\n      const disableRestore = this.el.getAttribute(PHX_DISABLE_WITH_RESTORE);\n      if (disableRestore !== null) {\n        this.el.innerText = disableRestore;\n        this.el.removeAttribute(PHX_DISABLE_WITH_RESTORE);\n      }\n\n      const opts = {\n        detail: { ref: ref, event: phxEvent },\n        bubbles: true,\n        cancelable: false,\n      };\n      this.el.dispatchEvent(\n        new CustomEvent(`phx:undo-loading:${this.loadingRef}`, opts),\n      );\n    }\n\n    // remove classes\n    PHX_EVENT_CLASSES.forEach((name) => {\n      if (name !== \"phx-submit-loading\" || this.canUndoLoading(ref)) {\n        DOM.removeClass(this.el, name);\n      }\n    });\n  }\n\n  isLoadingUndoneBy(ref) {\n    return this.loadingRef === null ? false : this.loadingRef <= ref;\n  }\n  isLockUndoneBy(ref) {\n    return this.lockRef === null ? false : this.lockRef <= ref;\n  }\n\n  isFullyResolvedBy(ref) {\n    return (\n      (this.loadingRef === null || this.loadingRef <= ref) &&\n      (this.lockRef === null || this.lockRef <= ref)\n    );\n  }\n\n  // only remove the phx-submit-loading class if we are not locked\n  canUndoLoading(ref) {\n    return this.lockRef === null || this.lockRef <= ref;\n  }\n}\n", "import { maybe } from \"./utils\";\n\nimport DOM from \"./dom\";\n\nexport default class DOMPostMorphRestorer {\n  constructor(containerBefore, containerAfter, updateType) {\n    const idsBefore = new Set();\n    const idsAfter = new Set(\n      [...containerAfter.children].map((child) => child.id),\n    );\n\n    const elementsToModify = [];\n\n    Array.from(containerBefore.children).forEach((child) => {\n      if (child.id) {\n        // all of our children should be elements with ids\n        idsBefore.add(child.id);\n        if (idsAfter.has(child.id)) {\n          const previousElementId =\n            child.previousElementSibling && child.previousElementSibling.id;\n          elementsToModify.push({\n            elementId: child.id,\n            previousElementId: previousElementId,\n          });\n        }\n      }\n    });\n\n    this.containerId = containerAfter.id;\n    this.updateType = updateType;\n    this.elementsToModify = elementsToModify;\n    this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));\n  }\n\n  // We do the following to optimize append/prepend operations:\n  //   1) Track ids of modified elements & of new elements\n  //   2) All the modified elements are put back in the correct position in the DOM tree\n  //      by storing the id of their previous sibling\n  //   3) New elements are going to be put in the right place by morphdom during append.\n  //      For prepend, we move them to the first position in the container\n  perform() {\n    const container = DOM.byId(this.containerId);\n    if (!container) {\n      return;\n    }\n    this.elementsToModify.forEach((elementToModify) => {\n      if (elementToModify.previousElementId) {\n        maybe(\n          document.getElementById(elementToModify.previousElementId),\n          (previousElem) => {\n            maybe(\n              document.getElementById(elementToModify.elementId),\n              (elem) => {\n                const isInRightPlace =\n                  elem.previousElementSibling &&\n                  elem.previousElementSibling.id == previousElem.id;\n                if (!isInRightPlace) {\n                  previousElem.insertAdjacentElement(\"afterend\", elem);\n                }\n              },\n            );\n          },\n        );\n      } else {\n        // This is the first element in the container\n        maybe(document.getElementById(elementToModify.elementId), (elem) => {\n          const isInRightPlace = elem.previousElementSibling == null;\n          if (!isInRightPlace) {\n            container.insertAdjacentElement(\"afterbegin\", elem);\n          }\n        });\n      }\n    });\n\n    if (this.updateType == \"prepend\") {\n      this.elementIdsToAdd.reverse().forEach((elemId) => {\n        maybe(document.getElementById(elemId), (elem) =>\n          container.insertAdjacentElement(\"afterbegin\", elem),\n        );\n      });\n    }\n  }\n}\n", "var DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                    // handle empty optgroups\n                    if (!curChild) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n    return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n  return function morphdom(fromNode, toNode, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof toNode === 'string') {\n      if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n        var toNodeHtml = toNode;\n        toNode = doc.createElement('html');\n        toNode.innerHTML = toNodeHtml;\n      } else {\n        toNode = toElement(toNode);\n      }\n    } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n      toNode = toNode.firstElementChild;\n    }\n\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n    var onNodeAdded = options.onNodeAdded || noop;\n    var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n    var onElUpdated = options.onElUpdated || noop;\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n    var skipFromChildren = options.skipFromChildren || noop;\n    var addChild = options.addChild || function(parent, child){ return parent.appendChild(child); };\n    var childrenOnly = options.childrenOnly === true;\n\n    // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n    var fromNodesLookup = Object.create(null);\n    var keyedRemovalList = [];\n\n    function addKeyedRemoval(key) {\n      keyedRemovalList.push(key);\n    }\n\n    function walkDiscardedChildNodes(node, skipKeyedNodes) {\n      if (node.nodeType === ELEMENT_NODE) {\n        var curChild = node.firstChild;\n        while (curChild) {\n\n          var key = undefined;\n\n          if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n            // If we are skipping keyed nodes then we add the key\n            // to a list so that it can be handled at the very end.\n            addKeyedRemoval(key);\n          } else {\n            // Only report the node as discarded if it is not keyed. We do this because\n            // at the end we loop through all keyed elements that were unmatched\n            // and then discard them in one final pass.\n            onNodeDiscarded(curChild);\n            if (curChild.firstChild) {\n              walkDiscardedChildNodes(curChild, skipKeyedNodes);\n            }\n          }\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    /**\n    * Removes a DOM node out of the original DOM\n    *\n    * @param  {Node} node The node to remove\n    * @param  {Node} parentNode The nodes parent\n    * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n    * @return {undefined}\n    */\n    function removeNode(node, parentNode, skipKeyedNodes) {\n      if (onBeforeNodeDiscarded(node) === false) {\n        return;\n      }\n\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n\n      onNodeDiscarded(node);\n      walkDiscardedChildNodes(node, skipKeyedNodes);\n    }\n\n    // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n    // function indexTree(root) {\n    //     var treeWalker = document.createTreeWalker(\n    //         root,\n    //         NodeFilter.SHOW_ELEMENT);\n    //\n    //     var el;\n    //     while((el = treeWalker.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n    //\n    // function indexTree(node) {\n    //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n    //     var el;\n    //     while((el = nodeIterator.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    function indexTree(node) {\n      if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n        var curChild = node.firstChild;\n        while (curChild) {\n          var key = getNodeKey(curChild);\n          if (key) {\n            fromNodesLookup[key] = curChild;\n          }\n\n          // Walk recursively\n          indexTree(curChild);\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    indexTree(fromNode);\n\n    function handleNodeAdded(el) {\n      onNodeAdded(el);\n\n      var curChild = el.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling;\n\n        var key = getNodeKey(curChild);\n        if (key) {\n          var unmatchedFromEl = fromNodesLookup[key];\n          // if we find a duplicate #id node in cache, replace `el` with cache value\n          // and morph it to the child node.\n          if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n            morphEl(unmatchedFromEl, curChild);\n          } else {\n            handleNodeAdded(curChild);\n          }\n        } else {\n          // recursively call for curChild and it's children to see if we find something in\n          // fromNodesLookup\n          handleNodeAdded(curChild);\n        }\n\n        curChild = nextSibling;\n      }\n    }\n\n    function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n      // We have processed all of the \"to nodes\". If curFromNodeChild is\n      // non-null then we still have some from nodes left over that need\n      // to be removed\n      while (curFromNodeChild) {\n        var fromNextSibling = curFromNodeChild.nextSibling;\n        if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n          // Since the node is keyed it might be matched up later so we defer\n          // the actual removal to later\n          addKeyedRemoval(curFromNodeKey);\n        } else {\n          // NOTE: we skip nested keyed nodes from being removed since there is\n          //       still a chance they will be matched up later\n          removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n        }\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n\n    function morphEl(fromEl, toEl, childrenOnly) {\n      var toElKey = getNodeKey(toEl);\n\n      if (toElKey) {\n        // If an element with an ID is being morphed then it will be in the final\n        // DOM so clear it out of the saved elements collection\n        delete fromNodesLookup[toElKey];\n      }\n\n      if (!childrenOnly) {\n        // optional\n        var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);\n        if (beforeUpdateResult === false) {\n          return;\n        } else if (beforeUpdateResult instanceof HTMLElement) {\n          fromEl = beforeUpdateResult;\n          // reindex the new fromEl in case it's not in the same\n          // tree as the original fromEl\n          // (Phoenix LiveView sometimes returns a cloned tree,\n          //  but keyed lookups would still point to the original tree)\n          indexTree(fromEl);\n        }\n\n        // update attributes on original DOM element first\n        morphAttrs(fromEl, toEl);\n        // optional\n        onElUpdated(fromEl);\n\n        if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n          return;\n        }\n      }\n\n      if (fromEl.nodeName !== 'TEXTAREA') {\n        morphChildren(fromEl, toEl);\n      } else {\n        specialElHandlers.TEXTAREA(fromEl, toEl);\n      }\n    }\n\n    function morphChildren(fromEl, toEl) {\n      var skipFrom = skipFromChildren(fromEl, toEl);\n      var curToNodeChild = toEl.firstChild;\n      var curFromNodeChild = fromEl.firstChild;\n      var curToNodeKey;\n      var curFromNodeKey;\n\n      var fromNextSibling;\n      var toNextSibling;\n      var matchingFromEl;\n\n      // walk the children\n      outer: while (curToNodeChild) {\n        toNextSibling = curToNodeChild.nextSibling;\n        curToNodeKey = getNodeKey(curToNodeChild);\n\n        // walk the fromNode children all the way through\n        while (!skipFrom && curFromNodeChild) {\n          fromNextSibling = curFromNodeChild.nextSibling;\n\n          if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          curFromNodeKey = getNodeKey(curFromNodeChild);\n\n          var curFromNodeType = curFromNodeChild.nodeType;\n\n          // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n          var isCompatible = undefined;\n\n          if (curFromNodeType === curToNodeChild.nodeType) {\n            if (curFromNodeType === ELEMENT_NODE) {\n              // Both nodes being compared are Element nodes\n\n              if (curToNodeKey) {\n                // The target node has a key so we want to match it up with the correct element\n                // in the original DOM tree\n                if (curToNodeKey !== curFromNodeKey) {\n                  // The current element in the original DOM tree does not have a matching key so\n                  // let's check our lookup to see if there is a matching element in the original\n                  // DOM tree\n                  if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                    if (fromNextSibling === matchingFromEl) {\n                      // Special case for single element removals. To avoid removing the original\n                      // DOM node out of the tree (since that can break CSS transitions, etc.),\n                      // we will instead discard the current node and wait until the next\n                      // iteration to properly match up the keyed target element with its matching\n                      // element in the original tree\n                      isCompatible = false;\n                    } else {\n                      // We found a matching keyed element somewhere in the original DOM tree.\n                      // Let's move the original DOM node into the current position and morph\n                      // it.\n\n                      // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                      // the `removeNode()` function for the node that is being discarded so that\n                      // all lifecycle hooks are correctly invoked\n                      fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                      // fromNextSibling = curFromNodeChild.nextSibling;\n\n                      if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                      } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                      }\n\n                      curFromNodeChild = matchingFromEl;\n                      curFromNodeKey = getNodeKey(curFromNodeChild);\n                    }\n                  } else {\n                    // The nodes are not compatible since the \"to\" node has a key and there\n                    // is no matching keyed node in the source tree\n                    isCompatible = false;\n                  }\n                }\n              } else if (curFromNodeKey) {\n                // The original has a key\n                isCompatible = false;\n              }\n\n              isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n              if (isCompatible) {\n                // We found compatible DOM elements so transform\n                // the current \"from\" node to match the current\n                // target DOM node.\n                // MORPH\n                morphEl(curFromNodeChild, curToNodeChild);\n              }\n\n            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n              // Both nodes being compared are Text or Comment nodes\n              isCompatible = true;\n              // Simply update nodeValue on the original node to\n              // change the text value\n              if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n              }\n\n            }\n          }\n\n          if (isCompatible) {\n            // Advance both the \"to\" child and the \"from\" child since we found a match\n            // Nothing else to do as we already recursively called morphChildren above\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          // No compatible match so remove the old node from the DOM and continue trying to find a\n          // match in the original DOM. However, we only do this if the from node is not keyed\n          // since it is possible that a keyed node might match up with a node somewhere else in the\n          // target tree and we don't want to discard it just yet since it still might find a\n          // home in the final DOM tree. After everything is done we will remove any keyed nodes\n          // that didn't find a home\n          if (curFromNodeKey) {\n            // Since the node is keyed it might be matched up later so we defer\n            // the actual removal to later\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            // NOTE: we skip nested keyed nodes from being removed since there is\n            //       still a chance they will be matched up later\n            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n          }\n\n          curFromNodeChild = fromNextSibling;\n        } // END: while(curFromNodeChild) {}\n\n        // If we got this far then we did not find a candidate match for\n        // our \"to node\" and we exhausted all of the children \"from\"\n        // nodes. Therefore, we will just append the current \"to\" node\n        // to the end\n        if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n          // MORPH\n          if(!skipFrom){ addChild(fromEl, matchingFromEl); }\n          morphEl(matchingFromEl, curToNodeChild);\n        } else {\n          var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n          if (onBeforeNodeAddedResult !== false) {\n            if (onBeforeNodeAddedResult) {\n              curToNodeChild = onBeforeNodeAddedResult;\n            }\n\n            if (curToNodeChild.actualize) {\n              curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n            }\n            addChild(fromEl, curToNodeChild);\n            handleNodeAdded(curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n      }\n\n      cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n      var specialElHandler = specialElHandlers[fromEl.nodeName];\n      if (specialElHandler) {\n        specialElHandler(fromEl, toEl);\n      }\n    } // END: morphChildren(...)\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n\n    if (!childrenOnly) {\n      // Handle the case where we are given two DOM nodes that are not\n      // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n      if (morphedNodeType === ELEMENT_NODE) {\n        if (toNodeType === ELEMENT_NODE) {\n          if (!compareNodeNames(fromNode, toNode)) {\n            onNodeDiscarded(fromNode);\n            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n          }\n        } else {\n          // Going from an element node to a text node\n          morphedNode = toNode;\n        }\n      } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n        if (toNodeType === morphedNodeType) {\n          if (morphedNode.nodeValue !== toNode.nodeValue) {\n            morphedNode.nodeValue = toNode.nodeValue;\n          }\n\n          return morphedNode;\n        } else {\n          // Text node to something else\n          morphedNode = toNode;\n        }\n      }\n    }\n\n    if (morphedNode === toNode) {\n      // The \"to node\" was not compatible with the \"from node\" so we had to\n      // toss out the \"from node\" and use the \"to node\"\n      onNodeDiscarded(fromNode);\n    } else {\n      if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n        return;\n      }\n\n      morphEl(morphedNode, toNode, childrenOnly);\n\n      // We now need to loop over any keyed nodes that might need to be\n      // removed. We only do the removal if we know that the keyed node\n      // never found a match. When a keyed node is matched up we remove\n      // it out of fromNodesLookup and we use fromNodesLookup to determine\n      // if a keyed node has been matched up or not\n      if (keyedRemovalList) {\n        for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n          var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n          if (elToRemove) {\n            removeNode(elToRemove, elToRemove.parentNode, false);\n          }\n        }\n      }\n    }\n\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n      if (morphedNode.actualize) {\n        morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n      }\n      // If we had to swap out the from node with a new node because the old\n      // node was not compatible with the target node then we need to\n      // replace the old DOM node in the original DOM tree. This is only\n      // possible if the original DOM node was part of a DOM tree which\n      // we know is the case if it has a parent node.\n      fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n\n    return morphedNode;\n  };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n", "import {\n  PHX_COMPONENT,\n  PHX_PRUNE,\n  PHX_ROOT_ID,\n  PHX_SESSION,\n  PHX_SKIP,\n  PHX_MAGIC_ID,\n  PHX_STATIC,\n  PHX_TRIGGER_ACTION,\n  PHX_UPDATE,\n  PHX_REF_SRC,\n  PHX_REF_LOCK,\n  PHX_STREAM,\n  PHX_STREAM_REF,\n  PHX_VIEWPORT_TOP,\n  PHX_VIEWPORT_BOTTOM,\n  PHX_PORTAL,\n  PHX_TELEPORTED_REF,\n  PHX_TELEPORTED_SRC,\n  PHX_RUNTIME_HOOK,\n} from \"./constants\";\n\nimport { detectDuplicateIds, detectInvalidStreamInserts, isCid } from \"./utils\";\nimport ElementRef from \"./element_ref\";\nimport DOM from \"./dom\";\nimport DOMPostMorphRestorer from \"./dom_post_morph_restorer\";\nimport morphdom from \"morphdom\";\n\nexport default class DOMPatch {\n  constructor(view, container, id, html, streams, targetCID, opts = {}) {\n    this.view = view;\n    this.liveSocket = view.liveSocket;\n    this.container = container;\n    this.id = id;\n    this.rootID = view.root.id;\n    this.html = html;\n    this.streams = streams;\n    this.streamInserts = {};\n    this.streamComponentRestore = {};\n    this.targetCID = targetCID;\n    this.cidPatch = isCid(this.targetCID);\n    this.pendingRemoves = [];\n    this.phxRemove = this.liveSocket.binding(\"remove\");\n    this.targetContainer = this.isCIDPatch()\n      ? this.targetCIDContainer(html)\n      : container;\n    this.callbacks = {\n      beforeadded: [],\n      beforeupdated: [],\n      beforephxChildAdded: [],\n      afteradded: [],\n      afterupdated: [],\n      afterdiscarded: [],\n      afterphxChildAdded: [],\n      aftertransitionsDiscarded: [],\n    };\n    this.withChildren = opts.withChildren || opts.undoRef || false;\n    this.undoRef = opts.undoRef;\n  }\n\n  before(kind, callback) {\n    this.callbacks[`before${kind}`].push(callback);\n  }\n  after(kind, callback) {\n    this.callbacks[`after${kind}`].push(callback);\n  }\n\n  trackBefore(kind, ...args) {\n    this.callbacks[`before${kind}`].forEach((callback) => callback(...args));\n  }\n\n  trackAfter(kind, ...args) {\n    this.callbacks[`after${kind}`].forEach((callback) => callback(...args));\n  }\n\n  markPrunableContentForRemoval() {\n    const phxUpdate = this.liveSocket.binding(PHX_UPDATE);\n    DOM.all(\n      this.container,\n      `[${phxUpdate}=append] > *, [${phxUpdate}=prepend] > *`,\n      (el) => {\n        el.setAttribute(PHX_PRUNE, \"\");\n      },\n    );\n  }\n\n  perform(isJoinPatch) {\n    const { view, liveSocket, html, container, targetContainer } = this;\n    if (this.isCIDPatch() && !targetContainer) {\n      return;\n    }\n\n    const focused = liveSocket.getActiveElement();\n    const { selectionStart, selectionEnd } =\n      focused && DOM.hasSelectionRange(focused) ? focused : {};\n    const phxUpdate = liveSocket.binding(PHX_UPDATE);\n    const phxViewportTop = liveSocket.binding(PHX_VIEWPORT_TOP);\n    const phxViewportBottom = liveSocket.binding(PHX_VIEWPORT_BOTTOM);\n    const phxTriggerExternal = liveSocket.binding(PHX_TRIGGER_ACTION);\n    const added = [];\n    const updates = [];\n    const appendPrependUpdates = [];\n\n    // as the portal target itself could be at the end of the DOM,\n    // it may not be present while morphing previous parts;\n    // therefore we apply all teleports after the morphing is done+\n    const portalCallbacks = [];\n\n    let externalFormTriggered = null;\n\n    const morph = (\n      targetContainer,\n      source,\n      withChildren = this.withChildren,\n    ) => {\n      const morphCallbacks = {\n        // normally, we are running with childrenOnly, as the patch HTML for a LV\n        // does not include the LV attrs (data-phx-session, etc.)\n        // when we are patching a live component, we do want to patch the root element as well;\n        // another case is the recursive patch of a stream item that was kept on reset (-> onBeforeNodeAdded)\n        childrenOnly:\n          targetContainer.getAttribute(PHX_COMPONENT) === null && !withChildren,\n        getNodeKey: (node) => {\n          if (DOM.isPhxDestroyed(node)) {\n            return null;\n          }\n          // If we have a join patch, then by definition there was no PHX_MAGIC_ID.\n          // This is important to reduce the amount of elements morphdom discards.\n          if (isJoinPatch) {\n            return node.id;\n          }\n          return (\n            node.id || (node.getAttribute && node.getAttribute(PHX_MAGIC_ID))\n          );\n        },\n        // skip indexing from children when container is stream\n        skipFromChildren: (from) => {\n          return from.getAttribute(phxUpdate) === PHX_STREAM;\n        },\n        // tell morphdom how to add a child\n        addChild: (parent, child) => {\n          const { ref, streamAt } = this.getStreamInsert(child);\n          if (ref === undefined) {\n            return parent.appendChild(child);\n          }\n\n          this.setStreamRef(child, ref);\n\n          // streaming\n          if (streamAt === 0) {\n            parent.insertAdjacentElement(\"afterbegin\", child);\n          } else if (streamAt === -1) {\n            const lastChild = parent.lastElementChild;\n            if (lastChild && !lastChild.hasAttribute(PHX_STREAM_REF)) {\n              const nonStreamChild = Array.from(parent.children).find(\n                (c) => !c.hasAttribute(PHX_STREAM_REF),\n              );\n              parent.insertBefore(child, nonStreamChild);\n            } else {\n              parent.appendChild(child);\n            }\n          } else if (streamAt > 0) {\n            const sibling = Array.from(parent.children)[streamAt];\n            parent.insertBefore(child, sibling);\n          }\n        },\n        onBeforeNodeAdded: (el) => {\n          // don't add update_only nodes if they did not already exist\n          if (\n            this.getStreamInsert(el)?.updateOnly &&\n            !this.streamComponentRestore[el.id]\n          ) {\n            return false;\n          }\n\n          DOM.maintainPrivateHooks(el, el, phxViewportTop, phxViewportBottom);\n          this.trackBefore(\"added\", el);\n\n          let morphedEl = el;\n          // this is a stream item that was kept on reset, recursively morph it\n          if (this.streamComponentRestore[el.id]) {\n            morphedEl = this.streamComponentRestore[el.id];\n            delete this.streamComponentRestore[el.id];\n            morph(morphedEl, el, true);\n          }\n\n          return morphedEl;\n        },\n        onNodeAdded: (el) => {\n          if (el.getAttribute) {\n            this.maybeReOrderStream(el, true);\n          }\n          // phx-portal handling\n          if (DOM.isPortalTemplate(el)) {\n            portalCallbacks.push(() => this.teleport(el, morph));\n          }\n\n          // hack to fix Safari handling of img srcset and video tags\n          if (el instanceof HTMLImageElement && el.srcset) {\n            // eslint-disable-next-line no-self-assign\n            el.srcset = el.srcset;\n          } else if (el instanceof HTMLVideoElement && el.autoplay) {\n            el.play();\n          }\n          if (DOM.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n            externalFormTriggered = el;\n          }\n\n          // nested view handling\n          if (\n            (DOM.isPhxChild(el) && view.ownsElement(el)) ||\n            (DOM.isPhxSticky(el) && view.ownsElement(el.parentNode))\n          ) {\n            this.trackAfter(\"phxChildAdded\", el);\n          }\n\n          // data-phx-runtime-hook\n          if (el.nodeName === \"SCRIPT\" && el.hasAttribute(PHX_RUNTIME_HOOK)) {\n            this.handleRuntimeHook(el, source);\n          }\n\n          added.push(el);\n        },\n        onNodeDiscarded: (el) => this.onNodeDiscarded(el),\n        onBeforeNodeDiscarded: (el) => {\n          if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {\n            return true;\n          }\n          if (\n            el.parentElement !== null &&\n            el.id &&\n            DOM.isPhxUpdate(el.parentElement, phxUpdate, [\n              PHX_STREAM,\n              \"append\",\n              \"prepend\",\n            ])\n          ) {\n            return false;\n          }\n          // don't remove teleported elements\n          if (el.getAttribute && el.getAttribute(PHX_TELEPORTED_REF)) {\n            return false;\n          }\n          if (this.maybePendingRemove(el)) {\n            return false;\n          }\n          if (this.skipCIDSibling(el)) {\n            return false;\n          }\n\n          if (DOM.isPortalTemplate(el)) {\n            // if the portal template itself is removed, remove the teleported element as well;\n            // we also perform a check after morphdom is finished to catch parent removals\n            const teleportedEl = document.getElementById(\n              el.content.firstElementChild.id,\n            );\n            if (teleportedEl) {\n              teleportedEl.remove();\n              morphCallbacks.onNodeDiscarded(teleportedEl);\n              this.view.dropPortalElementId(teleportedEl.id);\n            }\n          }\n\n          return true;\n        },\n        onElUpdated: (el) => {\n          if (DOM.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n            externalFormTriggered = el;\n          }\n          updates.push(el);\n          this.maybeReOrderStream(el, false);\n        },\n        onBeforeElUpdated: (fromEl, toEl) => {\n          // if we are patching the root target container and the id has changed, treat it as a new node\n          // by replacing the fromEl with the toEl, which ensures hooks are torn down and re-created\n          if (\n            fromEl.id &&\n            fromEl.isSameNode(targetContainer) &&\n            fromEl.id !== toEl.id\n          ) {\n            morphCallbacks.onNodeDiscarded(fromEl);\n            fromEl.replaceWith(toEl);\n            return morphCallbacks.onNodeAdded(toEl);\n          }\n          DOM.syncPendingAttrs(fromEl, toEl);\n          DOM.maintainPrivateHooks(\n            fromEl,\n            toEl,\n            phxViewportTop,\n            phxViewportBottom,\n          );\n          DOM.cleanChildNodes(toEl, phxUpdate);\n          if (this.skipCIDSibling(toEl)) {\n            // if this is a live component used in a stream, we may need to reorder it\n            this.maybeReOrderStream(fromEl);\n            return false;\n          }\n          if (DOM.isPhxSticky(fromEl)) {\n            [PHX_SESSION, PHX_STATIC, PHX_ROOT_ID]\n              .map((attr) => [\n                attr,\n                fromEl.getAttribute(attr),\n                toEl.getAttribute(attr),\n              ])\n              .forEach(([attr, fromVal, toVal]) => {\n                if (toVal && fromVal !== toVal) {\n                  fromEl.setAttribute(attr, toVal);\n                }\n              });\n\n            return false;\n          }\n          if (\n            DOM.isIgnored(fromEl, phxUpdate) ||\n            (fromEl.form && fromEl.form.isSameNode(externalFormTriggered))\n          ) {\n            this.trackBefore(\"updated\", fromEl, toEl);\n            DOM.mergeAttrs(fromEl, toEl, {\n              isIgnored: DOM.isIgnored(fromEl, phxUpdate),\n            });\n            updates.push(fromEl);\n            DOM.applyStickyOperations(fromEl);\n            return false;\n          }\n          if (\n            fromEl.type === \"number\" &&\n            fromEl.validity &&\n            fromEl.validity.badInput\n          ) {\n            return false;\n          }\n          // If the element has PHX_REF_SRC, it is loading or locked and awaiting an ack.\n          // If it's locked, we clone the fromEl tree and instruct morphdom to use\n          // the cloned tree as the source of the morph for this branch from here on out.\n          // We keep a reference to the cloned tree in the element's private data, and\n          // on ack (view.undoRefs), we morph the cloned tree with the true fromEl in the DOM to\n          // apply any changes that happened while the element was locked.\n          const isFocusedFormEl =\n            focused && fromEl.isSameNode(focused) && DOM.isFormInput(fromEl);\n          const focusedSelectChanged =\n            isFocusedFormEl && this.isChangedSelect(fromEl, toEl);\n          if (fromEl.hasAttribute(PHX_REF_SRC)) {\n            const ref = new ElementRef(fromEl);\n            // only perform the clone step if this is not a patch that unlocks\n            if (\n              ref.lockRef &&\n              (!this.undoRef || !ref.isLockUndoneBy(this.undoRef))\n            ) {\n              if (DOM.isUploadInput(fromEl)) {\n                DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });\n                this.trackBefore(\"updated\", fromEl, toEl);\n                updates.push(fromEl);\n              }\n              DOM.applyStickyOperations(fromEl);\n              const isLocked = fromEl.hasAttribute(PHX_REF_LOCK);\n              const clone = isLocked\n                ? DOM.private(fromEl, PHX_REF_LOCK) || fromEl.cloneNode(true)\n                : null;\n              if (clone) {\n                DOM.putPrivate(fromEl, PHX_REF_LOCK, clone);\n                if (!isFocusedFormEl) {\n                  fromEl = clone;\n                }\n              }\n            }\n          }\n\n          // nested view handling\n          if (DOM.isPhxChild(toEl)) {\n            const prevSession = fromEl.getAttribute(PHX_SESSION);\n            DOM.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });\n            if (prevSession !== \"\") {\n              fromEl.setAttribute(PHX_SESSION, prevSession);\n            }\n            fromEl.setAttribute(PHX_ROOT_ID, this.rootID);\n            DOM.applyStickyOperations(fromEl);\n            return false;\n          }\n\n          // if we are undoing a lock, copy potentially nested clones over\n          if (this.undoRef && DOM.private(toEl, PHX_REF_LOCK)) {\n            DOM.putPrivate(\n              fromEl,\n              PHX_REF_LOCK,\n              DOM.private(toEl, PHX_REF_LOCK),\n            );\n          }\n          // now copy regular DOM.private data\n          DOM.copyPrivates(toEl, fromEl);\n\n          // phx-portal handling\n          if (DOM.isPortalTemplate(toEl)) {\n            portalCallbacks.push(() => this.teleport(toEl, morph));\n            return false;\n          }\n\n          // skip patching focused inputs unless focus is a select that has changed options\n          if (\n            isFocusedFormEl &&\n            fromEl.type !== \"hidden\" &&\n            !focusedSelectChanged\n          ) {\n            this.trackBefore(\"updated\", fromEl, toEl);\n            DOM.mergeFocusedInput(fromEl, toEl);\n            DOM.syncAttrsToProps(fromEl);\n            updates.push(fromEl);\n            DOM.applyStickyOperations(fromEl);\n            return false;\n          } else {\n            // blur focused select if it changed so native UI is updated (ie safari won't update visible options)\n            if (focusedSelectChanged) {\n              fromEl.blur();\n            }\n            if (DOM.isPhxUpdate(toEl, phxUpdate, [\"append\", \"prepend\"])) {\n              appendPrependUpdates.push(\n                new DOMPostMorphRestorer(\n                  fromEl,\n                  toEl,\n                  toEl.getAttribute(phxUpdate),\n                ),\n              );\n            }\n\n            DOM.syncAttrsToProps(toEl);\n            DOM.applyStickyOperations(toEl);\n            this.trackBefore(\"updated\", fromEl, toEl);\n            return fromEl;\n          }\n        },\n      };\n\n      morphdom(targetContainer, source, morphCallbacks);\n    };\n\n    this.trackBefore(\"added\", container);\n    this.trackBefore(\"updated\", container, container);\n\n    liveSocket.time(\"morphdom\", () => {\n      this.streams.forEach(([ref, inserts, deleteIds, reset]) => {\n        inserts.forEach(([key, streamAt, limit, updateOnly]) => {\n          this.streamInserts[key] = { ref, streamAt, limit, reset, updateOnly };\n        });\n        if (reset !== undefined) {\n          DOM.all(container, `[${PHX_STREAM_REF}=\"${ref}\"]`, (child) => {\n            this.removeStreamChildElement(child);\n          });\n        }\n        deleteIds.forEach((id) => {\n          const child = container.querySelector(`[id=\"${id}\"]`);\n          if (child) {\n            this.removeStreamChildElement(child);\n          }\n        });\n      });\n\n      // clear stream items from the dead render if they are not inserted again\n      if (isJoinPatch) {\n        DOM.all(this.container, `[${phxUpdate}=${PHX_STREAM}]`)\n          // it is important to filter the element before removing them, as\n          // it may happen that streams are nested and the owner check fails if\n          // a parent is removed before a child\n          .filter((el) => this.view.ownsElement(el))\n          .forEach((el) => {\n            Array.from(el.children).forEach((child) => {\n              // we already performed the owner check, each child is guaranteed to be owned\n              // by the view. To prevent the nested owner check from failing in case of nested\n              // streams where the parent is removed before the child, we force the removal\n              this.removeStreamChildElement(child, true);\n            });\n          });\n      }\n\n      morph(targetContainer, html);\n      // normal patch complete, teleport elements now\n      portalCallbacks.forEach((callback) => callback());\n      // check for any teleported elements that are not in the view any more\n      // and remove them\n      this.view.portalElementIds.forEach((id) => {\n        const el = document.getElementById(id);\n        if (el) {\n          const source = document.getElementById(\n            el.getAttribute(PHX_TELEPORTED_SRC),\n          );\n          if (!source) {\n            el.remove();\n            this.onNodeDiscarded(el);\n            this.view.dropPortalElementId(id);\n          }\n        }\n      });\n    });\n\n    if (liveSocket.isDebugEnabled()) {\n      detectDuplicateIds();\n      detectInvalidStreamInserts(this.streamInserts);\n      // warn if there are any inputs named \"id\"\n      Array.from(document.querySelectorAll(\"input[name=id]\")).forEach(\n        (node) => {\n          if (node instanceof HTMLInputElement && node.form) {\n            console.error(\n              'Detected an input with name=\"id\" inside a form! This will cause problems when patching the DOM.\\n',\n              node,\n            );\n          }\n        },\n      );\n    }\n\n    if (appendPrependUpdates.length > 0) {\n      liveSocket.time(\"post-morph append/prepend restoration\", () => {\n        appendPrependUpdates.forEach((update) => update.perform());\n      });\n    }\n\n    liveSocket.silenceEvents(() =>\n      DOM.restoreFocus(focused, selectionStart, selectionEnd),\n    );\n    DOM.dispatchEvent(document, \"phx:update\");\n    added.forEach((el) => this.trackAfter(\"added\", el));\n    updates.forEach((el) => this.trackAfter(\"updated\", el));\n\n    this.transitionPendingRemoves();\n\n    if (externalFormTriggered) {\n      liveSocket.unload();\n      // check for submitter and inject it as hidden input for external submit;\n      // In theory, it could happen that the stored submitter is outdated and doesn't\n      // exist in the DOM any more, but this is unlikely, so we just accept it for now.\n      const submitter = DOM.private(externalFormTriggered, \"submitter\");\n      if (submitter && submitter.name && targetContainer.contains(submitter)) {\n        const input = document.createElement(\"input\");\n        input.type = \"hidden\";\n        const formId = submitter.getAttribute(\"form\");\n        if (formId) {\n          input.setAttribute(\"form\", formId);\n        }\n        input.name = submitter.name;\n        input.value = submitter.value;\n        submitter.parentElement.insertBefore(input, submitter);\n      }\n      // use prototype's submit in case there's a form control with name or id of \"submit\"\n      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit\n      Object.getPrototypeOf(externalFormTriggered).submit.call(\n        externalFormTriggered,\n      );\n    }\n    return true;\n  }\n\n  onNodeDiscarded(el) {\n    // nested view handling\n    if (DOM.isPhxChild(el) || DOM.isPhxSticky(el)) {\n      this.liveSocket.destroyViewByEl(el);\n    }\n    this.trackAfter(\"discarded\", el);\n  }\n\n  maybePendingRemove(node) {\n    if (node.getAttribute && node.getAttribute(this.phxRemove) !== null) {\n      this.pendingRemoves.push(node);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  removeStreamChildElement(child, force = false) {\n    // make sure to only remove elements owned by the current view\n    // see https://github.com/phoenixframework/phoenix_live_view/issues/3047\n    // and https://github.com/phoenixframework/phoenix_live_view/issues/3681\n    if (!force && !this.view.ownsElement(child)) {\n      return;\n    }\n\n    // we need to store the node if it is actually re-added in the same patch\n    // we do NOT want to execute phx-remove, we do NOT want to call onNodeDiscarded\n    if (this.streamInserts[child.id]) {\n      this.streamComponentRestore[child.id] = child;\n      child.remove();\n    } else {\n      // only remove the element now if it has no phx-remove binding\n      if (!this.maybePendingRemove(child)) {\n        child.remove();\n        this.onNodeDiscarded(child);\n      }\n    }\n  }\n\n  getStreamInsert(el) {\n    const insert = el.id ? this.streamInserts[el.id] : {};\n    return insert || {};\n  }\n\n  setStreamRef(el, ref) {\n    DOM.putSticky(el, PHX_STREAM_REF, (el) =>\n      el.setAttribute(PHX_STREAM_REF, ref),\n    );\n  }\n\n  maybeReOrderStream(el, isNew) {\n    const { ref, streamAt, reset } = this.getStreamInsert(el);\n    if (streamAt === undefined) {\n      return;\n    }\n\n    // we need to set the PHX_STREAM_REF here as well as addChild is invoked only for parents\n    this.setStreamRef(el, ref);\n\n    if (!reset && !isNew) {\n      // we only reorder if the element is new or it's a stream reset\n      return;\n    }\n\n    // check if the element has a parent element;\n    // it doesn't if we are currently recursively morphing (restoring a saved stream child)\n    // because the element is not yet added to the real dom;\n    // reordering does not make sense in that case anyway\n    if (!el.parentElement) {\n      return;\n    }\n\n    if (streamAt === 0) {\n      el.parentElement.insertBefore(el, el.parentElement.firstElementChild);\n    } else if (streamAt > 0) {\n      const children = Array.from(el.parentElement.children);\n      const oldIndex = children.indexOf(el);\n      if (streamAt >= children.length - 1) {\n        el.parentElement.appendChild(el);\n      } else {\n        const sibling = children[streamAt];\n        if (oldIndex > streamAt) {\n          el.parentElement.insertBefore(el, sibling);\n        } else {\n          el.parentElement.insertBefore(el, sibling.nextElementSibling);\n        }\n      }\n    }\n\n    this.maybeLimitStream(el);\n  }\n\n  maybeLimitStream(el) {\n    const { limit } = this.getStreamInsert(el);\n    const children = limit !== null && Array.from(el.parentElement.children);\n    if (limit && limit < 0 && children.length > limit * -1) {\n      children\n        .slice(0, children.length + limit)\n        .forEach((child) => this.removeStreamChildElement(child));\n    } else if (limit && limit >= 0 && children.length > limit) {\n      children\n        .slice(limit)\n        .forEach((child) => this.removeStreamChildElement(child));\n    }\n  }\n\n  transitionPendingRemoves() {\n    const { pendingRemoves, liveSocket } = this;\n    if (pendingRemoves.length > 0) {\n      liveSocket.transitionRemoves(pendingRemoves, () => {\n        pendingRemoves.forEach((el) => {\n          const child = DOM.firstPhxChild(el);\n          if (child) {\n            liveSocket.destroyViewByEl(child);\n          }\n          el.remove();\n        });\n        this.trackAfter(\"transitionsDiscarded\", pendingRemoves);\n      });\n    }\n  }\n\n  isChangedSelect(fromEl, toEl) {\n    if (!(fromEl instanceof HTMLSelectElement) || fromEl.multiple) {\n      return false;\n    }\n    if (fromEl.options.length !== toEl.options.length) {\n      return true;\n    }\n\n    // keep the current value\n    toEl.value = fromEl.value;\n\n    // in general we have to be very careful with using isEqualNode as it does not a reliable\n    // DOM tree equality check, but for selection attributes and options it works fine\n    return !fromEl.isEqualNode(toEl);\n  }\n\n  isCIDPatch() {\n    return this.cidPatch;\n  }\n\n  skipCIDSibling(el) {\n    return el.nodeType === Node.ELEMENT_NODE && el.hasAttribute(PHX_SKIP);\n  }\n\n  targetCIDContainer(html) {\n    if (!this.isCIDPatch()) {\n      return;\n    }\n    const [first, ...rest] = DOM.findComponentNodeList(\n      this.view.id,\n      this.targetCID,\n    );\n    if (rest.length === 0 && DOM.childNodeLength(html) === 1) {\n      return first;\n    } else {\n      return first && first.parentNode;\n    }\n  }\n\n  indexOf(parent, child) {\n    return Array.from(parent.children).indexOf(child);\n  }\n\n  teleport(el, morph) {\n    const targetSelector = el.getAttribute(PHX_PORTAL);\n    const portalContainer = document.querySelector(targetSelector);\n    if (!portalContainer) {\n      throw new Error(\n        \"portal target with selector \" + targetSelector + \" not found\",\n      );\n    }\n    // phx-portal templates must have a single root element, so we assume this to be\n    // the case here\n    const toTeleport = el.content.firstElementChild;\n    // the PHX_SKIP optimization can also apply inside of the <template> elements\n    if (this.skipCIDSibling(toTeleport)) {\n      return;\n    }\n    if (!toTeleport?.id) {\n      throw new Error(\n        \"phx-portal template must have a single root element with ID!\",\n      );\n    }\n    const existing = document.getElementById(toTeleport.id);\n    let portalTarget;\n    if (existing) {\n      // check if the element needs to be moved to another target\n      if (!portalContainer.contains(existing)) {\n        portalContainer.appendChild(existing);\n      }\n      // we already teleported in a previous patch\n      portalTarget = existing;\n    } else {\n      // create empty target and morph it recursively\n      portalTarget = document.createElement(toTeleport.tagName);\n      portalContainer.appendChild(portalTarget);\n    }\n    // mark the target as teleported;\n    // to prevent unnecessary attribute modifications, we set the attribute\n    // on the source and remove it after morphing (we could also just keep it)\n    // otherwise morphdom would remove it, as the ref is not present in the source\n    // and we'd need to set it back after each morph\n    toTeleport.setAttribute(PHX_TELEPORTED_REF, this.view.id);\n    toTeleport.setAttribute(PHX_TELEPORTED_SRC, el.id);\n    morph(portalTarget, toTeleport, true);\n    toTeleport.removeAttribute(PHX_TELEPORTED_REF);\n    toTeleport.removeAttribute(PHX_TELEPORTED_SRC);\n    // store a reference to the teleported element in the view\n    // to cleanup when the view is destroyed, in case the portal target\n    // is outside the view itself\n    this.view.pushPortalElementId(toTeleport.id);\n  }\n\n  handleRuntimeHook(el, source) {\n    // usually, scripts are not executed when morphdom adds them to the DOM\n    // we special case runtime colocated hooks\n    const name = el.getAttribute(PHX_RUNTIME_HOOK);\n    let nonce = el.hasAttribute(\"nonce\") ? el.getAttribute(\"nonce\") : null;\n    if (el.hasAttribute(\"nonce\")) {\n      const template = document.createElement(\"template\");\n      template.innerHTML = source;\n      nonce = template.content\n        .querySelector(`script[${PHX_RUNTIME_HOOK}=\"${CSS.escape(name)}\"]`)\n        .getAttribute(\"nonce\");\n    }\n    const script = document.createElement(\"script\");\n    script.textContent = el.textContent;\n    DOM.mergeAttrs(script, el, { isIgnored: false });\n    if (nonce) {\n      script.nonce = nonce;\n    }\n    el.replaceWith(script);\n    el = script;\n  }\n}\n", "import {\n  COMPONENTS,\n  TEMPLATES,\n  EVENTS,\n  PHX_COMPONENT,\n  PHX_VIEW_REF,\n  PHX_SKIP,\n  PHX_MAGIC_ID,\n  REPLY,\n  STATIC,\n  TITLE,\n  STREAM,\n  ROOT,\n  KEYED,\n  KEYED_COUNT,\n} from \"./constants\";\n\nimport { isObject, logError, isCid } from \"./utils\";\n\nconst VOID_TAGS = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"command\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"keygen\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n]);\nconst quoteChars = new Set([\"'\", '\"']);\n\nexport const modifyRoot = (html, attrs, clearInnerHTML) => {\n  let i = 0;\n  let insideComment = false;\n  let beforeTag, afterTag, tag, tagNameEndsAt, id, newHTML;\n\n  const lookahead = html.match(/^(\\s*(?:<!--.*?-->\\s*)*)<([^\\s\\/>]+)/);\n  if (lookahead === null) {\n    throw new Error(`malformed html ${html}`);\n  }\n\n  i = lookahead[0].length;\n  beforeTag = lookahead[1];\n  tag = lookahead[2];\n  tagNameEndsAt = i;\n\n  // Scan the opening tag for id, if there is any\n  for (i; i < html.length; i++) {\n    if (html.charAt(i) === \">\") {\n      break;\n    }\n    if (html.charAt(i) === \"=\") {\n      const isId = html.slice(i - 3, i) === \" id\";\n      i++;\n      const char = html.charAt(i);\n      if (quoteChars.has(char)) {\n        const attrStartsAt = i;\n        i++;\n        for (i; i < html.length; i++) {\n          if (html.charAt(i) === char) {\n            break;\n          }\n        }\n        if (isId) {\n          id = html.slice(attrStartsAt + 1, i);\n          break;\n        }\n      }\n    }\n  }\n\n  let closeAt = html.length - 1;\n  insideComment = false;\n  while (closeAt >= beforeTag.length + tag.length) {\n    const char = html.charAt(closeAt);\n    if (insideComment) {\n      if (char === \"-\" && html.slice(closeAt - 3, closeAt) === \"<!-\") {\n        insideComment = false;\n        closeAt -= 4;\n      } else {\n        closeAt -= 1;\n      }\n    } else if (char === \">\" && html.slice(closeAt - 2, closeAt) === \"--\") {\n      insideComment = true;\n      closeAt -= 3;\n    } else if (char === \">\") {\n      break;\n    } else {\n      closeAt -= 1;\n    }\n  }\n  afterTag = html.slice(closeAt + 1, html.length);\n\n  const attrsStr = Object.keys(attrs)\n    .map((attr) => (attrs[attr] === true ? attr : `${attr}=\"${attrs[attr]}\"`))\n    .join(\" \");\n\n  if (clearInnerHTML) {\n    // Keep the id if any\n    const idAttrStr = id ? ` id=\"${id}\"` : \"\";\n    if (VOID_TAGS.has(tag)) {\n      newHTML = `<${tag}${idAttrStr}${attrsStr === \"\" ? \"\" : \" \"}${attrsStr}/>`;\n    } else {\n      newHTML = `<${tag}${idAttrStr}${attrsStr === \"\" ? \"\" : \" \"}${attrsStr}></${tag}>`;\n    }\n  } else {\n    const rest = html.slice(tagNameEndsAt, closeAt + 1);\n    newHTML = `<${tag}${attrsStr === \"\" ? \"\" : \" \"}${attrsStr}${rest}`;\n  }\n\n  return [newHTML, beforeTag, afterTag];\n};\n\nexport default class Rendered {\n  static extract(diff) {\n    const { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;\n    delete diff[REPLY];\n    delete diff[EVENTS];\n    delete diff[TITLE];\n    return { diff, title, reply: reply || null, events: events || [] };\n  }\n\n  constructor(viewId, rendered) {\n    this.viewId = viewId;\n    this.rendered = {};\n    this.magicId = 0;\n    this.mergeDiff(rendered);\n  }\n\n  parentViewId() {\n    return this.viewId;\n  }\n\n  toString(onlyCids) {\n    const { buffer: str, streams: streams } = this.recursiveToString(\n      this.rendered,\n      this.rendered[COMPONENTS],\n      onlyCids,\n      true,\n      {},\n    );\n    return { buffer: str, streams: streams };\n  }\n\n  recursiveToString(\n    rendered,\n    components = rendered[COMPONENTS],\n    onlyCids,\n    changeTracking,\n    rootAttrs,\n  ) {\n    onlyCids = onlyCids ? new Set(onlyCids) : null;\n    const output = {\n      buffer: \"\",\n      components: components,\n      onlyCids: onlyCids,\n      streams: new Set(),\n    };\n    this.toOutputBuffer(rendered, null, output, changeTracking, rootAttrs);\n    return { buffer: output.buffer, streams: output.streams };\n  }\n\n  componentCIDs(diff) {\n    return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));\n  }\n\n  isComponentOnlyDiff(diff) {\n    if (!diff[COMPONENTS]) {\n      return false;\n    }\n    return Object.keys(diff).length === 1;\n  }\n\n  getComponent(diff, cid) {\n    return diff[COMPONENTS][cid];\n  }\n\n  resetRender(cid) {\n    // we are racing a component destroy, it could not exist, so\n    // make sure that we don't try to set reset on undefined\n    if (this.rendered[COMPONENTS][cid]) {\n      this.rendered[COMPONENTS][cid].reset = true;\n    }\n  }\n\n  mergeDiff(diff) {\n    const newc = diff[COMPONENTS];\n    const cache = {};\n    delete diff[COMPONENTS];\n    this.rendered = this.mutableMerge(this.rendered, diff);\n    this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};\n\n    if (newc) {\n      const oldc = this.rendered[COMPONENTS];\n\n      for (const cid in newc) {\n        newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);\n      }\n\n      for (const cid in newc) {\n        oldc[cid] = newc[cid];\n      }\n      diff[COMPONENTS] = newc;\n    }\n  }\n\n  cachedFindComponent(cid, cdiff, oldc, newc, cache) {\n    if (cache[cid]) {\n      return cache[cid];\n    } else {\n      let ndiff,\n        stat,\n        scid = cdiff[STATIC];\n\n      if (isCid(scid)) {\n        let tdiff;\n\n        if (scid > 0) {\n          tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);\n        } else {\n          tdiff = oldc[-scid];\n        }\n\n        stat = tdiff[STATIC];\n        ndiff = this.cloneMerge(tdiff, cdiff, true);\n        ndiff[STATIC] = stat;\n      } else {\n        ndiff =\n          cdiff[STATIC] !== undefined || oldc[cid] === undefined\n            ? cdiff\n            : this.cloneMerge(oldc[cid], cdiff, false);\n      }\n\n      cache[cid] = ndiff;\n      return ndiff;\n    }\n  }\n\n  mutableMerge(target, source) {\n    if (source[STATIC] !== undefined) {\n      return source;\n    } else {\n      this.doMutableMerge(target, source);\n      return target;\n    }\n  }\n\n  doMutableMerge(target, source) {\n    if (source[KEYED]) {\n      this.mergeKeyed(target, source);\n    } else {\n      for (const key in source) {\n        const val = source[key];\n        const targetVal = target[key];\n        const isObjVal = isObject(val);\n        if (isObjVal && val[STATIC] === undefined && isObject(targetVal)) {\n          this.doMutableMerge(targetVal, val);\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n    if (target[ROOT]) {\n      target.newRender = true;\n    }\n  }\n\n  clone(diff) {\n    if (\"structuredClone\" in window) {\n      return structuredClone(diff);\n    } else {\n      // fallback for jest\n      return JSON.parse(JSON.stringify(diff));\n    }\n  }\n\n  // keyed comprehensions\n  mergeKeyed(target, source) {\n    // we need to clone the target since elements can move and otherwise\n    // it could happen that we modify an element that we'll need to refer to\n    // later\n    const clonedTarget = this.clone(target);\n    Object.entries(source[KEYED]).forEach(([i, entry]) => {\n      if (i === KEYED_COUNT) {\n        return;\n      }\n      if (Array.isArray(entry)) {\n        // [old_idx, diff]\n        // moved with diff\n        const [old_idx, diff] = entry;\n        target[KEYED][i] = clonedTarget[KEYED][old_idx];\n        this.doMutableMerge(target[KEYED][i], diff);\n      } else if (typeof entry === \"number\") {\n        // moved without diff\n        const old_idx = entry;\n        target[KEYED][i] = clonedTarget[KEYED][old_idx];\n      } else if (typeof entry === \"object\") {\n        // diff, same position\n        if (!target[KEYED][i]) {\n          target[KEYED][i] = {};\n        }\n        this.doMutableMerge(target[KEYED][i], entry);\n      }\n    });\n    // drop extra entries\n    if (source[KEYED][KEYED_COUNT] < target[KEYED][KEYED_COUNT]) {\n      for (\n        let i = source[KEYED][KEYED_COUNT];\n        i < target[KEYED][KEYED_COUNT];\n        i++\n      ) {\n        delete target[KEYED][i];\n      }\n    }\n    target[KEYED][KEYED_COUNT] = source[KEYED][KEYED_COUNT];\n    if (source[STREAM]) {\n      target[STREAM] = source[STREAM];\n    }\n    if (source[TEMPLATES]) {\n      target[TEMPLATES] = source[TEMPLATES];\n    }\n  }\n\n  // Merges cid trees together, copying statics from source tree.\n  //\n  // The `pruneMagicId` is passed to control pruning the magicId of the\n  // target. We must always prune the magicId when we are sharing statics\n  // from another component. If not pruning, we replicate the logic from\n  // mutableMerge, where we set newRender to true if there is a root\n  // (effectively forcing the new version to be rendered instead of skipped)\n  //\n  cloneMerge(target, source, pruneMagicId) {\n    const merged = { ...target, ...source };\n    for (const key in merged) {\n      const val = source[key];\n      const targetVal = target[key];\n      if (isObject(val) && val[STATIC] === undefined && isObject(targetVal)) {\n        merged[key] = this.cloneMerge(targetVal, val, pruneMagicId);\n      } else if (val === undefined && isObject(targetVal)) {\n        merged[key] = this.cloneMerge(targetVal, {}, pruneMagicId);\n      }\n    }\n    if (pruneMagicId) {\n      delete merged.magicId;\n      delete merged.newRender;\n    } else if (target[ROOT]) {\n      merged.newRender = true;\n    }\n    return merged;\n  }\n\n  componentToString(cid) {\n    const { buffer: str, streams } = this.recursiveCIDToString(\n      this.rendered[COMPONENTS],\n      cid,\n      null,\n    );\n    const [strippedHTML, _before, _after] = modifyRoot(str, {});\n    return { buffer: strippedHTML, streams: streams };\n  }\n\n  pruneCIDs(cids) {\n    cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);\n  }\n\n  // private\n\n  get() {\n    return this.rendered;\n  }\n\n  isNewFingerprint(diff = {}) {\n    return !!diff[STATIC];\n  }\n\n  templateStatic(part, templates) {\n    if (typeof part === \"number\") {\n      return templates[part];\n    } else {\n      return part;\n    }\n  }\n\n  nextMagicID() {\n    this.magicId++;\n    return `m${this.magicId}-${this.parentViewId()}`;\n  }\n\n  // Converts rendered tree to output buffer.\n  //\n  // changeTracking controls if we can apply the PHX_SKIP optimization.\n  toOutputBuffer(rendered, templates, output, changeTracking, rootAttrs = {}) {\n    if (rendered[KEYED]) {\n      return this.comprehensionToBuffer(\n        rendered,\n        templates,\n        output,\n        changeTracking,\n      );\n    }\n\n    // Templates are a way of sharing statics between multiple rendered structs.\n    // Since LiveView 1.1, those can also appear at the root - for example if one renders\n    // two comprehensions that can share statics.\n    // Whenever we find templates, we need to use them recursively. Also, templates can\n    // be sent for each diff, not only for the initial one. We don't want to merge them\n    // though, so we always resolve them and remove them from the rendered object.\n    if (rendered[TEMPLATES]) {\n      templates = rendered[TEMPLATES];\n      delete rendered[TEMPLATES];\n    }\n\n    let { [STATIC]: statics } = rendered;\n    statics = this.templateStatic(statics, templates);\n    rendered[STATIC] = statics;\n    const isRoot = rendered[ROOT];\n    const prevBuffer = output.buffer;\n    if (isRoot) {\n      output.buffer = \"\";\n    }\n\n    // this condition is called when first rendering an optimizable function component.\n    // LC have their magicId previously set\n    if (changeTracking && isRoot && !rendered.magicId) {\n      rendered.newRender = true;\n      rendered.magicId = this.nextMagicID();\n    }\n\n    output.buffer += statics[0];\n    for (let i = 1; i < statics.length; i++) {\n      this.dynamicToBuffer(rendered[i - 1], templates, output, changeTracking);\n      output.buffer += statics[i];\n    }\n\n    // Applies the root tag \"skip\" optimization if supported, which clears\n    // the root tag attributes and innerHTML, and only maintains the magicId.\n    // We can only skip when changeTracking is supported,\n    // and when the root element hasn't experienced an unrendered merge (newRender true).\n    if (isRoot) {\n      let skip = false;\n      let attrs;\n      // When a LC is re-added to the page, we need to re-render the entire LC tree,\n      // therefore changeTracking is false; however, we need to keep all the magicIds\n      // from any function component so the next time the LC is updated, we can apply\n      // the skip optimization\n      if (changeTracking || rendered.magicId) {\n        skip = changeTracking && !rendered.newRender;\n        attrs = { [PHX_MAGIC_ID]: rendered.magicId, ...rootAttrs };\n      } else {\n        attrs = rootAttrs;\n      }\n      if (skip) {\n        attrs[PHX_SKIP] = true;\n      }\n      const [newRoot, commentBefore, commentAfter] = modifyRoot(\n        output.buffer,\n        attrs,\n        skip,\n      );\n      rendered.newRender = false;\n      output.buffer = prevBuffer + commentBefore + newRoot + commentAfter;\n    }\n  }\n\n  comprehensionToBuffer(rendered, templates, output, changeTracking) {\n    const keyedTemplates = templates || rendered[TEMPLATES];\n    const statics = this.templateStatic(rendered[STATIC], templates);\n    rendered[STATIC] = statics;\n    delete rendered[TEMPLATES];\n    for (let i = 0; i < rendered[KEYED][KEYED_COUNT]; i++) {\n      output.buffer += statics[0];\n      for (let j = 1; j < statics.length; j++) {\n        this.dynamicToBuffer(\n          rendered[KEYED][i][j - 1],\n          keyedTemplates,\n          output,\n          changeTracking,\n        );\n        output.buffer += statics[j];\n      }\n    }\n    // we don't need to store the rendered tree for streams\n    if (rendered[STREAM]) {\n      const stream = rendered[STREAM];\n      const [_ref, _inserts, deleteIds, reset] = stream || [null, {}, [], null];\n      if (\n        stream !== undefined &&\n        (rendered[KEYED][KEYED_COUNT] > 0 || deleteIds.length > 0 || reset)\n      ) {\n        delete rendered[STREAM];\n        rendered[KEYED] = {\n          [KEYED_COUNT]: 0,\n        };\n        output.streams.add(stream);\n      }\n    }\n  }\n\n  dynamicToBuffer(rendered, templates, output, changeTracking) {\n    if (typeof rendered === \"number\") {\n      const { buffer: str, streams } = this.recursiveCIDToString(\n        output.components,\n        rendered,\n        output.onlyCids,\n      );\n      output.buffer += str;\n      output.streams = new Set([...output.streams, ...streams]);\n    } else if (isObject(rendered)) {\n      this.toOutputBuffer(rendered, templates, output, changeTracking, {});\n    } else {\n      output.buffer += rendered;\n    }\n  }\n\n  recursiveCIDToString(components, cid, onlyCids) {\n    const component =\n      components[cid] || logError(`no component for CID ${cid}`, components);\n    const attrs = { [PHX_COMPONENT]: cid, [PHX_VIEW_REF]: this.viewId };\n    const skip = onlyCids && !onlyCids.has(cid);\n    // Two optimization paths apply here:\n    //\n    //   1. The onlyCids optimization works by the server diff telling us only specific\n    //     cid's have changed. This allows us to skip rendering any component that hasn't changed,\n    //     which ultimately sets PHX_SKIP root attribute and avoids rendering the innerHTML.\n    //\n    //   2. The root PHX_SKIP optimization generalizes to all HEEx function components, and\n    //     works in the same PHX_SKIP attribute fashion as 1, but the newRender tracking is done\n    //     at the general diff merge level. If we merge a diff with new dynamics, we necessarily have\n    //     experienced a change which must be a newRender, and thus we can't skip the render.\n    //\n    // Both optimization flows apply here. newRender is set based on the onlyCids optimization, and\n    // we track a deterministic magicId based on the cid.\n    //\n    // changeTracking is about the entire tree\n    // newRender is about the current root in the tree\n    //\n    // By default changeTracking is enabled, but we special case the flow where the client is pruning\n    // cids and the server adds the component back. In such cases, we explicitly disable changeTracking\n    // with resetRender for this cid, then re-enable it after the recursive call to skip the optimization\n    // for the entire component tree.\n    component.newRender = !skip;\n    component.magicId = `c${cid}-${this.parentViewId()}`;\n    // enable change tracking as long as the component hasn't been reset\n    const changeTracking = !component.reset;\n    const { buffer: html, streams } = this.recursiveToString(\n      component,\n      components,\n      onlyCids,\n      changeTracking,\n      attrs,\n    );\n    // disable reset after we've rendered\n    delete component.reset;\n\n    return { buffer: html, streams: streams };\n  }\n}\n", "import DOM from \"./dom\";\nimport ARIA from \"./aria\";\n\nconst focusStack = [];\nconst default_transition_time = 200;\n\nconst JS = {\n  // private\n  exec(e, eventType, phxEvent, view, sourceEl, defaults) {\n    const [defaultKind, defaultArgs] = defaults || [\n      null,\n      { callback: defaults && defaults.callback },\n    ];\n    const commands =\n      phxEvent.charAt(0) === \"[\"\n        ? JSON.parse(phxEvent)\n        : [[defaultKind, defaultArgs]];\n\n    commands.forEach(([kind, args]) => {\n      if (kind === defaultKind) {\n        // always prefer the args, but keep existing keys from the defaultArgs\n        args = { ...defaultArgs, ...args };\n        args.callback = args.callback || defaultArgs.callback;\n      }\n      this.filterToEls(view.liveSocket, sourceEl, args).forEach((el) => {\n        this[`exec_${kind}`](e, eventType, phxEvent, view, sourceEl, el, args);\n      });\n    });\n  },\n\n  isVisible(el) {\n    return !!(\n      el.offsetWidth ||\n      el.offsetHeight ||\n      el.getClientRects().length > 0\n    );\n  },\n\n  // returns true if any part of the element is inside the viewport\n  isInViewport(el) {\n    const rect = el.getBoundingClientRect();\n    const windowHeight =\n      window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth =\n      window.innerWidth || document.documentElement.clientWidth;\n\n    return (\n      rect.right > 0 &&\n      rect.bottom > 0 &&\n      rect.left < windowWidth &&\n      rect.top < windowHeight\n    );\n  },\n\n  // private\n\n  // commands\n\n  exec_exec(e, eventType, phxEvent, view, sourceEl, el, { attr, to }) {\n    const encodedJS = el.getAttribute(attr);\n    if (!encodedJS) {\n      throw new Error(`expected ${attr} to contain JS command on \"${to}\"`);\n    }\n    view.liveSocket.execJS(el, encodedJS, eventType);\n  },\n\n  exec_dispatch(\n    e,\n    eventType,\n    phxEvent,\n    view,\n    sourceEl,\n    el,\n    { event, detail, bubbles, blocking },\n  ) {\n    detail = detail || {};\n    detail.dispatcher = sourceEl;\n    if (blocking) {\n      const promise = new Promise((resolve, _reject) => {\n        detail.done = resolve;\n      });\n      view.liveSocket.asyncTransition(promise);\n    }\n    DOM.dispatchEvent(el, event, { detail, bubbles });\n  },\n\n  exec_push(e, eventType, phxEvent, view, sourceEl, el, args) {\n    const {\n      event,\n      data,\n      target,\n      page_loading,\n      loading,\n      value,\n      dispatcher,\n      callback,\n    } = args;\n    const pushOpts = {\n      loading,\n      value,\n      target,\n      page_loading: !!page_loading,\n      originalEvent: e,\n    };\n    const targetSrc =\n      eventType === \"change\" && dispatcher ? dispatcher : sourceEl;\n    const phxTarget =\n      target || targetSrc.getAttribute(view.binding(\"target\")) || targetSrc;\n    const handler = (targetView, targetCtx) => {\n      if (!targetView.isConnected()) {\n        return;\n      }\n      if (eventType === \"change\") {\n        let { newCid, _target } = args;\n        _target =\n          _target || (DOM.isFormInput(sourceEl) ? sourceEl.name : undefined);\n        if (_target) {\n          pushOpts._target = _target;\n        }\n        targetView.pushInput(\n          sourceEl,\n          targetCtx,\n          newCid,\n          event || phxEvent,\n          pushOpts,\n          callback,\n        );\n      } else if (eventType === \"submit\") {\n        const { submitter } = args;\n        targetView.submitForm(\n          sourceEl,\n          targetCtx,\n          event || phxEvent,\n          submitter,\n          pushOpts,\n          callback,\n        );\n      } else {\n        targetView.pushEvent(\n          eventType,\n          sourceEl,\n          targetCtx,\n          event || phxEvent,\n          data,\n          pushOpts,\n          callback,\n        );\n      }\n    };\n    // in case of formRecovery, targetView and targetCtx are passed as argument\n    // as they are looked up in a template element, not the real DOM\n    if (args.targetView && args.targetCtx) {\n      handler(args.targetView, args.targetCtx);\n    } else {\n      view.withinTargets(phxTarget, handler);\n    }\n  },\n\n  exec_navigate(e, eventType, phxEvent, view, sourceEl, el, { href, replace }) {\n    view.liveSocket.historyRedirect(\n      e,\n      href,\n      replace ? \"replace\" : \"push\",\n      null,\n      sourceEl,\n    );\n  },\n\n  exec_patch(e, eventType, phxEvent, view, sourceEl, el, { href, replace }) {\n    view.liveSocket.pushHistoryPatch(\n      e,\n      href,\n      replace ? \"replace\" : \"push\",\n      sourceEl,\n    );\n  },\n\n  exec_focus(e, eventType, phxEvent, view, sourceEl, el) {\n    ARIA.attemptFocus(el);\n    // in case the JS.focus command is in a JS.show/hide/toggle chain, for show we need\n    // to wait for JS.show to have updated the element's display property (see exec_toggle)\n    // but that run in nested animation frames, therefore we need to use them here as well\n    window.requestAnimationFrame(() => {\n      window.requestAnimationFrame(() => ARIA.attemptFocus(el));\n    });\n  },\n\n  exec_focus_first(e, eventType, phxEvent, view, sourceEl, el) {\n    ARIA.focusFirstInteractive(el) || ARIA.focusFirst(el);\n    // if you wonder about the nested animation frames, see exec_focus\n    window.requestAnimationFrame(() => {\n      window.requestAnimationFrame(\n        () => ARIA.focusFirstInteractive(el) || ARIA.focusFirst(el),\n      );\n    });\n  },\n\n  exec_push_focus(e, eventType, phxEvent, view, sourceEl, el) {\n    focusStack.push(el || sourceEl);\n  },\n\n  exec_pop_focus(_e, _eventType, _phxEvent, _view, _sourceEl, _el) {\n    const el = focusStack.pop();\n    if (el) {\n      el.focus();\n      // if you wonder about the nested animation frames, see exec_focus\n      window.requestAnimationFrame(() => {\n        window.requestAnimationFrame(() => el.focus());\n      });\n    }\n  },\n\n  exec_add_class(\n    e,\n    eventType,\n    phxEvent,\n    view,\n    sourceEl,\n    el,\n    { names, transition, time, blocking },\n  ) {\n    this.addOrRemoveClasses(el, names, [], transition, time, view, blocking);\n  },\n\n  exec_remove_class(\n    e,\n    eventType,\n    phxEvent,\n    view,\n    sourceEl,\n    el,\n    { names, transition, time, blocking },\n  ) {\n    this.addOrRemoveClasses(el, [], names, transition, time, view, blocking);\n  },\n\n  exec_toggle_class(\n    e,\n    eventType,\n    phxEvent,\n    view,\n    sourceEl,\n    el,\n    { names, transition, time, blocking },\n  ) {\n    this.toggleClasses(el, names, transition, time, view, blocking);\n  },\n\n  exec_toggle_attr(\n    e,\n    eventType,\n    phxEvent,\n    view,\n    sourceEl,\n    el,\n    { attr: [attr, val1, val2] },\n  ) {\n    this.toggleAttr(el, attr, val1, val2);\n  },\n\n  exec_ignore_attrs(e, eventType, phxEvent, view, sourceEl, el, { attrs }) {\n    this.ignoreAttrs(el, attrs);\n  },\n\n  exec_transition(\n    e,\n    eventType,\n    phxEvent,\n    view,\n    sourceEl,\n    el,\n    { time, transition, blocking },\n  ) {\n    this.addOrRemoveClasses(el, [], [], transition, time, view, blocking);\n  },\n\n  exec_toggle(\n    e,\n    eventType,\n    phxEvent,\n    view,\n    sourceEl,\n    el,\n    { display, ins, outs, time, blocking },\n  ) {\n    this.toggle(eventType, view, el, display, ins, outs, time, blocking);\n  },\n\n  exec_show(\n    e,\n    eventType,\n    phxEvent,\n    view,\n    sourceEl,\n    el,\n    { display, transition, time, blocking },\n  ) {\n    this.show(eventType, view, el, display, transition, time, blocking);\n  },\n\n  exec_hide(\n    e,\n    eventType,\n    phxEvent,\n    view,\n    sourceEl,\n    el,\n    { display, transition, time, blocking },\n  ) {\n    this.hide(eventType, view, el, display, transition, time, blocking);\n  },\n\n  exec_set_attr(\n    e,\n    eventType,\n    phxEvent,\n    view,\n    sourceEl,\n    el,\n    { attr: [attr, val] },\n  ) {\n    this.setOrRemoveAttrs(el, [[attr, val]], []);\n  },\n\n  exec_remove_attr(e, eventType, phxEvent, view, sourceEl, el, { attr }) {\n    this.setOrRemoveAttrs(el, [], [attr]);\n  },\n\n  ignoreAttrs(el, attrs) {\n    DOM.putPrivate(el, \"JS:ignore_attrs\", {\n      apply: (fromEl, toEl) => {\n        Array.from(fromEl.attributes).forEach((attr) => {\n          if (\n            attrs.some(\n              (toIgnore) =>\n                attr.name == toIgnore ||\n                (toIgnore.includes(\"*\") && attr.name.match(toIgnore) != null),\n            )\n          ) {\n            toEl.setAttribute(attr.name, attr.value);\n          }\n        });\n      },\n    });\n  },\n\n  onBeforeElUpdated(fromEl, toEl) {\n    const ignoreAttrs = DOM.private(fromEl, \"JS:ignore_attrs\");\n    if (ignoreAttrs) {\n      ignoreAttrs.apply(fromEl, toEl);\n    }\n  },\n\n  // utils for commands\n\n  show(eventType, view, el, display, transition, time, blocking) {\n    if (!this.isVisible(el)) {\n      this.toggle(\n        eventType,\n        view,\n        el,\n        display,\n        transition,\n        null,\n        time,\n        blocking,\n      );\n    }\n  },\n\n  hide(eventType, view, el, display, transition, time, blocking) {\n    if (this.isVisible(el)) {\n      this.toggle(\n        eventType,\n        view,\n        el,\n        display,\n        null,\n        transition,\n        time,\n        blocking,\n      );\n    }\n  },\n\n  toggle(eventType, view, el, display, ins, outs, time, blocking) {\n    time = time || default_transition_time;\n    const [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];\n    const [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];\n    if (inClasses.length > 0 || outClasses.length > 0) {\n      if (this.isVisible(el)) {\n        const onStart = () => {\n          this.addOrRemoveClasses(\n            el,\n            outStartClasses,\n            inClasses.concat(inStartClasses).concat(inEndClasses),\n          );\n          window.requestAnimationFrame(() => {\n            this.addOrRemoveClasses(el, outClasses, []);\n            window.requestAnimationFrame(() =>\n              this.addOrRemoveClasses(el, outEndClasses, outStartClasses),\n            );\n          });\n        };\n        const onEnd = () => {\n          this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));\n          DOM.putSticky(\n            el,\n            \"toggle\",\n            (currentEl) => (currentEl.style.display = \"none\"),\n          );\n          el.dispatchEvent(new Event(\"phx:hide-end\"));\n        };\n        el.dispatchEvent(new Event(\"phx:hide-start\"));\n        if (blocking === false) {\n          onStart();\n          setTimeout(onEnd, time);\n        } else {\n          view.transition(time, onStart, onEnd);\n        }\n      } else {\n        if (eventType === \"remove\") {\n          return;\n        }\n        const onStart = () => {\n          this.addOrRemoveClasses(\n            el,\n            inStartClasses,\n            outClasses.concat(outStartClasses).concat(outEndClasses),\n          );\n          const stickyDisplay = display || this.defaultDisplay(el);\n          window.requestAnimationFrame(() => {\n            // first add the starting + active class, THEN make the element visible\n            // otherwise if we toggled the visibility earlier css animations\n            // would flicker, as the element becomes visible before the active animation\n            // class is set (see https://github.com/phoenixframework/phoenix_live_view/issues/3456)\n            this.addOrRemoveClasses(el, inClasses, []);\n            // addOrRemoveClasses uses a requestAnimationFrame itself, therefore we need to move the putSticky\n            // into the next requestAnimationFrame...\n            window.requestAnimationFrame(() => {\n              DOM.putSticky(\n                el,\n                \"toggle\",\n                (currentEl) => (currentEl.style.display = stickyDisplay),\n              );\n              this.addOrRemoveClasses(el, inEndClasses, inStartClasses);\n            });\n          });\n        };\n        const onEnd = () => {\n          this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));\n          el.dispatchEvent(new Event(\"phx:show-end\"));\n        };\n        el.dispatchEvent(new Event(\"phx:show-start\"));\n        if (blocking === false) {\n          onStart();\n          setTimeout(onEnd, time);\n        } else {\n          view.transition(time, onStart, onEnd);\n        }\n      }\n    } else {\n      if (this.isVisible(el)) {\n        window.requestAnimationFrame(() => {\n          el.dispatchEvent(new Event(\"phx:hide-start\"));\n          DOM.putSticky(\n            el,\n            \"toggle\",\n            (currentEl) => (currentEl.style.display = \"none\"),\n          );\n          el.dispatchEvent(new Event(\"phx:hide-end\"));\n        });\n      } else {\n        window.requestAnimationFrame(() => {\n          el.dispatchEvent(new Event(\"phx:show-start\"));\n          const stickyDisplay = display || this.defaultDisplay(el);\n          DOM.putSticky(\n            el,\n            \"toggle\",\n            (currentEl) => (currentEl.style.display = stickyDisplay),\n          );\n          el.dispatchEvent(new Event(\"phx:show-end\"));\n        });\n      }\n    }\n  },\n\n  toggleClasses(el, classes, transition, time, view, blocking) {\n    window.requestAnimationFrame(() => {\n      const [prevAdds, prevRemoves] = DOM.getSticky(el, \"classes\", [[], []]);\n      const newAdds = classes.filter(\n        (name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name),\n      );\n      const newRemoves = classes.filter(\n        (name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name),\n      );\n      this.addOrRemoveClasses(\n        el,\n        newAdds,\n        newRemoves,\n        transition,\n        time,\n        view,\n        blocking,\n      );\n    });\n  },\n\n  toggleAttr(el, attr, val1, val2) {\n    if (el.hasAttribute(attr)) {\n      if (val2 !== undefined) {\n        // toggle between val1 and val2\n        if (el.getAttribute(attr) === val1) {\n          this.setOrRemoveAttrs(el, [[attr, val2]], []);\n        } else {\n          this.setOrRemoveAttrs(el, [[attr, val1]], []);\n        }\n      } else {\n        // remove attr\n        this.setOrRemoveAttrs(el, [], [attr]);\n      }\n    } else {\n      this.setOrRemoveAttrs(el, [[attr, val1]], []);\n    }\n  },\n\n  addOrRemoveClasses(el, adds, removes, transition, time, view, blocking) {\n    time = time || default_transition_time;\n    const [transitionRun, transitionStart, transitionEnd] = transition || [\n      [],\n      [],\n      [],\n    ];\n    if (transitionRun.length > 0) {\n      const onStart = () => {\n        this.addOrRemoveClasses(\n          el,\n          transitionStart,\n          [].concat(transitionRun).concat(transitionEnd),\n        );\n        window.requestAnimationFrame(() => {\n          this.addOrRemoveClasses(el, transitionRun, []);\n          window.requestAnimationFrame(() =>\n            this.addOrRemoveClasses(el, transitionEnd, transitionStart),\n          );\n        });\n      };\n      const onDone = () =>\n        this.addOrRemoveClasses(\n          el,\n          adds.concat(transitionEnd),\n          removes.concat(transitionRun).concat(transitionStart),\n        );\n      if (blocking === false) {\n        onStart();\n        setTimeout(onDone, time);\n      } else {\n        view.transition(time, onStart, onDone);\n      }\n      return;\n    }\n\n    window.requestAnimationFrame(() => {\n      const [prevAdds, prevRemoves] = DOM.getSticky(el, \"classes\", [[], []]);\n      const keepAdds = adds.filter(\n        (name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name),\n      );\n      const keepRemoves = removes.filter(\n        (name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name),\n      );\n      const newAdds = prevAdds\n        .filter((name) => removes.indexOf(name) < 0)\n        .concat(keepAdds);\n      const newRemoves = prevRemoves\n        .filter((name) => adds.indexOf(name) < 0)\n        .concat(keepRemoves);\n\n      DOM.putSticky(el, \"classes\", (currentEl) => {\n        currentEl.classList.remove(...newRemoves);\n        currentEl.classList.add(...newAdds);\n        return [newAdds, newRemoves];\n      });\n    });\n  },\n\n  setOrRemoveAttrs(el, sets, removes) {\n    const [prevSets, prevRemoves] = DOM.getSticky(el, \"attrs\", [[], []]);\n\n    const alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);\n    const newSets = prevSets\n      .filter(([attr, _val]) => !alteredAttrs.includes(attr))\n      .concat(sets);\n    const newRemoves = prevRemoves\n      .filter((attr) => !alteredAttrs.includes(attr))\n      .concat(removes);\n\n    DOM.putSticky(el, \"attrs\", (currentEl) => {\n      newRemoves.forEach((attr) => currentEl.removeAttribute(attr));\n      newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));\n      return [newSets, newRemoves];\n    });\n  },\n\n  hasAllClasses(el, classes) {\n    return classes.every((name) => el.classList.contains(name));\n  },\n\n  isToggledOut(el, outClasses) {\n    return !this.isVisible(el) || this.hasAllClasses(el, outClasses);\n  },\n\n  filterToEls(liveSocket, sourceEl, { to }) {\n    const defaultQuery = () => {\n      if (typeof to === \"string\") {\n        return document.querySelectorAll(to);\n      } else if (to.closest) {\n        const toEl = sourceEl.closest(to.closest);\n        return toEl ? [toEl] : [];\n      } else if (to.inner) {\n        return sourceEl.querySelectorAll(to.inner);\n      }\n    };\n    return to\n      ? liveSocket.jsQuerySelectorAll(sourceEl, to, defaultQuery)\n      : [sourceEl];\n  },\n\n  defaultDisplay(el) {\n    return (\n      { tr: \"table-row\", td: \"table-cell\" }[el.tagName.toLowerCase()] || \"block\"\n    );\n  },\n\n  transitionClasses(val) {\n    if (!val) {\n      return null;\n    }\n\n    let [trans, tStart, tEnd] = Array.isArray(val)\n      ? val\n      : [val.split(\" \"), [], []];\n    trans = Array.isArray(trans) ? trans : trans.split(\" \");\n    tStart = Array.isArray(tStart) ? tStart : tStart.split(\" \");\n    tEnd = Array.isArray(tEnd) ? tEnd : tEnd.split(\" \");\n    return [trans, tStart, tEnd];\n  },\n};\n\nexport default JS;\n", "import JS from \"./js\";\nimport LiveSocket from \"./live_socket\";\n\ntype Transition = string | string[];\n\n// Base options for commands involving transitions and timing\ntype BaseOpts = {\n  /**\n   * The CSS transition classes to set.\n   * Accepts a string of classes or a 3-tuple like:\n   * `[\"ease-out duration-300\", \"opacity-0\", \"opacity-100\"]`\n   */\n  transition?: Transition;\n  /** The transition duration in milliseconds. Defaults 200. */\n  time?: number;\n  /** Whether to block UI during transition. Defaults `true`. */\n  blocking?: boolean;\n};\n\ntype ShowOpts = BaseOpts & {\n  /** The CSS display value to set. Defaults \"block\". */\n  display?: string;\n};\n\ntype ToggleOpts = {\n  /** The CSS display value to set. Defaults \"block\". */\n  display?: string;\n  /**\n   * The CSS transition classes for showing.\n   * Accepts either the string of classes to apply when toggling in, or\n   * a 3-tuple containing the transition class, the class to apply\n   * to start the transition, and the ending transition class, such as:\n   * `[\"ease-out duration-300\", \"opacity-0\", \"opacity-100\"]`\n   */\n  in?: Transition;\n  /**\n   * The CSS transition classes for hiding.\n   * Accepts either string of classes to apply when toggling out, or\n   * a 3-tuple containing the transition class, the class to apply\n   * to start the transition, and the ending transition class, such as:\n   * `[\"ease-out duration-300\", \"opacity-100\", \"opacity-0\"]`\n   */\n  out?: Transition;\n  /** The transition duration in milliseconds. */\n  time?: number;\n  /** Whether to block UI during transition. Defaults `true`. */\n  blocking?: boolean;\n};\n\n// Options specific to the 'transition' command\ntype TransitionCommandOpts = {\n  /** The transition duration in milliseconds. */\n  time?: number;\n  /** Whether to block UI during transition. Defaults `true`. */\n  blocking?: boolean;\n};\n\ntype PushOpts = {\n  /** Data to be merged into the event payload. */\n  value?: any;\n  /** For targeting a LiveComponent by its ID, a component ID (number), or a CSS selector string. */\n  target?: HTMLElement | number | string;\n  /** Indicates if a page loading state should be shown. */\n  page_loading?: boolean;\n  [key: string]: any; // Allow other properties like 'cid', 'redirect', etc.\n};\n\ntype NavigationOpts = {\n  /** Whether to replace the current history entry instead of pushing a new one. */\n  replace?: boolean;\n};\n\n/**\n * Represents all possible JS commands that can be generated by the factory.\n * This is used as a base for LiveSocketJSCommands and HookJSCommands.\n */\ninterface AllJSCommands {\n  /**\n   * Executes encoded JavaScript in the context of the element.\n   * This version is for general use via liveSocket.js().\n   *\n   * @param el - The element in whose context to execute the JavaScript.\n   * @param encodedJS - The encoded JavaScript string to execute.\n   */\n  exec(el: HTMLElement, encodedJS: string): void;\n\n  /**\n   * Shows an element.\n   *\n   * @param el - The element to show.\n   * @param {ShowOpts} [opts={}] - Optional settings.\n   *   Accepts: `display`, `transition`, `time`, and `blocking`.\n   */\n  show(el: HTMLElement, opts?: ShowOpts): void;\n\n  /**\n   * Hides an element.\n   *\n   * @param el - The element to hide.\n   * @param [opts={}] - Optional settings.\n   *   Accepts: `transition`, `time`, and `blocking`.\n   */\n  hide(el: HTMLElement, opts?: BaseOpts): void;\n\n  /**\n   * Toggles the visibility of an element.\n   *\n   * @param el - The element to toggle.\n   * @param [opts={}] - Optional settings.\n   *   Accepts: `display`, `in`, `out`, `time`, and `blocking`.\n   */\n  toggle(el: HTMLElement, opts?: ToggleOpts): void;\n\n  /**\n   * Adds CSS classes to an element.\n   *\n   * @param el - The element to add classes to.\n   * @param names - The class name(s) to add.\n   * @param [opts={}] - Optional settings.\n   *   Accepts: `transition`, `time`, and `blocking`.\n   */\n  addClass(el: HTMLElement, names: string | string[], opts?: BaseOpts): void;\n\n  /**\n   * Removes CSS classes from an element.\n   *\n   * @param el - The element to remove classes from.\n   * @param names - The class name(s) to remove.\n   * @param [opts={}] - Optional settings.\n   *   Accepts: `transition`, `time`, and `blocking`.\n   */\n  removeClass(el: HTMLElement, names: string | string[], opts?: BaseOpts): void;\n\n  /**\n   * Toggles CSS classes on an element.\n   *\n   * @param el - The element to toggle classes on.\n   * @param names - The class name(s) to toggle.\n   * @param [opts={}] - Optional settings.\n   *   Accepts: `transition`, `time`, and `blocking`.\n   */\n  toggleClass(el: HTMLElement, names: string | string[], opts?: BaseOpts): void;\n\n  /**\n   * Applies a CSS transition to an element.\n   *\n   * @param el - The element to apply the transition to.\n   * @param transition - The transition class(es) to apply.\n   *   Accepts a string of classes to apply when transitioning or\n   *   a 3-tuple containing the transition class, the class to apply\n   *   to start the transition, and the ending transition class, such as:\n   *\n   *       [\"ease-out duration-300\", \"opacity-100\", \"opacity-0\"]\n   *\n   * @param [opts={}] - Optional settings for timing and blocking behavior.\n   *   Accepts: `time` and `blocking`.\n   */\n  transition(\n    el: HTMLElement,\n    transition: string | string[],\n    opts?: TransitionCommandOpts,\n  ): void;\n\n  /**\n   * Sets an attribute on an element.\n   *\n   * @param el - The element to set the attribute on.\n   * @param attr - The attribute name to set.\n   * @param val - The value to set for the attribute.\n   */\n  setAttribute(el: HTMLElement, attr: string, val: string): void;\n\n  /**\n   * Removes an attribute from an element.\n   *\n   * @param el - The element to remove the attribute from.\n   * @param attr - The attribute name to remove.\n   */\n  removeAttribute(el: HTMLElement, attr: string): void;\n\n  /**\n   * Toggles an attribute on an element between two values.\n   *\n   * @param el - The element to toggle the attribute on.\n   * @param attr - The attribute name to toggle.\n   * @param val1 - The first value to toggle between.\n   * @param val2 - The second value to toggle between.\n   */\n  toggleAttribute(\n    el: HTMLElement,\n    attr: string,\n    val1: string,\n    val2: string,\n  ): void;\n\n  /**\n   * Pushes an event to the server.\n   *\n   * @param el - An element that belongs to the target LiveView / LiveComponent or a component ID.\n   *   To target a LiveComponent by its ID, pass a separate `target` in the options.\n   * @param type - The event name to push.\n   * @param [opts={}] - Optional settings.\n   *   Accepts: `value`, `target`, `page_loading`.\n   */\n  push(el: HTMLElement, type: string, opts?: PushOpts): void;\n\n  /**\n   * Sends a navigation event to the server and updates the browser's pushState history.\n   *\n   * @param href - The URL to navigate to.\n   * @param [opts={}] - Optional settings.\n   *   Accepts: `replace`.\n   */\n  navigate(href: string, opts?: NavigationOpts): void;\n\n  /**\n   * Sends a patch event to the server and updates the browser's pushState history.\n   *\n   * @param href - The URL to patch to.\n   * @param [opts={}] - Optional settings.\n   *   Accepts: `replace`.\n   */\n  patch(href: string, opts?: NavigationOpts): void;\n\n  /**\n   * Mark attributes as ignored, skipping them when patching the DOM.\n   *\n   * @param el - The element to ignore attributes on.\n   * @param attrs - The attribute name or names to ignore.\n   */\n  ignoreAttributes(el: HTMLElement, attrs: string | string[]): void;\n}\n\nexport default (\n  liveSocket: LiveSocket,\n  eventType: string | null,\n): AllJSCommands => {\n  return {\n    exec(el, encodedJS) {\n      liveSocket.execJS(el, encodedJS, eventType);\n    },\n    show(el, opts = {}) {\n      const owner = liveSocket.owner(el);\n      JS.show(\n        eventType,\n        owner,\n        el,\n        opts.display,\n        JS.transitionClasses(opts.transition),\n        opts.time,\n        opts.blocking,\n      );\n    },\n    hide(el, opts = {}) {\n      const owner = liveSocket.owner(el);\n      JS.hide(\n        eventType,\n        owner,\n        el,\n        null,\n        JS.transitionClasses(opts.transition),\n        opts.time,\n        opts.blocking,\n      );\n    },\n    toggle(el, opts = {}) {\n      const owner = liveSocket.owner(el);\n      const inTransition = JS.transitionClasses(opts.in);\n      const outTransition = JS.transitionClasses(opts.out);\n      JS.toggle(\n        eventType,\n        owner,\n        el,\n        opts.display,\n        inTransition,\n        outTransition,\n        opts.time,\n        opts.blocking,\n      );\n    },\n    addClass(el, names, opts = {}) {\n      const classNames = Array.isArray(names) ? names : names.split(\" \");\n      const owner = liveSocket.owner(el);\n      JS.addOrRemoveClasses(\n        el,\n        classNames,\n        [],\n        JS.transitionClasses(opts.transition),\n        opts.time,\n        owner,\n        opts.blocking,\n      );\n    },\n    removeClass(el, names, opts = {}) {\n      const classNames = Array.isArray(names) ? names : names.split(\" \");\n      const owner = liveSocket.owner(el);\n      JS.addOrRemoveClasses(\n        el,\n        [],\n        classNames,\n        JS.transitionClasses(opts.transition),\n        opts.time,\n        owner,\n        opts.blocking,\n      );\n    },\n    toggleClass(el, names, opts = {}) {\n      const classNames = Array.isArray(names) ? names : names.split(\" \");\n      const owner = liveSocket.owner(el);\n      JS.toggleClasses(\n        el,\n        classNames,\n        JS.transitionClasses(opts.transition),\n        opts.time,\n        owner,\n        opts.blocking,\n      );\n    },\n    transition(el, transition, opts = {}) {\n      const owner = liveSocket.owner(el);\n      JS.addOrRemoveClasses(\n        el,\n        [],\n        [],\n        JS.transitionClasses(transition),\n        opts.time,\n        owner,\n        opts.blocking,\n      );\n    },\n    setAttribute(el, attr, val) {\n      JS.setOrRemoveAttrs(el, [[attr, val]], []);\n    },\n    removeAttribute(el, attr) {\n      JS.setOrRemoveAttrs(el, [], [attr]);\n    },\n    toggleAttribute(el, attr, val1, val2) {\n      JS.toggleAttr(el, attr, val1, val2);\n    },\n    push(el, type, opts = {}) {\n      liveSocket.withinOwners(el, (view) => {\n        const data = opts.value || {};\n        delete opts.value;\n        let e = new CustomEvent(\"phx:exec\", { detail: { sourceElement: el } });\n        JS.exec(e, eventType, type, view, el, [\"push\", { data, ...opts }]);\n      });\n    },\n    navigate(href, opts = {}) {\n      const customEvent = new CustomEvent(\"phx:exec\");\n      liveSocket.historyRedirect(\n        customEvent,\n        href,\n        opts.replace ? \"replace\" : \"push\",\n        null,\n        null,\n      );\n    },\n    patch(href, opts = {}) {\n      const customEvent = new CustomEvent(\"phx:exec\");\n      liveSocket.pushHistoryPatch(\n        customEvent,\n        href,\n        opts.replace ? \"replace\" : \"push\",\n        null,\n      );\n    },\n    ignoreAttributes(el, attrs) {\n      JS.ignoreAttrs(el, Array.isArray(attrs) ? attrs : [attrs]);\n    },\n  };\n};\n\n/**\n * JSCommands for use with `liveSocket.js()`.\n * Includes the general `exec` command that requires an element.\n */\nexport type LiveSocketJSCommands = AllJSCommands;\n\n/**\n * JSCommands for use within a Hook.\n * The `exec` command is tailored for hooks, not requiring an explicit element.\n */\nexport interface HookJSCommands extends Omit<AllJSCommands, \"exec\"> {\n  /**\n   * Executes encoded JavaScript in the context of the hook's element.\n   *\n   * @param {string} encodedJS - The encoded JavaScript string to execute.\n   */\n  exec(encodedJS: string): void;\n}\n", "import jsCommands, { HookJSCommands } from \"./js_commands\";\nimport DOM from \"./dom\";\nimport LiveSocket from \"./live_socket\";\nimport View from \"./view\";\n\nconst HOOK_ID = \"hookId\";\nlet viewHookID = 1;\n\nexport type OnReply = (reply: any, ref: number) => any;\nexport type CallbackRef = { event: string; callback: (payload: any) => any };\n\nexport type PhxTarget = string | number | HTMLElement;\n\nexport interface HookInterface {\n  /**\n   * The DOM element that the hook is attached to.\n   */\n  el: HTMLElement;\n\n  /**\n   * The LiveSocket instance that the hook is attached to.\n   */\n  liveSocket: LiveSocket;\n\n  /**\n   * The mounted callback.\n   *\n   * Called when the element has been added to the DOM and its server LiveView has finished mounting.\n   */\n  mounted?: () => void;\n\n  /**\n   * The beforeUpdate callback.\n   *\n   * Called when the element is about to be updated in the DOM.\n   * Note: any call here must be synchronous as the operation cannot be deferred or cancelled.\n   */\n  beforeUpdate?: () => void;\n\n  /**\n   * The updated callback.\n   *\n   * Called when the element has been updated in the DOM by the server\n   */\n  updated?: () => void;\n\n  /**\n   * The destroyed callback.\n   *\n   * Called when the element has been removed from the page, either by a parent update, or by the parent being removed entirely\n   */\n  destroyed?: () => void;\n\n  /**\n   * The disconnected callback.\n   *\n   * Called when the element's parent LiveView has disconnected from the server.\n   */\n  disconnected?: () => void;\n\n  /**\n   * The reconnected callback.\n   *\n   * Called when the element's parent LiveView has reconnected to the server.\n   */\n  reconnected?: () => void;\n\n  /**\n   * Returns an object with methods to manipluate the DOM and execute JavaScript.\n   * The applied changes integrate with server DOM patching.\n   */\n  js(): HookJSCommands;\n\n  /**\n   * Pushes an event to the server.\n   *\n   * @param event - The event name.\n   * @param [payload] - The payload to send to the server. Defaults to an empty object.\n   * @param [onReply] - A callback to handle the server's reply.\n   *\n   * When onReply is not provided, the method returns a Promise that\n   * When onReply is provided, the method returns void.\n   */\n  pushEvent(event: string, payload: any, onReply: OnReply): void;\n  pushEvent(event: string, payload?: any): Promise<any>;\n\n  /**\n   * Pushed a targeted event to the server.\n   *\n   * It sends the event to the LiveComponent or LiveView the `selectorOrTarget` is defined in,\n   * where its value can be either a query selector, an actual DOM element, or a CID (component id)\n   * returned by the `@myself` assign.\n   *\n   * If the query selector returns more than one element it will send the event to all of them,\n   * even if all the elements are in the same LiveComponent or LiveView. Because of this,\n   * if no callback is passed, a promise is returned that matches the return value of\n   * [`Promise.allSettled()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled#return_value).\n   * Individual fulfilled values are of the format `{ reply, ref }`, where `reply` is the server's reply.\n   *\n   * @param selectorOrTarget - The selector, element, or CID to target.\n   * @param event - The event name.\n   * @param [payload] - The payload to send to the server. Defaults to an empty object.\n   * @param [onReply] - A callback to handle the server's reply.\n   *\n   * When onReply is not provided, the method returns a Promise.\n   * When onReply is provided, the method returns void.\n   */\n  pushEventTo(\n    selectorOrTarget: PhxTarget,\n    event: string,\n    payload: object,\n    onReply: OnReply,\n  ): void;\n  pushEventTo(\n    selectorOrTarget: PhxTarget,\n    event: string,\n    payload?: object,\n  ): Promise<PromiseSettledResult<{ reply: any; ref: number }>[]>;\n\n  /**\n   * Allows to register a callback to be called when an event is received from the server.\n   *\n   * This is used to handle `pushEvent` calls from the server. The callback is called with the payload from the server.\n   *\n   * @param event - The event name.\n   * @param callback - The callback to call when the event is received.\n   *\n   * @returns A reference to the callback, which can be used in `removeHandleEvent` to remove the callback.\n   */\n  handleEvent(event: string, callback: (payload: any) => any): CallbackRef;\n\n  /**\n   * Removes a callback registered with `handleEvent`.\n   *\n   * @param callbackRef - The reference to the callback to remove.\n   */\n  removeHandleEvent(ref: CallbackRef): void;\n\n  /**\n   * Allows to trigger a live file upload.\n   *\n   * @param name - The upload name corresponding to the `Phoenix.LiveView.allow_upload/3` call.\n   * @param files - The files to upload.\n   */\n  upload(name: any, files: any): any;\n\n  /**\n   * Allows to trigger a live file upload to a specific target.\n   *\n   * @param selectorOrTarget - The target to upload the files to.\n   * @param name - The upload name corresponding to the `Phoenix.LiveView.allow_upload/3` call.\n   * @param files - The files to upload.\n   */\n  uploadTo(selectorOrTarget: PhxTarget, name: any, files: any): any;\n\n  // allow unknown methods, as people can define them in their hooks\n  [key: string]: any;\n}\n\n// based on https://github.com/DefinitelyTyped/DefinitelyTyped/blob/fac1aa75acdddbf4f1a95e98ee2297b54ce4b4c9/types/phoenix_live_view/hooks.d.ts#L26\n// licensed under MIT\nexport interface Hook<T = object> {\n  /**\n   * The mounted callback.\n   *\n   * Called when the element has been added to the DOM and its server LiveView has finished mounting.\n   */\n  mounted?: (this: T & HookInterface) => void;\n\n  /**\n   * The beforeUpdate callback.\n   *\n   * Called when the element is about to be updated in the DOM.\n   * Note: any call here must be synchronous as the operation cannot be deferred or cancelled.\n   */\n  beforeUpdate?: (this: T & HookInterface) => void;\n\n  /**\n   * The updated callback.\n   *\n   * Called when the element has been updated in the DOM by the server\n   */\n  updated?: (this: T & HookInterface) => void;\n\n  /**\n   * The destroyed callback.\n   *\n   * Called when the element has been removed from the page, either by a parent update, or by the parent being removed entirely\n   */\n  destroyed?: (this: T & HookInterface) => void;\n\n  /**\n   * The disconnected callback.\n   *\n   * Called when the element's parent LiveView has disconnected from the server.\n   */\n  disconnected?: (this: T & HookInterface) => void;\n\n  /**\n   * The reconnected callback.\n   *\n   * Called when the element's parent LiveView has reconnected to the server.\n   */\n  reconnected?: (this: T & HookInterface) => void;\n\n  // Allow custom methods with any signature and custom properties\n  [key: string]: ((this: T & HookInterface, ...args: any[]) => any) | any;\n}\n\n/**\n * Base class for LiveView hooks. Users extend this class to define their hooks.\n *\n * Example:\n * ```typescript\n * class MyCustomHook extends ViewHook {\n *   myState = \"initial\";\n *\n *   mounted() {\n *     console.log(\"Hook mounted on element:\", this.el);\n *     this.el.addEventListener(\"click\", () => {\n *       this.pushEvent(\"element-clicked\", { state: this.myState });\n *     });\n *   }\n *\n *   updated() {\n *     console.log(\"Hook updated\", this.el.id);\n *   }\n *\n *   myCustomMethod(someArg: string) {\n *     console.log(\"myCustomMethod called with:\", someArg, \"Current state:\", this.myState);\n *   }\n * }\n * ```\n *\n * The `this` context within the hook methods (mounted, updated, custom methods, etc.)\n * will refer to the hook instance, providing access to `this.el`, `this.liveSocket`,\n * `this.pushEvent()`, etc., as well as any properties or methods defined on the subclass.\n */\nexport class ViewHook implements HookInterface {\n  el: HTMLElement;\n  liveSocket: LiveSocket;\n\n  private __listeners: Set<CallbackRef>;\n  private __isDisconnected: boolean;\n  private __view: () => View;\n\n  static makeID() {\n    return viewHookID++;\n  }\n  static elementID(el: HTMLElement) {\n    return DOM.private(el, HOOK_ID);\n  }\n\n  constructor(view: View | null, el: HTMLElement, callbacks?: Hook) {\n    this.el = el;\n    this.__attachView(view);\n    this.__listeners = new Set();\n    this.__isDisconnected = false;\n    DOM.putPrivate(this.el, HOOK_ID, ViewHook.makeID());\n\n    if (callbacks) {\n      // This instance is for an object-literal hook. Copy methods/properties.\n      // These are properties that should NOT be overridden by the callbacks object.\n      const protectedProps = new Set([\n        \"el\",\n        \"liveSocket\",\n        \"__view\",\n        \"__listeners\",\n        \"__isDisconnected\",\n        \"constructor\", // Standard object properties\n        // Core ViewHook API methods\n        \"js\",\n        \"pushEvent\",\n        \"pushEventTo\",\n        \"handleEvent\",\n        \"removeHandleEvent\",\n        \"upload\",\n        \"uploadTo\",\n        // Internal lifecycle callers\n        \"__mounted\",\n        \"__updated\",\n        \"__beforeUpdate\",\n        \"__destroyed\",\n        \"__reconnected\",\n        \"__disconnected\",\n        \"__cleanup__\",\n      ]);\n\n      for (const key in callbacks) {\n        if (Object.prototype.hasOwnProperty.call(callbacks, key)) {\n          (this as any)[key] = callbacks[key];\n          // for backwards compatibility, we allow the overwrite, but we log a warning\n          if (protectedProps.has(key)) {\n            console.warn(\n              `Hook object for element #${el.id} overwrites core property '${key}'!`,\n            );\n          }\n        }\n      }\n\n      const lifecycleMethods: (keyof Hook)[] = [\n        \"mounted\",\n        \"beforeUpdate\",\n        \"updated\",\n        \"destroyed\",\n        \"disconnected\",\n        \"reconnected\",\n      ];\n      lifecycleMethods.forEach((methodName) => {\n        if (\n          callbacks[methodName] &&\n          typeof callbacks[methodName] === \"function\"\n        ) {\n          (this as any)[methodName] = callbacks[methodName];\n        }\n      });\n    }\n    // If 'callbacks' is not provided, this is an instance of a user-defined class (e.g., MyHook).\n    // Its methods (mounted, updated, custom) are already part of its prototype or instance,\n    // and will correctly override the defaults from ViewHook.prototype.\n  }\n\n  /** @internal */\n  __attachView(view: View | null) {\n    if (view) {\n      this.__view = () => view;\n      this.liveSocket = view.liveSocket;\n    } else {\n      this.__view = () => {\n        throw new Error(\n          `hook not yet attached to a live view: ${this.el.outerHTML}`,\n        );\n      };\n      this.liveSocket = null;\n    }\n  }\n\n  // Default lifecycle methods\n  mounted(): void {}\n  beforeUpdate(): void {}\n  updated(): void {}\n  destroyed(): void {}\n  disconnected(): void {}\n  reconnected(): void {}\n\n  // Internal lifecycle callers - called by the View\n\n  /** @internal */\n  __mounted() {\n    this.mounted();\n  }\n  /** @internal */\n  __updated() {\n    this.updated();\n  }\n  /** @internal */\n  __beforeUpdate() {\n    this.beforeUpdate();\n  }\n  /** @internal */\n  __destroyed() {\n    this.destroyed();\n    DOM.deletePrivate(this.el, HOOK_ID); // https://github.com/phoenixframework/phoenix_live_view/issues/3496\n  }\n  /** @internal */\n  __reconnected() {\n    if (this.__isDisconnected) {\n      this.__isDisconnected = false;\n      this.reconnected();\n    }\n  }\n  /** @internal */\n  __disconnected() {\n    this.__isDisconnected = true;\n    this.disconnected();\n  }\n\n  js(): HookJSCommands {\n    return {\n      ...jsCommands(this.__view().liveSocket, \"hook\"),\n      exec: (encodedJS: string) => {\n        this.__view().liveSocket.execJS(this.el, encodedJS, \"hook\");\n      },\n    };\n  }\n\n  pushEvent(event: string, payload?: any, onReply?: OnReply) {\n    const promise = this.__view().pushHookEvent(\n      this.el,\n      null,\n      event,\n      payload || {},\n    );\n    if (onReply === undefined) {\n      return promise.then(({ reply }) => reply);\n    }\n    promise.then(({ reply, ref }) => onReply(reply, ref)).catch(() => {});\n    return;\n  }\n\n  pushEventTo(\n    selectorOrTarget: PhxTarget,\n    event: string,\n    payload?: object,\n    onReply?: OnReply,\n  ) {\n    if (onReply === undefined) {\n      const targetPair: { view: View; targetCtx: any }[] = [];\n      this.__view().withinTargets(selectorOrTarget, (view, targetCtx) => {\n        targetPair.push({ view, targetCtx });\n      });\n      const promises = targetPair.map(({ view, targetCtx }) => {\n        return view.pushHookEvent(this.el, targetCtx, event, payload || {});\n      });\n      return Promise.allSettled(promises);\n    }\n    this.__view().withinTargets(selectorOrTarget, (view, targetCtx) => {\n      view\n        .pushHookEvent(this.el, targetCtx, event, payload || {})\n        .then(({ reply, ref }) => onReply(reply, ref))\n        .catch(() => {});\n    });\n    return;\n  }\n\n  handleEvent(event: string, callback: (payload: any) => any): CallbackRef {\n    const callbackRef: CallbackRef = {\n      event,\n      callback: (customEvent: CustomEvent) => callback(customEvent.detail),\n    };\n    window.addEventListener(\n      `phx:${event}`,\n      callbackRef.callback as EventListener,\n    );\n    this.__listeners.add(callbackRef);\n    return callbackRef;\n  }\n\n  removeHandleEvent(ref: CallbackRef): void {\n    window.removeEventListener(\n      `phx:${ref.event}`,\n      ref.callback as EventListener,\n    );\n    this.__listeners.delete(ref);\n  }\n\n  upload(name: string, files: FileList): any {\n    return this.__view().dispatchUploads(null, name, files);\n  }\n\n  uploadTo(selectorOrTarget: PhxTarget, name: string, files: FileList): any {\n    return this.__view().withinTargets(selectorOrTarget, (view, targetCtx) => {\n      view.dispatchUploads(targetCtx, name, files);\n    });\n  }\n\n  /** @internal */\n  __cleanup__() {\n    this.__listeners.forEach((callbackRef) =>\n      this.removeHandleEvent(callbackRef),\n    );\n  }\n}\n\nexport type HooksOptions = Record<string, typeof ViewHook | Hook>;\n\nexport default ViewHook;\n", "import {\n  BEFORE_UNLOAD_LOADER_TIMEOUT,\n  CHECKABLE_INPUTS,\n  CONSECUTIVE_RELOADS,\n  PHX_AUTO_RECOVER,\n  PHX_COMPONENT,\n  PHX_CONNECTED_CLASS,\n  PHX_DISABLE_WITH,\n  PHX_DISABLE_WITH_RESTORE,\n  PHX_DISABLED,\n  PHX_LOADING_CLASS,\n  PHX_ERROR_CLASS,\n  PHX_CLIENT_ERROR_CLASS,\n  PHX_SERVER_ERROR_CLASS,\n  PHX_HAS_FOCUSED,\n  PHX_HAS_SUBMITTED,\n  PHX_HOOK,\n  PHX_PARENT_ID,\n  PHX_PROGRESS,\n  PHX_READONLY,\n  PHX_REF_LOADING,\n  PHX_REF_SRC,\n  PHX_REF_LOCK,\n  PHX_ROOT_ID,\n  PHX_SESSION,\n  PHX_STATIC,\n  PHX_STICKY,\n  PHX_TRACK_STATIC,\n  PHX_TRACK_UPLOADS,\n  PHX_UPDATE,\n  PHX_UPLOAD_REF,\n  PHX_VIEW_SELECTOR,\n  PHX_MAIN,\n  PHX_MOUNTED,\n  PUSH_TIMEOUT,\n  PHX_VIEWPORT_TOP,\n  PHX_VIEWPORT_BOTTOM,\n  MAX_CHILD_JOIN_ATTEMPTS,\n  PHX_LV_PID,\n} from \"./constants\";\n\nimport {\n  clone,\n  closestPhxBinding,\n  isEmpty,\n  isEqualObj,\n  logError,\n  maybe,\n  isCid,\n} from \"./utils\";\n\nimport Browser from \"./browser\";\nimport DOM from \"./dom\";\nimport ElementRef from \"./element_ref\";\nimport DOMPatch from \"./dom_patch\";\nimport LiveUploader from \"./live_uploader\";\nimport Rendered from \"./rendered\";\nimport { ViewHook } from \"./view_hook\";\nimport JS from \"./js\";\n\nimport morphdom from \"morphdom\";\n\nexport const prependFormDataKey = (key, prefix) => {\n  const isArray = key.endsWith(\"[]\");\n  // Remove the \"[]\" if it's an array\n  let baseKey = isArray ? key.slice(0, -2) : key;\n  // Replace last occurrence of key before a closing bracket or the end with key plus suffix\n  baseKey = baseKey.replace(/([^\\[\\]]+)(\\]?$)/, `${prefix}$1$2`);\n  // Add back the \"[]\" if it was an array\n  if (isArray) {\n    baseKey += \"[]\";\n  }\n  return baseKey;\n};\n\nconst serializeForm = (form, opts, onlyNames = []) => {\n  const { submitter } = opts;\n\n  // We must inject the submitter in the order that it exists in the DOM\n  // relative to other inputs. For example, for checkbox groups, the order must be maintained.\n  let injectedElement;\n  if (submitter && submitter.name) {\n    const input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    // set the form attribute if the submitter has one;\n    // this can happen if the element is outside the actual form element\n    const formId = submitter.getAttribute(\"form\");\n    if (formId) {\n      input.setAttribute(\"form\", formId);\n    }\n    input.name = submitter.name;\n    input.value = submitter.value;\n    submitter.parentElement.insertBefore(input, submitter);\n    injectedElement = input;\n  }\n\n  const formData = new FormData(form);\n  const toRemove = [];\n\n  formData.forEach((val, key, _index) => {\n    if (val instanceof File) {\n      toRemove.push(key);\n    }\n  });\n\n  // Cleanup after building fileData\n  toRemove.forEach((key) => formData.delete(key));\n\n  const params = new URLSearchParams();\n\n  const { inputsUnused, onlyHiddenInputs } = Array.from(form.elements).reduce(\n    (acc, input) => {\n      const { inputsUnused, onlyHiddenInputs } = acc;\n      const key = input.name;\n      if (!key) {\n        return acc;\n      }\n\n      if (inputsUnused[key] === undefined) {\n        inputsUnused[key] = true;\n      }\n      if (onlyHiddenInputs[key] === undefined) {\n        onlyHiddenInputs[key] = true;\n      }\n\n      const isUsed =\n        DOM.private(input, PHX_HAS_FOCUSED) ||\n        DOM.private(input, PHX_HAS_SUBMITTED);\n      const isHidden = input.type === \"hidden\";\n      inputsUnused[key] = inputsUnused[key] && !isUsed;\n      onlyHiddenInputs[key] = onlyHiddenInputs[key] && isHidden;\n\n      return acc;\n    },\n    { inputsUnused: {}, onlyHiddenInputs: {} },\n  );\n\n  for (const [key, val] of formData.entries()) {\n    if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {\n      const isUnused = inputsUnused[key];\n      const hidden = onlyHiddenInputs[key];\n      if (isUnused && !(submitter && submitter.name == key) && !hidden) {\n        params.append(prependFormDataKey(key, \"_unused_\"), \"\");\n      }\n      if (typeof val === \"string\") {\n        params.append(key, val);\n      }\n    }\n  }\n\n  // remove the injected element again\n  // (it would be removed by the next dom patch anyway, but this is cleaner)\n  if (submitter && injectedElement) {\n    submitter.parentElement.removeChild(injectedElement);\n  }\n\n  return params.toString();\n};\n\nexport default class View {\n  static closestView(el) {\n    const liveViewEl = el.closest(PHX_VIEW_SELECTOR);\n    return liveViewEl ? DOM.private(liveViewEl, \"view\") : null;\n  }\n\n  constructor(el, liveSocket, parentView, flash, liveReferer) {\n    this.isDead = false;\n    this.liveSocket = liveSocket;\n    this.flash = flash;\n    this.parent = parentView;\n    this.root = parentView ? parentView.root : this;\n    this.el = el;\n    // see https://github.com/phoenixframework/phoenix_live_view/pull/3721\n    // check if the element is already bound to a view\n    const boundView = DOM.private(this.el, \"view\");\n    if (boundView !== undefined && boundView.isDead !== true) {\n      logError(\n        `The DOM element for this view has already been bound to a view.\n\n        An element can only ever be associated with a single view!\n        Please ensure that you are not trying to initialize multiple LiveSockets on the same page.\n        This could happen if you're accidentally trying to render your root layout more than once.\n        Ensure that the template set on the LiveView is different than the root layout.\n      `,\n        { view: boundView },\n      );\n      throw new Error(\"Cannot bind multiple views to the same DOM element.\");\n    }\n    // bind the view to the element\n    DOM.putPrivate(this.el, \"view\", this);\n    this.id = this.el.id;\n    this.ref = 0;\n    this.lastAckRef = null;\n    this.childJoins = 0;\n    this.loaderTimer = null;\n    this.disconnectedTimer = null;\n    this.pendingDiffs = [];\n    this.pendingForms = new Set();\n    this.redirect = false;\n    this.href = null;\n    this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;\n    this.joinAttempts = 0;\n    this.joinPending = true;\n    this.destroyed = false;\n    this.joinCallback = function (onDone) {\n      onDone && onDone();\n    };\n    this.stopCallback = function () {};\n    this.pendingJoinOps = this.parent ? null : [];\n    this.viewHooks = {};\n    this.formSubmits = [];\n    this.children = this.parent ? null : {};\n    this.root.children[this.id] = {};\n    this.formsForRecovery = {};\n    this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {\n      const url = this.href && this.expandURL(this.href);\n      return {\n        redirect: this.redirect ? url : undefined,\n        url: this.redirect ? undefined : url || undefined,\n        params: this.connectParams(liveReferer),\n        session: this.getSession(),\n        static: this.getStatic(),\n        flash: this.flash,\n        sticky: this.el.hasAttribute(PHX_STICKY),\n      };\n    });\n    this.portalElementIds = new Set();\n  }\n\n  setHref(href) {\n    this.href = href;\n  }\n\n  setRedirect(href) {\n    this.redirect = true;\n    this.href = href;\n  }\n\n  isMain() {\n    return this.el.hasAttribute(PHX_MAIN);\n  }\n\n  connectParams(liveReferer) {\n    const params = this.liveSocket.params(this.el);\n    const manifest = DOM.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`)\n      .map((node) => node.src || node.href)\n      .filter((url) => typeof url === \"string\");\n\n    if (manifest.length > 0) {\n      params[\"_track_static\"] = manifest;\n    }\n    params[\"_mounts\"] = this.joinCount;\n    params[\"_mount_attempts\"] = this.joinAttempts;\n    params[\"_live_referer\"] = liveReferer;\n    this.joinAttempts++;\n\n    return params;\n  }\n\n  isConnected() {\n    return this.channel.canPush();\n  }\n\n  getSession() {\n    return this.el.getAttribute(PHX_SESSION);\n  }\n\n  getStatic() {\n    const val = this.el.getAttribute(PHX_STATIC);\n    return val === \"\" ? null : val;\n  }\n\n  destroy(callback = function () {}) {\n    this.destroyAllChildren();\n    this.destroyPortalElements();\n    this.destroyed = true;\n    DOM.deletePrivate(this.el, \"view\");\n    delete this.root.children[this.id];\n    if (this.parent) {\n      delete this.root.children[this.parent.id][this.id];\n    }\n    clearTimeout(this.loaderTimer);\n    const onFinished = () => {\n      callback();\n      for (const id in this.viewHooks) {\n        this.destroyHook(this.viewHooks[id]);\n      }\n    };\n\n    DOM.markPhxChildDestroyed(this.el);\n\n    this.log(\"destroyed\", () => [\"the child has been removed from the parent\"]);\n    this.channel\n      .leave()\n      .receive(\"ok\", onFinished)\n      .receive(\"error\", onFinished)\n      .receive(\"timeout\", onFinished);\n  }\n\n  setContainerClasses(...classes) {\n    this.el.classList.remove(\n      PHX_CONNECTED_CLASS,\n      PHX_LOADING_CLASS,\n      PHX_ERROR_CLASS,\n      PHX_CLIENT_ERROR_CLASS,\n      PHX_SERVER_ERROR_CLASS,\n    );\n    this.el.classList.add(...classes);\n  }\n\n  showLoader(timeout) {\n    clearTimeout(this.loaderTimer);\n    if (timeout) {\n      this.loaderTimer = setTimeout(() => this.showLoader(), timeout);\n    } else {\n      for (const id in this.viewHooks) {\n        this.viewHooks[id].__disconnected();\n      }\n      this.setContainerClasses(PHX_LOADING_CLASS);\n    }\n  }\n\n  execAll(binding) {\n    DOM.all(this.el, `[${binding}]`, (el) =>\n      this.liveSocket.execJS(el, el.getAttribute(binding)),\n    );\n  }\n\n  hideLoader() {\n    clearTimeout(this.loaderTimer);\n    clearTimeout(this.disconnectedTimer);\n    this.setContainerClasses(PHX_CONNECTED_CLASS);\n    this.execAll(this.binding(\"connected\"));\n  }\n\n  triggerReconnected() {\n    for (const id in this.viewHooks) {\n      this.viewHooks[id].__reconnected();\n    }\n  }\n\n  log(kind, msgCallback) {\n    this.liveSocket.log(this, kind, msgCallback);\n  }\n\n  transition(time, onStart, onDone = function () {}) {\n    this.liveSocket.transition(time, onStart, onDone);\n  }\n\n  // calls the callback with the view and target element for the given phxTarget\n  // targets can be:\n  //  * an element itself, then it is simply passed to liveSocket.owner;\n  //  * a CID (Component ID), then we first search the component's element in the DOM\n  //  * a selector, then we search the selector in the DOM and call the callback\n  //    for each element found with the corresponding owner view\n  withinTargets(phxTarget, callback, dom = document) {\n    // in the form recovery case we search in a template fragment instead of\n    // the real dom, therefore we optionally pass dom and viewEl\n\n    if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {\n      return this.liveSocket.owner(phxTarget, (view) =>\n        callback(view, phxTarget),\n      );\n    }\n\n    if (isCid(phxTarget)) {\n      const targets = DOM.findComponentNodeList(this.id, phxTarget, dom);\n      if (targets.length === 0) {\n        logError(`no component found matching phx-target of ${phxTarget}`);\n      } else {\n        callback(this, parseInt(phxTarget));\n      }\n    } else {\n      const targets = Array.from(dom.querySelectorAll(phxTarget));\n      if (targets.length === 0) {\n        logError(\n          `nothing found matching the phx-target selector \"${phxTarget}\"`,\n        );\n      }\n      targets.forEach((target) =>\n        this.liveSocket.owner(target, (view) => callback(view, target)),\n      );\n    }\n  }\n\n  applyDiff(type, rawDiff, callback) {\n    this.log(type, () => [\"\", clone(rawDiff)]);\n    const { diff, reply, events, title } = Rendered.extract(rawDiff);\n    callback({ diff, reply, events });\n    if (typeof title === \"string\" || type == \"mount\") {\n      window.requestAnimationFrame(() => DOM.putTitle(title));\n    }\n  }\n\n  onJoin(resp) {\n    const { rendered, container, liveview_version, pid } = resp;\n    if (container) {\n      const [tag, attrs] = container;\n      this.el = DOM.replaceRootContainer(this.el, tag, attrs);\n    }\n    this.childJoins = 0;\n    this.joinPending = true;\n    this.flash = null;\n    if (this.root === this) {\n      this.formsForRecovery = this.getFormsForRecovery();\n    }\n    if (this.isMain() && window.history.state === null) {\n      // set initial history entry if this is the first page load (no history)\n      Browser.pushState(\"replace\", {\n        type: \"patch\",\n        id: this.id,\n        position: this.liveSocket.currentHistoryPosition,\n      });\n    }\n\n    if (liveview_version !== this.liveSocket.version()) {\n      console.error(\n        `LiveView asset version mismatch. JavaScript version ${this.liveSocket.version()} vs. server ${liveview_version}. To avoid issues, please ensure that your assets use the same version as the server.`,\n      );\n    }\n\n    // The pid is only sent if\n    //\n    //    config :phoenix_live_view, :debug_attributes\n    //\n    // if set to true. It is to help debugging in development.\n    if (pid) {\n      this.el.setAttribute(PHX_LV_PID, pid);\n    }\n\n    Browser.dropLocal(\n      this.liveSocket.localStorage,\n      window.location.pathname,\n      CONSECUTIVE_RELOADS,\n    );\n    this.applyDiff(\"mount\", rendered, ({ diff, events }) => {\n      this.rendered = new Rendered(this.id, diff);\n      const [html, streams] = this.renderContainer(null, \"join\");\n      this.dropPendingRefs();\n      this.joinCount++;\n      this.joinAttempts = 0;\n\n      this.maybeRecoverForms(html, () => {\n        this.onJoinComplete(resp, html, streams, events);\n      });\n    });\n  }\n\n  dropPendingRefs() {\n    DOM.all(document, `[${PHX_REF_SRC}=\"${this.refSrc()}\"]`, (el) => {\n      el.removeAttribute(PHX_REF_LOADING);\n      el.removeAttribute(PHX_REF_SRC);\n      el.removeAttribute(PHX_REF_LOCK);\n    });\n  }\n\n  onJoinComplete({ live_patch }, html, streams, events) {\n    // In order to provide a better experience, we want to join\n    // all LiveViews first and only then apply their patches.\n    if (this.joinCount > 1 || (this.parent && !this.parent.isJoinPending())) {\n      return this.applyJoinPatch(live_patch, html, streams, events);\n    }\n\n    // One downside of this approach is that we need to find phxChildren\n    // in the html fragment, instead of directly on the DOM. The fragment\n    // also does not include PHX_STATIC, so we need to copy it over from\n    // the DOM.\n    const newChildren = DOM.findPhxChildrenInFragment(html, this.id).filter(\n      (toEl) => {\n        const fromEl = toEl.id && this.el.querySelector(`[id=\"${toEl.id}\"]`);\n        const phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);\n        if (phxStatic) {\n          toEl.setAttribute(PHX_STATIC, phxStatic);\n        }\n        // set PHX_ROOT_ID to prevent events from being dispatched to the root view\n        // while the child join is still pending\n        if (fromEl) {\n          fromEl.setAttribute(PHX_ROOT_ID, this.root.id);\n        }\n        return this.joinChild(toEl);\n      },\n    );\n\n    if (newChildren.length === 0) {\n      if (this.parent) {\n        this.root.pendingJoinOps.push([\n          this,\n          () => this.applyJoinPatch(live_patch, html, streams, events),\n        ]);\n        this.parent.ackJoin(this);\n      } else {\n        this.onAllChildJoinsComplete();\n        this.applyJoinPatch(live_patch, html, streams, events);\n      }\n    } else {\n      this.root.pendingJoinOps.push([\n        this,\n        () => this.applyJoinPatch(live_patch, html, streams, events),\n      ]);\n    }\n  }\n\n  attachTrueDocEl() {\n    this.el = DOM.byId(this.id);\n    this.el.setAttribute(PHX_ROOT_ID, this.root.id);\n  }\n\n  // this is invoked for dead and live views, so we must filter by\n  // by owner to ensure we aren't duplicating hooks across disconnect\n  // and connected states. This also handles cases where hooks exist\n  // in a root layout with a LV in the body\n  execNewMounted(parent = document) {\n    let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);\n    let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);\n    this.all(\n      parent,\n      `[${phxViewportTop}], [${phxViewportBottom}]`,\n      (hookEl) => {\n        DOM.maintainPrivateHooks(\n          hookEl,\n          hookEl,\n          phxViewportTop,\n          phxViewportBottom,\n        );\n        this.maybeAddNewHook(hookEl);\n      },\n    );\n    this.all(\n      parent,\n      `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`,\n      (hookEl) => {\n        this.maybeAddNewHook(hookEl);\n      },\n    );\n    this.all(parent, `[${this.binding(PHX_MOUNTED)}]`, (el) => {\n      this.maybeMounted(el);\n    });\n  }\n\n  all(parent, selector, callback) {\n    DOM.all(parent, selector, (el) => {\n      if (this.ownsElement(el)) {\n        callback(el);\n      }\n    });\n  }\n\n  applyJoinPatch(live_patch, html, streams, events) {\n    this.attachTrueDocEl();\n    const patch = new DOMPatch(this, this.el, this.id, html, streams, null);\n    patch.markPrunableContentForRemoval();\n    this.performPatch(patch, false, true);\n    this.joinNewChildren();\n    this.execNewMounted();\n\n    this.joinPending = false;\n    this.liveSocket.dispatchEvents(events);\n    this.applyPendingUpdates();\n\n    if (live_patch) {\n      const { kind, to } = live_patch;\n      this.liveSocket.historyPatch(to, kind);\n    }\n    this.hideLoader();\n    if (this.joinCount > 1) {\n      this.triggerReconnected();\n    }\n    this.stopCallback();\n  }\n\n  triggerBeforeUpdateHook(fromEl, toEl) {\n    this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [fromEl, toEl]);\n    const hook = this.getHook(fromEl);\n    const isIgnored = hook && DOM.isIgnored(fromEl, this.binding(PHX_UPDATE));\n    if (\n      hook &&\n      !fromEl.isEqualNode(toEl) &&\n      !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))\n    ) {\n      hook.__beforeUpdate();\n      return hook;\n    }\n  }\n\n  maybeMounted(el) {\n    const phxMounted = el.getAttribute(this.binding(PHX_MOUNTED));\n    const hasBeenInvoked = phxMounted && DOM.private(el, \"mounted\");\n    if (phxMounted && !hasBeenInvoked) {\n      this.liveSocket.execJS(el, phxMounted);\n      DOM.putPrivate(el, \"mounted\", true);\n    }\n  }\n\n  maybeAddNewHook(el) {\n    const newHook = this.addHook(el);\n    if (newHook) {\n      newHook.__mounted();\n    }\n  }\n\n  performPatch(patch, pruneCids, isJoinPatch = false) {\n    const removedEls = [];\n    let phxChildrenAdded = false;\n    const updatedHookIds = new Set();\n\n    this.liveSocket.triggerDOM(\"onPatchStart\", [patch.targetContainer]);\n\n    patch.after(\"added\", (el) => {\n      this.liveSocket.triggerDOM(\"onNodeAdded\", [el]);\n      const phxViewportTop = this.binding(PHX_VIEWPORT_TOP);\n      const phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);\n      DOM.maintainPrivateHooks(el, el, phxViewportTop, phxViewportBottom);\n      this.maybeAddNewHook(el);\n      if (el.getAttribute) {\n        this.maybeMounted(el);\n      }\n    });\n\n    patch.after(\"phxChildAdded\", (el) => {\n      if (DOM.isPhxSticky(el)) {\n        this.liveSocket.joinRootViews();\n      } else {\n        phxChildrenAdded = true;\n      }\n    });\n\n    patch.before(\"updated\", (fromEl, toEl) => {\n      const hook = this.triggerBeforeUpdateHook(fromEl, toEl);\n      if (hook) {\n        updatedHookIds.add(fromEl.id);\n      }\n      // trigger JS specific update logic (for example for JS.ignore_attributes)\n      JS.onBeforeElUpdated(fromEl, toEl);\n    });\n\n    patch.after(\"updated\", (el) => {\n      if (updatedHookIds.has(el.id)) {\n        this.getHook(el).__updated();\n      }\n    });\n\n    patch.after(\"discarded\", (el) => {\n      if (el.nodeType === Node.ELEMENT_NODE) {\n        removedEls.push(el);\n      }\n    });\n\n    patch.after(\"transitionsDiscarded\", (els) =>\n      this.afterElementsRemoved(els, pruneCids),\n    );\n    patch.perform(isJoinPatch);\n    this.afterElementsRemoved(removedEls, pruneCids);\n\n    this.liveSocket.triggerDOM(\"onPatchEnd\", [patch.targetContainer]);\n    return phxChildrenAdded;\n  }\n\n  afterElementsRemoved(elements, pruneCids) {\n    const destroyedCIDs = [];\n    elements.forEach((parent) => {\n      const components = DOM.all(parent, `[${PHX_COMPONENT}]`);\n      const hooks = DOM.all(\n        parent,\n        `[${this.binding(PHX_HOOK)}], [data-phx-hook]`,\n      );\n      components.concat(parent).forEach((el) => {\n        const cid = this.componentID(el);\n        if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {\n          destroyedCIDs.push(cid);\n        }\n      });\n      hooks.concat(parent).forEach((hookEl) => {\n        const hook = this.getHook(hookEl);\n        hook && this.destroyHook(hook);\n      });\n    });\n    // We should not pruneCids on joins. Otherwise, in case of\n    // rejoins, we may notify cids that no longer belong to the\n    // current LiveView to be removed.\n    if (pruneCids) {\n      this.maybePushComponentsDestroyed(destroyedCIDs);\n    }\n  }\n\n  joinNewChildren() {\n    DOM.findPhxChildren(document, this.id).forEach((el) => this.joinChild(el));\n  }\n\n  maybeRecoverForms(html, callback) {\n    const phxChange = this.binding(\"change\");\n    const oldForms = this.root.formsForRecovery;\n    // So why do we create a template element here?\n    // One way to recover forms would be to immediately apply the mount\n    // patch and then afterwards recover the forms. However, this would\n    // cause a flicker, because the mount patch would remove the form content\n    // until it is restored. Therefore LV decided to do form recovery with the\n    // raw HTML before it is applied and delay the mount patch until the form\n    // recovery events are done.\n    const template = document.createElement(\"template\");\n    template.innerHTML = html;\n    // because we work with a template element, we must manually copy the attributes\n    // otherwise the owner / target helpers don't work properly\n    const rootEl = template.content.firstElementChild;\n    rootEl.id = this.id;\n    rootEl.setAttribute(PHX_ROOT_ID, this.root.id);\n    rootEl.setAttribute(PHX_SESSION, this.getSession());\n    rootEl.setAttribute(PHX_STATIC, this.getStatic());\n    rootEl.setAttribute(PHX_PARENT_ID, this.parent ? this.parent.id : null);\n\n    // we go over all form elements in the new HTML for the LV\n    // and look for old forms in the `formsForRecovery` object;\n    // the formsForRecovery can also contain forms from child views\n    const formsToRecover =\n      // we go over all forms in the new DOM; because this is only the HTML for the current\n      // view, we can be sure that all forms are owned by this view:\n      DOM.all(template.content, \"form\")\n        // only recover forms that have an id and are in the old DOM\n        .filter((newForm) => newForm.id && oldForms[newForm.id])\n        // abandon forms we already tried to recover to prevent looping a failed state\n        .filter((newForm) => !this.pendingForms.has(newForm.id))\n        // only recover if the form has the same phx-change value\n        .filter(\n          (newForm) =>\n            oldForms[newForm.id].getAttribute(phxChange) ===\n            newForm.getAttribute(phxChange),\n        )\n        .map((newForm) => {\n          return [oldForms[newForm.id], newForm];\n        });\n\n    if (formsToRecover.length === 0) {\n      return callback();\n    }\n\n    formsToRecover.forEach(([oldForm, newForm], i) => {\n      this.pendingForms.add(newForm.id);\n      // it is important to use the firstElementChild of the template content\n      // because when traversing a documentFragment using parentNode, we won't ever arrive at\n      // the fragment; as the template is always a LiveView, we can be sure that there is only\n      // one child on the root level\n      this.pushFormRecovery(\n        oldForm,\n        newForm,\n        template.content.firstElementChild,\n        () => {\n          this.pendingForms.delete(newForm.id);\n          // we only call the callback once all forms have been recovered\n          if (i === formsToRecover.length - 1) {\n            callback();\n          }\n        },\n      );\n    });\n  }\n\n  getChildById(id) {\n    return this.root.children[this.id][id];\n  }\n\n  getDescendentByEl(el) {\n    if (el.id === this.id) {\n      return this;\n    } else {\n      return this.children[el.getAttribute(PHX_PARENT_ID)]?.[el.id];\n    }\n  }\n\n  destroyDescendent(id) {\n    for (const parentId in this.root.children) {\n      for (const childId in this.root.children[parentId]) {\n        if (childId === id) {\n          return this.root.children[parentId][childId].destroy();\n        }\n      }\n    }\n  }\n\n  joinChild(el) {\n    const child = this.getChildById(el.id);\n    if (!child) {\n      const view = new View(el, this.liveSocket, this);\n      this.root.children[this.id][view.id] = view;\n      view.join();\n      this.childJoins++;\n      return true;\n    }\n  }\n\n  isJoinPending() {\n    return this.joinPending;\n  }\n\n  ackJoin(_child) {\n    this.childJoins--;\n\n    if (this.childJoins === 0) {\n      if (this.parent) {\n        this.parent.ackJoin(this);\n      } else {\n        this.onAllChildJoinsComplete();\n      }\n    }\n  }\n\n  onAllChildJoinsComplete() {\n    // we can clear pending form recoveries now that we've joined.\n    // They either all resolved or were abandoned\n    this.pendingForms.clear();\n    // we can also clear the formsForRecovery object to not keep old form elements around\n    this.formsForRecovery = {};\n    this.joinCallback(() => {\n      this.pendingJoinOps.forEach(([view, op]) => {\n        if (!view.isDestroyed()) {\n          op();\n        }\n      });\n      this.pendingJoinOps = [];\n    });\n  }\n\n  update(diff, events) {\n    if (\n      this.isJoinPending() ||\n      (this.liveSocket.hasPendingLink() && this.root.isMain())\n    ) {\n      return this.pendingDiffs.push({ diff, events });\n    }\n\n    this.rendered.mergeDiff(diff);\n    let phxChildrenAdded = false;\n\n    // When the diff only contains component diffs, then walk components\n    // and patch only the parent component containers found in the diff.\n    // Otherwise, patch entire LV container.\n    if (this.rendered.isComponentOnlyDiff(diff)) {\n      this.liveSocket.time(\"component patch complete\", () => {\n        const parentCids = DOM.findExistingParentCIDs(\n          this.id,\n          this.rendered.componentCIDs(diff),\n        );\n        parentCids.forEach((parentCID) => {\n          if (\n            this.componentPatch(\n              this.rendered.getComponent(diff, parentCID),\n              parentCID,\n            )\n          ) {\n            phxChildrenAdded = true;\n          }\n        });\n      });\n    } else if (!isEmpty(diff)) {\n      this.liveSocket.time(\"full patch complete\", () => {\n        const [html, streams] = this.renderContainer(diff, \"update\");\n        const patch = new DOMPatch(this, this.el, this.id, html, streams, null);\n        phxChildrenAdded = this.performPatch(patch, true);\n      });\n    }\n\n    this.liveSocket.dispatchEvents(events);\n    if (phxChildrenAdded) {\n      this.joinNewChildren();\n    }\n  }\n\n  renderContainer(diff, kind) {\n    return this.liveSocket.time(`toString diff (${kind})`, () => {\n      const tag = this.el.tagName;\n      // Don't skip any component in the diff nor any marked as pruned\n      // (as they may have been added back)\n      const cids = diff ? this.rendered.componentCIDs(diff) : null;\n      const { buffer: html, streams } = this.rendered.toString(cids);\n      return [`<${tag}>${html}</${tag}>`, streams];\n    });\n  }\n\n  componentPatch(diff, cid) {\n    if (isEmpty(diff)) return false;\n    const { buffer: html, streams } = this.rendered.componentToString(cid);\n    const patch = new DOMPatch(this, this.el, this.id, html, streams, cid);\n    const childrenAdded = this.performPatch(patch, true);\n    return childrenAdded;\n  }\n\n  getHook(el) {\n    return this.viewHooks[ViewHook.elementID(el)];\n  }\n\n  addHook(el) {\n    const hookElId = ViewHook.elementID(el);\n\n    // only ever try to add hooks to elements owned by this view\n    if (el.getAttribute && !this.ownsElement(el)) {\n      return;\n    }\n\n    if (hookElId && !this.viewHooks[hookElId]) {\n      // hook created, but not attached (createHook for web component)\n      const hook =\n        DOM.getCustomElHook(el) ||\n        logError(`no hook found for custom element: ${el.id}`);\n      this.viewHooks[hookElId] = hook;\n      hook.__attachView(this);\n      return hook;\n    } else if (hookElId || !el.getAttribute) {\n      // no hook found\n      return;\n    } else {\n      // new hook found with phx-hook attribute\n      const hookName =\n        el.getAttribute(`data-phx-${PHX_HOOK}`) ||\n        el.getAttribute(this.binding(PHX_HOOK));\n\n      if (!hookName) {\n        return;\n      }\n\n      const hookDefinition = this.liveSocket.getHookDefinition(hookName);\n\n      if (hookDefinition) {\n        if (!el.id) {\n          logError(\n            `no DOM ID for hook \"${hookName}\". Hooks require a unique ID on each element.`,\n            el,\n          );\n          return;\n        }\n\n        let hookInstance;\n        try {\n          if (\n            typeof hookDefinition === \"function\" &&\n            hookDefinition.prototype instanceof ViewHook\n          ) {\n            // It's a class constructor (subclass of ViewHook)\n            hookInstance = new hookDefinition(this, el); // `this` is the View instance\n          } else if (\n            typeof hookDefinition === \"object\" &&\n            hookDefinition !== null\n          ) {\n            // It's an object literal, pass it to the ViewHook constructor for wrapping\n            hookInstance = new ViewHook(this, el, hookDefinition);\n          } else {\n            logError(\n              `Invalid hook definition for \"${hookName}\". Expected a class extending ViewHook or an object definition.`,\n              el,\n            );\n            return;\n          }\n        } catch (e) {\n          const errorMessage = e instanceof Error ? e.message : String(e);\n          logError(`Failed to create hook \"${hookName}\": ${errorMessage}`, el);\n          return;\n        }\n\n        this.viewHooks[ViewHook.elementID(hookInstance.el)] = hookInstance;\n        return hookInstance;\n      } else if (hookName !== null) {\n        logError(`unknown hook found for \"${hookName}\"`, el);\n      }\n    }\n  }\n\n  destroyHook(hook) {\n    // __destroyed clears the elementID from the hook, therefore\n    // we need to get it before calling __destroyed\n    const hookId = ViewHook.elementID(hook.el);\n    hook.__destroyed();\n    hook.__cleanup__();\n    delete this.viewHooks[hookId];\n  }\n\n  applyPendingUpdates() {\n    // prevent race conditions where we might still be pending a new\n    // navigation after applying the current one;\n    // if we call update and a pendingDiff is not applied, it would\n    // be silently dropped otherwise, as update would push it back to\n    // pendingDiffs, but we clear it immediately after\n    if (this.liveSocket.hasPendingLink() && this.root.isMain()) {\n      return;\n    }\n    this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));\n    this.pendingDiffs = [];\n    this.eachChild((child) => child.applyPendingUpdates());\n  }\n\n  eachChild(callback) {\n    const children = this.root.children[this.id] || {};\n    for (const id in children) {\n      callback(this.getChildById(id));\n    }\n  }\n\n  onChannel(event, cb) {\n    this.liveSocket.onChannel(this.channel, event, (resp) => {\n      if (this.isJoinPending()) {\n        this.root.pendingJoinOps.push([this, () => cb(resp)]);\n      } else {\n        this.liveSocket.requestDOMUpdate(() => cb(resp));\n      }\n    });\n  }\n\n  bindChannel() {\n    // The diff event should be handled by the regular update operations.\n    // All other operations are queued to be applied only after join.\n    this.liveSocket.onChannel(this.channel, \"diff\", (rawDiff) => {\n      this.liveSocket.requestDOMUpdate(() => {\n        this.applyDiff(\"update\", rawDiff, ({ diff, events }) =>\n          this.update(diff, events),\n        );\n      });\n    });\n    this.onChannel(\"redirect\", ({ to, flash }) =>\n      this.onRedirect({ to, flash }),\n    );\n    this.onChannel(\"live_patch\", (redir) => this.onLivePatch(redir));\n    this.onChannel(\"live_redirect\", (redir) => this.onLiveRedirect(redir));\n    this.channel.onError((reason) => this.onError(reason));\n    this.channel.onClose((reason) => this.onClose(reason));\n  }\n\n  destroyAllChildren() {\n    this.eachChild((child) => child.destroy());\n  }\n\n  onLiveRedirect(redir) {\n    const { to, kind, flash } = redir;\n    const url = this.expandURL(to);\n    const e = new CustomEvent(\"phx:server-navigate\", {\n      detail: { to, kind, flash },\n    });\n    this.liveSocket.historyRedirect(e, url, kind, flash);\n  }\n\n  onLivePatch(redir) {\n    const { to, kind } = redir;\n    this.href = this.expandURL(to);\n    this.liveSocket.historyPatch(to, kind);\n  }\n\n  expandURL(to) {\n    return to.startsWith(\"/\")\n      ? `${window.location.protocol}//${window.location.host}${to}`\n      : to;\n  }\n\n  /**\n   * @param {{to: string, flash?: string, reloadToken?: string}} redirect\n   */\n  onRedirect({ to, flash, reloadToken }) {\n    this.liveSocket.redirect(to, flash, reloadToken);\n  }\n\n  isDestroyed() {\n    return this.destroyed;\n  }\n\n  joinDead() {\n    this.isDead = true;\n  }\n\n  joinPush() {\n    this.joinPush = this.joinPush || this.channel.join();\n    return this.joinPush;\n  }\n\n  join(callback) {\n    this.showLoader(this.liveSocket.loaderTimeout);\n    this.bindChannel();\n    if (this.isMain()) {\n      this.stopCallback = this.liveSocket.withPageLoading({\n        to: this.href,\n        kind: \"initial\",\n      });\n    }\n    this.joinCallback = (onDone) => {\n      onDone = onDone || function () {};\n      callback ? callback(this.joinCount, onDone) : onDone();\n    };\n\n    this.wrapPush(() => this.channel.join(), {\n      ok: (resp) => this.liveSocket.requestDOMUpdate(() => this.onJoin(resp)),\n      error: (error) => this.onJoinError(error),\n      timeout: () => this.onJoinError({ reason: \"timeout\" }),\n    });\n  }\n\n  onJoinError(resp) {\n    if (resp.reason === \"reload\") {\n      this.log(\"error\", () => [\n        `failed mount with ${resp.status}. Falling back to page reload`,\n        resp,\n      ]);\n      this.onRedirect({ to: this.root.href, reloadToken: resp.token });\n      return;\n    } else if (resp.reason === \"unauthorized\" || resp.reason === \"stale\") {\n      this.log(\"error\", () => [\n        \"unauthorized live_redirect. Falling back to page request\",\n        resp,\n      ]);\n      this.onRedirect({ to: this.root.href, flash: this.flash });\n      return;\n    }\n    if (resp.redirect || resp.live_redirect) {\n      this.joinPending = false;\n      this.channel.leave();\n    }\n    if (resp.redirect) {\n      return this.onRedirect(resp.redirect);\n    }\n    if (resp.live_redirect) {\n      return this.onLiveRedirect(resp.live_redirect);\n    }\n    this.log(\"error\", () => [\"unable to join\", resp]);\n    if (this.isMain()) {\n      this.displayError([\n        PHX_LOADING_CLASS,\n        PHX_ERROR_CLASS,\n        PHX_SERVER_ERROR_CLASS,\n      ]);\n      if (this.liveSocket.isConnected()) {\n        this.liveSocket.reloadWithJitter(this);\n      }\n    } else {\n      if (this.joinAttempts >= MAX_CHILD_JOIN_ATTEMPTS) {\n        // put the root review into permanent error state, but don't destroy it as it can remain active\n        this.root.displayError([\n          PHX_LOADING_CLASS,\n          PHX_ERROR_CLASS,\n          PHX_SERVER_ERROR_CLASS,\n        ]);\n        this.log(\"error\", () => [\n          `giving up trying to mount after ${MAX_CHILD_JOIN_ATTEMPTS} tries`,\n          resp,\n        ]);\n        this.destroy();\n      }\n      const trueChildEl = DOM.byId(this.el.id);\n      if (trueChildEl) {\n        DOM.mergeAttrs(trueChildEl, this.el);\n        this.displayError([\n          PHX_LOADING_CLASS,\n          PHX_ERROR_CLASS,\n          PHX_SERVER_ERROR_CLASS,\n        ]);\n        this.el = trueChildEl;\n      } else {\n        this.destroy();\n      }\n    }\n  }\n\n  onClose(reason) {\n    if (this.isDestroyed()) {\n      return;\n    }\n    if (\n      this.isMain() &&\n      this.liveSocket.hasPendingLink() &&\n      reason !== \"leave\"\n    ) {\n      return this.liveSocket.reloadWithJitter(this);\n    }\n    this.destroyAllChildren();\n    this.liveSocket.dropActiveElement(this);\n    if (this.liveSocket.isUnloaded()) {\n      this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);\n    }\n  }\n\n  onError(reason) {\n    this.onClose(reason);\n    if (this.liveSocket.isConnected()) {\n      this.log(\"error\", () => [\"view crashed\", reason]);\n    }\n    if (!this.liveSocket.isUnloaded()) {\n      if (this.liveSocket.isConnected()) {\n        this.displayError([\n          PHX_LOADING_CLASS,\n          PHX_ERROR_CLASS,\n          PHX_SERVER_ERROR_CLASS,\n        ]);\n      } else {\n        this.displayError([\n          PHX_LOADING_CLASS,\n          PHX_ERROR_CLASS,\n          PHX_CLIENT_ERROR_CLASS,\n        ]);\n      }\n    }\n  }\n\n  displayError(classes) {\n    if (this.isMain()) {\n      DOM.dispatchEvent(window, \"phx:page-loading-start\", {\n        detail: { to: this.href, kind: \"error\" },\n      });\n    }\n    this.showLoader();\n    this.setContainerClasses(...classes);\n    this.delayedDisconnected();\n  }\n\n  delayedDisconnected() {\n    this.disconnectedTimer = setTimeout(() => {\n      this.execAll(this.binding(\"disconnected\"));\n    }, this.liveSocket.disconnectedTimeout);\n  }\n\n  wrapPush(callerPush, receives) {\n    const latency = this.liveSocket.getLatencySim();\n    const withLatency = latency\n      ? (cb) => setTimeout(() => !this.isDestroyed() && cb(), latency)\n      : (cb) => !this.isDestroyed() && cb();\n\n    withLatency(() => {\n      callerPush()\n        .receive(\"ok\", (resp) =>\n          withLatency(() => receives.ok && receives.ok(resp)),\n        )\n        .receive(\"error\", (reason) =>\n          withLatency(() => receives.error && receives.error(reason)),\n        )\n        .receive(\"timeout\", () =>\n          withLatency(() => receives.timeout && receives.timeout()),\n        );\n    });\n  }\n\n  pushWithReply(refGenerator, event, payload) {\n    if (!this.isConnected()) {\n      return Promise.reject(new Error(\"no connection\"));\n    }\n\n    const [ref, [el], opts] = refGenerator\n      ? refGenerator({ payload })\n      : [null, [], {}];\n    const oldJoinCount = this.joinCount;\n    let onLoadingDone = function () {};\n    if (opts.page_loading) {\n      onLoadingDone = this.liveSocket.withPageLoading({\n        kind: \"element\",\n        target: el,\n      });\n    }\n\n    if (typeof payload.cid !== \"number\") {\n      delete payload.cid;\n    }\n\n    return new Promise((resolve, reject) => {\n      this.wrapPush(() => this.channel.push(event, payload, PUSH_TIMEOUT), {\n        ok: (resp) => {\n          if (ref !== null) {\n            this.lastAckRef = ref;\n          }\n          const finish = (hookReply) => {\n            if (resp.redirect) {\n              this.onRedirect(resp.redirect);\n            }\n            if (resp.live_patch) {\n              this.onLivePatch(resp.live_patch);\n            }\n            if (resp.live_redirect) {\n              this.onLiveRedirect(resp.live_redirect);\n            }\n            onLoadingDone();\n            resolve({ resp: resp, reply: hookReply, ref });\n          };\n          if (resp.diff) {\n            this.liveSocket.requestDOMUpdate(() => {\n              this.applyDiff(\"update\", resp.diff, ({ diff, reply, events }) => {\n                if (ref !== null) {\n                  this.undoRefs(ref, payload.event);\n                }\n                this.update(diff, events);\n                finish(reply);\n              });\n            });\n          } else {\n            if (ref !== null) {\n              this.undoRefs(ref, payload.event);\n            }\n            finish(null);\n          }\n        },\n        error: (reason) => reject(new Error(`failed with reason: ${reason}`)),\n        timeout: () => {\n          reject(new Error(\"timeout\"));\n          if (this.joinCount === oldJoinCount) {\n            this.liveSocket.reloadWithJitter(this, () => {\n              this.log(\"timeout\", () => [\n                \"received timeout while communicating with server. Falling back to hard refresh for recovery\",\n              ]);\n            });\n          }\n        },\n      });\n    });\n  }\n\n  undoRefs(ref, phxEvent, onlyEls) {\n    if (!this.isConnected()) {\n      return;\n    } // exit if external form triggered\n    const selector = `[${PHX_REF_SRC}=\"${this.refSrc()}\"]`;\n\n    if (onlyEls) {\n      onlyEls = new Set(onlyEls);\n      DOM.all(document, selector, (parent) => {\n        if (onlyEls && !onlyEls.has(parent)) {\n          return;\n        }\n        // undo any child refs within parent first\n        DOM.all(parent, selector, (child) =>\n          this.undoElRef(child, ref, phxEvent),\n        );\n        this.undoElRef(parent, ref, phxEvent);\n      });\n    } else {\n      DOM.all(document, selector, (el) => this.undoElRef(el, ref, phxEvent));\n    }\n  }\n\n  undoElRef(el, ref, phxEvent) {\n    const elRef = new ElementRef(el);\n\n    elRef.maybeUndo(ref, phxEvent, (clonedTree) => {\n      // we need to perform a full patch on unlocked elements\n      // to perform all the necessary logic (like calling updated for hooks, etc.)\n      const patch = new DOMPatch(this, el, this.id, clonedTree, [], null, {\n        undoRef: ref,\n      });\n      const phxChildrenAdded = this.performPatch(patch, true);\n      DOM.all(el, `[${PHX_REF_SRC}=\"${this.refSrc()}\"]`, (child) =>\n        this.undoElRef(child, ref, phxEvent),\n      );\n      if (phxChildrenAdded) {\n        this.joinNewChildren();\n      }\n    });\n  }\n\n  refSrc() {\n    return this.el.id;\n  }\n\n  putRef(elements, phxEvent, eventType, opts = {}) {\n    const newRef = this.ref++;\n    const disableWith = this.binding(PHX_DISABLE_WITH);\n    if (opts.loading) {\n      const loadingEls = DOM.all(document, opts.loading).map((el) => {\n        return { el, lock: true, loading: true };\n      });\n      elements = elements.concat(loadingEls);\n    }\n\n    for (const { el, lock, loading } of elements) {\n      if (!lock && !loading) {\n        throw new Error(\"putRef requires lock or loading\");\n      }\n      el.setAttribute(PHX_REF_SRC, this.refSrc());\n      if (loading) {\n        el.setAttribute(PHX_REF_LOADING, newRef);\n      }\n      if (lock) {\n        el.setAttribute(PHX_REF_LOCK, newRef);\n      }\n\n      if (\n        !loading ||\n        (opts.submitter && !(el === opts.submitter || el === opts.form))\n      ) {\n        continue;\n      }\n\n      const lockCompletePromise = new Promise((resolve) => {\n        el.addEventListener(`phx:undo-lock:${newRef}`, () => resolve(detail), {\n          once: true,\n        });\n      });\n\n      const loadingCompletePromise = new Promise((resolve) => {\n        el.addEventListener(\n          `phx:undo-loading:${newRef}`,\n          () => resolve(detail),\n          { once: true },\n        );\n      });\n\n      el.classList.add(`phx-${eventType}-loading`);\n      const disableText = el.getAttribute(disableWith);\n      if (disableText !== null) {\n        if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {\n          el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);\n        }\n        if (disableText !== \"\") {\n          el.innerText = disableText;\n        }\n        // PHX_DISABLED could have already been set in disableForm\n        el.setAttribute(\n          PHX_DISABLED,\n          el.getAttribute(PHX_DISABLED) || el.disabled,\n        );\n        el.setAttribute(\"disabled\", \"\");\n      }\n\n      const detail = {\n        event: phxEvent,\n        eventType: eventType,\n        ref: newRef,\n        isLoading: loading,\n        isLocked: lock,\n        lockElements: elements.filter(({ lock }) => lock).map(({ el }) => el),\n        loadingElements: elements\n          .filter(({ loading }) => loading)\n          .map(({ el }) => el),\n        unlock: (els) => {\n          els = Array.isArray(els) ? els : [els];\n          this.undoRefs(newRef, phxEvent, els);\n        },\n        lockComplete: lockCompletePromise,\n        loadingComplete: loadingCompletePromise,\n        lock: (lockEl) => {\n          return new Promise((resolve) => {\n            if (this.isAcked(newRef)) {\n              return resolve(detail);\n            }\n            lockEl.setAttribute(PHX_REF_LOCK, newRef);\n            lockEl.setAttribute(PHX_REF_SRC, this.refSrc());\n            lockEl.addEventListener(\n              `phx:lock-stop:${newRef}`,\n              () => resolve(detail),\n              { once: true },\n            );\n          });\n        },\n      };\n      if (opts.payload) {\n        detail[\"payload\"] = opts.payload;\n      }\n      if (opts.target) {\n        detail[\"target\"] = opts.target;\n      }\n      if (opts.originalEvent) {\n        detail[\"originalEvent\"] = opts.originalEvent;\n      }\n      el.dispatchEvent(\n        new CustomEvent(\"phx:push\", {\n          detail: detail,\n          bubbles: true,\n          cancelable: false,\n        }),\n      );\n      if (phxEvent) {\n        el.dispatchEvent(\n          new CustomEvent(`phx:push:${phxEvent}`, {\n            detail: detail,\n            bubbles: true,\n            cancelable: false,\n          }),\n        );\n      }\n    }\n    return [newRef, elements.map(({ el }) => el), opts];\n  }\n\n  isAcked(ref) {\n    return this.lastAckRef !== null && this.lastAckRef >= ref;\n  }\n\n  componentID(el) {\n    const cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);\n    return cid ? parseInt(cid) : null;\n  }\n\n  targetComponentID(target, targetCtx, opts = {}) {\n    if (isCid(targetCtx)) {\n      return targetCtx;\n    }\n\n    const cidOrSelector =\n      opts.target || target.getAttribute(this.binding(\"target\"));\n    if (isCid(cidOrSelector)) {\n      return parseInt(cidOrSelector);\n    } else if (targetCtx && (cidOrSelector !== null || opts.target)) {\n      return this.closestComponentID(targetCtx);\n    } else {\n      return null;\n    }\n  }\n\n  closestComponentID(targetCtx) {\n    if (isCid(targetCtx)) {\n      return targetCtx;\n    } else if (targetCtx) {\n      return maybe(\n        targetCtx.closest(`[${PHX_COMPONENT}]`),\n        (el) => this.ownsElement(el) && this.componentID(el),\n      );\n    } else {\n      return null;\n    }\n  }\n\n  pushHookEvent(el, targetCtx, event, payload) {\n    if (!this.isConnected()) {\n      this.log(\"hook\", () => [\n        \"unable to push hook event. LiveView not connected\",\n        event,\n        payload,\n      ]);\n      return Promise.reject(\n        new Error(\"unable to push hook event. LiveView not connected\"),\n      );\n    }\n\n    const refGenerator = () =>\n      this.putRef([{ el, loading: true, lock: true }], event, \"hook\", {\n        payload,\n        target: targetCtx,\n      });\n\n    return this.pushWithReply(refGenerator, \"event\", {\n      type: \"hook\",\n      event: event,\n      value: payload,\n      cid: this.closestComponentID(targetCtx),\n    }).then(({ resp: _resp, reply, ref }) => ({ reply, ref }));\n  }\n\n  extractMeta(el, meta, value) {\n    const prefix = this.binding(\"value-\");\n    for (let i = 0; i < el.attributes.length; i++) {\n      if (!meta) {\n        meta = {};\n      }\n      const name = el.attributes[i].name;\n      if (name.startsWith(prefix)) {\n        meta[name.replace(prefix, \"\")] = el.getAttribute(name);\n      }\n    }\n    if (el.value !== undefined && !(el instanceof HTMLFormElement)) {\n      if (!meta) {\n        meta = {};\n      }\n      meta.value = el.value;\n\n      if (\n        el.tagName === \"INPUT\" &&\n        CHECKABLE_INPUTS.indexOf(el.type) >= 0 &&\n        !el.checked\n      ) {\n        delete meta.value;\n      }\n    }\n    if (value) {\n      if (!meta) {\n        meta = {};\n      }\n      for (const key in value) {\n        meta[key] = value[key];\n      }\n    }\n    return meta;\n  }\n\n  pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}, onReply) {\n    this.pushWithReply(\n      (maybePayload) =>\n        this.putRef([{ el, loading: true, lock: true }], phxEvent, type, {\n          ...opts,\n          payload: maybePayload?.payload,\n        }),\n      \"event\",\n      {\n        type: type,\n        event: phxEvent,\n        value: this.extractMeta(el, meta, opts.value),\n        cid: this.targetComponentID(el, targetCtx, opts),\n      },\n    )\n      .then(({ reply }) => onReply && onReply(reply))\n      .catch((error) => logError(\"Failed to push event\", error));\n  }\n\n  pushFileProgress(fileEl, entryRef, progress, onReply = function () {}) {\n    this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {\n      view\n        .pushWithReply(null, \"progress\", {\n          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),\n          ref: fileEl.getAttribute(PHX_UPLOAD_REF),\n          entry_ref: entryRef,\n          progress: progress,\n          cid: view.targetComponentID(fileEl.form, targetCtx),\n        })\n        .then(() => onReply())\n        .catch((error) => logError(\"Failed to push file progress\", error));\n    });\n  }\n\n  pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {\n    if (!inputEl.form) {\n      throw new Error(\"form events require the input to be inside a form\");\n    }\n\n    let uploads;\n    const cid = isCid(forceCid)\n      ? forceCid\n      : this.targetComponentID(inputEl.form, targetCtx, opts);\n    const refGenerator = (maybePayload) => {\n      return this.putRef(\n        [\n          { el: inputEl, loading: true, lock: true },\n          { el: inputEl.form, loading: true, lock: true },\n        ],\n        phxEvent,\n        \"change\",\n        { ...opts, payload: maybePayload?.payload },\n      );\n    };\n    let formData;\n    const meta = this.extractMeta(inputEl.form, {}, opts.value);\n    const serializeOpts = {};\n    if (inputEl instanceof HTMLButtonElement) {\n      serializeOpts.submitter = inputEl;\n    }\n    if (inputEl.getAttribute(this.binding(\"change\"))) {\n      formData = serializeForm(inputEl.form, serializeOpts, [inputEl.name]);\n    } else {\n      formData = serializeForm(inputEl.form, serializeOpts);\n    }\n    if (\n      DOM.isUploadInput(inputEl) &&\n      inputEl.files &&\n      inputEl.files.length > 0\n    ) {\n      LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));\n    }\n    uploads = LiveUploader.serializeUploads(inputEl);\n\n    const event = {\n      type: \"form\",\n      event: phxEvent,\n      value: formData,\n      meta: {\n        // no target was implicitly sent as \"undefined\" in LV <= 1.0.5, therefore\n        // we have to keep it. In 1.0.6 we switched from passing meta as URL encoded data\n        // to passing it directly in the event, but the JSON encode would drop keys with\n        // undefined values.\n        _target: opts._target || \"undefined\",\n        ...meta,\n      },\n      uploads: uploads,\n      cid: cid,\n    };\n    this.pushWithReply(refGenerator, \"event\", event)\n      .then(({ resp }) => {\n        if (DOM.isUploadInput(inputEl) && DOM.isAutoUpload(inputEl)) {\n          // the element could be inside a locked parent for other unrelated changes;\n          // we can only start uploads when the tree is unlocked and the\n          // necessary data attributes are set in the real DOM\n          ElementRef.onUnlock(inputEl, () => {\n            if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {\n              const [ref, _els] = refGenerator();\n              this.undoRefs(ref, phxEvent, [inputEl.form]);\n              this.uploadFiles(\n                inputEl.form,\n                phxEvent,\n                targetCtx,\n                ref,\n                cid,\n                (_uploads) => {\n                  callback && callback(resp);\n                  this.triggerAwaitingSubmit(inputEl.form, phxEvent);\n                  this.undoRefs(ref, phxEvent);\n                },\n              );\n            }\n          });\n        } else {\n          callback && callback(resp);\n        }\n      })\n      .catch((error) => logError(\"Failed to push input event\", error));\n  }\n\n  triggerAwaitingSubmit(formEl, phxEvent) {\n    const awaitingSubmit = this.getScheduledSubmit(formEl);\n    if (awaitingSubmit) {\n      const [_el, _ref, _opts, callback] = awaitingSubmit;\n      this.cancelSubmit(formEl, phxEvent);\n      callback();\n    }\n  }\n\n  getScheduledSubmit(formEl) {\n    return this.formSubmits.find(([el, _ref, _opts, _callback]) =>\n      el.isSameNode(formEl),\n    );\n  }\n\n  scheduleSubmit(formEl, ref, opts, callback) {\n    if (this.getScheduledSubmit(formEl)) {\n      return true;\n    }\n    this.formSubmits.push([formEl, ref, opts, callback]);\n  }\n\n  cancelSubmit(formEl, phxEvent) {\n    this.formSubmits = this.formSubmits.filter(\n      ([el, ref, _opts, _callback]) => {\n        if (el.isSameNode(formEl)) {\n          this.undoRefs(ref, phxEvent);\n          return false;\n        } else {\n          return true;\n        }\n      },\n    );\n  }\n\n  disableForm(formEl, phxEvent, opts = {}) {\n    const filterIgnored = (el) => {\n      const userIgnored = closestPhxBinding(\n        el,\n        `${this.binding(PHX_UPDATE)}=ignore`,\n        el.form,\n      );\n      return !(\n        userIgnored || closestPhxBinding(el, \"data-phx-update=ignore\", el.form)\n      );\n    };\n    const filterDisables = (el) => {\n      return el.hasAttribute(this.binding(PHX_DISABLE_WITH));\n    };\n    const filterButton = (el) => el.tagName == \"BUTTON\";\n\n    const filterInput = (el) =>\n      [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(el.tagName);\n\n    const formElements = Array.from(formEl.elements);\n    const disables = formElements.filter(filterDisables);\n    const buttons = formElements.filter(filterButton).filter(filterIgnored);\n    const inputs = formElements.filter(filterInput).filter(filterIgnored);\n\n    buttons.forEach((button) => {\n      button.setAttribute(PHX_DISABLED, button.disabled);\n      button.disabled = true;\n    });\n    inputs.forEach((input) => {\n      input.setAttribute(PHX_READONLY, input.readOnly);\n      input.readOnly = true;\n      if (input.files) {\n        input.setAttribute(PHX_DISABLED, input.disabled);\n        input.disabled = true;\n      }\n    });\n    const formEls = disables\n      .concat(buttons)\n      .concat(inputs)\n      .map((el) => {\n        return { el, loading: true, lock: true };\n      });\n\n    // we reverse the order so form children are already locked by the time\n    // the form is locked\n    const els = [{ el: formEl, loading: true, lock: false }]\n      .concat(formEls)\n      .reverse();\n    return this.putRef(els, phxEvent, \"submit\", opts);\n  }\n\n  pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply) {\n    const refGenerator = (maybePayload) =>\n      this.disableForm(formEl, phxEvent, {\n        ...opts,\n        form: formEl,\n        payload: maybePayload?.payload,\n        submitter: submitter,\n      });\n    // store the submitter in the form element in order to trigger it\n    // for phx-trigger-action\n    DOM.putPrivate(formEl, \"submitter\", submitter);\n    const cid = this.targetComponentID(formEl, targetCtx);\n    if (LiveUploader.hasUploadsInProgress(formEl)) {\n      const [ref, _els] = refGenerator();\n      const push = () =>\n        this.pushFormSubmit(\n          formEl,\n          targetCtx,\n          phxEvent,\n          submitter,\n          opts,\n          onReply,\n        );\n      return this.scheduleSubmit(formEl, ref, opts, push);\n    } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {\n      const [ref, els] = refGenerator();\n      const proxyRefGen = () => [ref, els, opts];\n      this.uploadFiles(formEl, phxEvent, targetCtx, ref, cid, (_uploads) => {\n        // if we still having pending preflights it means we have invalid entries\n        // and the phx-submit cannot be completed\n        if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {\n          return this.undoRefs(ref, phxEvent);\n        }\n        const meta = this.extractMeta(formEl, {}, opts.value);\n        const formData = serializeForm(formEl, { submitter });\n        this.pushWithReply(proxyRefGen, \"event\", {\n          type: \"form\",\n          event: phxEvent,\n          value: formData,\n          meta: meta,\n          cid: cid,\n        })\n          .then(({ resp }) => onReply(resp))\n          .catch((error) => logError(\"Failed to push form submit\", error));\n      });\n    } else if (\n      !(\n        formEl.hasAttribute(PHX_REF_SRC) &&\n        formEl.classList.contains(\"phx-submit-loading\")\n      )\n    ) {\n      const meta = this.extractMeta(formEl, {}, opts.value);\n      const formData = serializeForm(formEl, { submitter });\n      this.pushWithReply(refGenerator, \"event\", {\n        type: \"form\",\n        event: phxEvent,\n        value: formData,\n        meta: meta,\n        cid: cid,\n      })\n        .then(({ resp }) => onReply(resp))\n        .catch((error) => logError(\"Failed to push form submit\", error));\n    }\n  }\n\n  uploadFiles(formEl, phxEvent, targetCtx, ref, cid, onComplete) {\n    const joinCountAtUpload = this.joinCount;\n    const inputEls = LiveUploader.activeFileInputs(formEl);\n    let numFileInputsInProgress = inputEls.length;\n\n    // get each file input\n    inputEls.forEach((inputEl) => {\n      const uploader = new LiveUploader(inputEl, this, () => {\n        numFileInputsInProgress--;\n        if (numFileInputsInProgress === 0) {\n          onComplete();\n        }\n      });\n\n      const entries = uploader\n        .entries()\n        .map((entry) => entry.toPreflightPayload());\n\n      if (entries.length === 0) {\n        numFileInputsInProgress--;\n        return;\n      }\n\n      const payload = {\n        ref: inputEl.getAttribute(PHX_UPLOAD_REF),\n        entries: entries,\n        cid: this.targetComponentID(inputEl.form, targetCtx),\n      };\n\n      this.log(\"upload\", () => [\"sending preflight request\", payload]);\n\n      this.pushWithReply(null, \"allow_upload\", payload)\n        .then(({ resp }) => {\n          this.log(\"upload\", () => [\"got preflight response\", resp]);\n          // the preflight will reject entries beyond the max entries\n          // so we error and cancel entries on the client that are missing from the response\n          uploader.entries().forEach((entry) => {\n            if (resp.entries && !resp.entries[entry.ref]) {\n              this.handleFailedEntryPreflight(\n                entry.ref,\n                \"failed preflight\",\n                uploader,\n              );\n            }\n          });\n          // for auto uploads, we may have an empty entries response from the server\n          // for form submits that contain invalid entries\n          if (resp.error || Object.keys(resp.entries).length === 0) {\n            this.undoRefs(ref, phxEvent);\n            const errors = resp.error || [];\n            errors.map(([entry_ref, reason]) => {\n              this.handleFailedEntryPreflight(entry_ref, reason, uploader);\n            });\n          } else {\n            const onError = (callback) => {\n              this.channel.onError(() => {\n                if (this.joinCount === joinCountAtUpload) {\n                  callback();\n                }\n              });\n            };\n            uploader.initAdapterUpload(resp, onError, this.liveSocket);\n          }\n        })\n        .catch((error) => logError(\"Failed to push upload\", error));\n    });\n  }\n\n  handleFailedEntryPreflight(uploadRef, reason, uploader) {\n    if (uploader.isAutoUpload()) {\n      // uploadRef may be top level upload config ref or entry ref\n      const entry = uploader\n        .entries()\n        .find((entry) => entry.ref === uploadRef.toString());\n      if (entry) {\n        entry.cancel();\n      }\n    } else {\n      uploader.entries().map((entry) => entry.cancel());\n    }\n    this.log(\"upload\", () => [`error for entry ${uploadRef}`, reason]);\n  }\n\n  dispatchUploads(targetCtx, name, filesOrBlobs) {\n    const targetElement = this.targetCtxElement(targetCtx) || this.el;\n    const inputs = DOM.findUploadInputs(targetElement).filter(\n      (el) => el.name === name,\n    );\n    if (inputs.length === 0) {\n      logError(`no live file inputs found matching the name \"${name}\"`);\n    } else if (inputs.length > 1) {\n      logError(`duplicate live file inputs found matching the name \"${name}\"`);\n    } else {\n      DOM.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, {\n        detail: { files: filesOrBlobs },\n      });\n    }\n  }\n\n  targetCtxElement(targetCtx) {\n    if (isCid(targetCtx)) {\n      const [target] = DOM.findComponentNodeList(this.id, targetCtx);\n      return target;\n    } else if (targetCtx) {\n      return targetCtx;\n    } else {\n      return null;\n    }\n  }\n\n  pushFormRecovery(oldForm, newForm, templateDom, callback) {\n    // we are only recovering forms inside the current view, therefore it is safe to\n    // skip withinOwners here and always use this when referring to the view\n    const phxChange = this.binding(\"change\");\n    const phxTarget = newForm.getAttribute(this.binding(\"target\")) || newForm;\n    const phxEvent =\n      newForm.getAttribute(this.binding(PHX_AUTO_RECOVER)) ||\n      newForm.getAttribute(this.binding(\"change\"));\n    const inputs = Array.from(oldForm.elements).filter(\n      (el) => DOM.isFormInput(el) && el.name && !el.hasAttribute(phxChange),\n    );\n    if (inputs.length === 0) {\n      callback();\n      return;\n    }\n\n    // we must clear tracked uploads before recovery as they no longer have valid refs\n    inputs.forEach(\n      (input) =>\n        input.hasAttribute(PHX_UPLOAD_REF) && LiveUploader.clearFiles(input),\n    );\n    // pushInput assumes that there is a source element that initiated the change;\n    // because this is not the case when we recover forms, we provide the first input we find\n    const input = inputs.find((el) => el.type !== \"hidden\") || inputs[0];\n\n    // in the case that there are multiple targets, we count the number of pending recovery events\n    // and only call the callback once all events have been processed\n    let pending = 0;\n    // withinTargets(phxTarget, callback, dom, viewEl)\n    this.withinTargets(\n      phxTarget,\n      (targetView, targetCtx) => {\n        const cid = this.targetComponentID(newForm, targetCtx);\n        pending++;\n        let e = new CustomEvent(\"phx:form-recovery\", {\n          detail: { sourceElement: oldForm },\n        });\n        JS.exec(e, \"change\", phxEvent, this, input, [\n          \"push\",\n          {\n            _target: input.name,\n            targetView,\n            targetCtx,\n            newCid: cid,\n            callback: () => {\n              pending--;\n              if (pending === 0) {\n                callback();\n              }\n            },\n          },\n        ]);\n      },\n      templateDom,\n    );\n  }\n\n  pushLinkPatch(e, href, targetEl, callback) {\n    const linkRef = this.liveSocket.setPendingLink(href);\n    // only add loading states if event is trusted (it was triggered by user, such as click) and\n    // it's not a forward/back navigation from popstate\n    const loading = e.isTrusted && e.type !== \"popstate\";\n    const refGen = targetEl\n      ? () =>\n          this.putRef(\n            [{ el: targetEl, loading: loading, lock: true }],\n            null,\n            \"click\",\n          )\n      : null;\n    const fallback = () => this.liveSocket.redirect(window.location.href);\n    const url = href.startsWith(\"/\")\n      ? `${location.protocol}//${location.host}${href}`\n      : href;\n\n    this.pushWithReply(refGen, \"live_patch\", { url }).then(\n      ({ resp }) => {\n        this.liveSocket.requestDOMUpdate(() => {\n          if (resp.link_redirect) {\n            this.liveSocket.replaceMain(href, null, callback, linkRef);\n          } else {\n            if (this.liveSocket.commitPendingLink(linkRef)) {\n              this.href = href;\n            }\n            this.applyPendingUpdates();\n            callback && callback(linkRef);\n          }\n        });\n      },\n      ({ error: _error, timeout: _timeout }) => fallback(),\n    );\n  }\n\n  getFormsForRecovery() {\n    if (this.joinCount === 0) {\n      return {};\n    }\n\n    const phxChange = this.binding(\"change\");\n\n    return DOM.all(this.el, `form[${phxChange}]`)\n      .filter((form) => form.id)\n      .filter((form) => form.elements.length > 0)\n      .filter(\n        (form) =>\n          form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== \"ignore\",\n      )\n      .map((form) => {\n        // we perform a shallow clone and manually copy all elements\n        const clonedForm = form.cloneNode(false);\n        // we need to copy the private data as it contains\n        // the information about touched fields\n        DOM.copyPrivates(clonedForm, form);\n        Array.from(form.elements).forEach((el) => {\n          // we need to clone all child nodes as well,\n          // because those could also be selects\n          const clonedEl = el.cloneNode(true);\n          // we call morphdom to copy any special state\n          // like the selected option of a <select> element;\n          // this should be plenty fast as we call it on a small subset of the DOM,\n          // single inputs or a select with children\n          morphdom(clonedEl, el);\n          DOM.copyPrivates(clonedEl, el);\n          clonedForm.appendChild(clonedEl);\n        });\n        return clonedForm;\n      })\n      .reduce((acc, form) => {\n        acc[form.id] = form;\n        return acc;\n      }, {});\n  }\n\n  maybePushComponentsDestroyed(destroyedCIDs) {\n    let willDestroyCIDs = destroyedCIDs.filter((cid) => {\n      return DOM.findComponentNodeList(this.el, cid).length === 0;\n    });\n\n    const onError = (error) => {\n      if (!this.isDestroyed()) {\n        logError(\"Failed to push components destroyed\", error);\n      }\n    };\n\n    if (willDestroyCIDs.length > 0) {\n      // we must reset the render change tracking for cids that\n      // could be added back from the server so we don't skip them\n      willDestroyCIDs.forEach((cid) => this.rendered.resetRender(cid));\n\n      this.pushWithReply(null, \"cids_will_destroy\", { cids: willDestroyCIDs })\n        .then(() => {\n          // we must wait for pending transitions to complete before determining\n          // if the cids were added back to the DOM in the meantime (#3139)\n          this.liveSocket.requestDOMUpdate(() => {\n            // See if any of the cids we wanted to destroy were added back,\n            // if they were added back, we don't actually destroy them.\n            let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {\n              return DOM.findComponentNodeList(this.el, cid).length === 0;\n            });\n\n            if (completelyDestroyCIDs.length > 0) {\n              this.pushWithReply(null, \"cids_destroyed\", {\n                cids: completelyDestroyCIDs,\n              })\n                .then(({ resp }) => {\n                  this.rendered.pruneCIDs(resp.cids);\n                })\n                .catch(onError);\n            }\n          });\n        })\n        .catch(onError);\n    }\n  }\n\n  ownsElement(el) {\n    let parentViewEl = el.closest(PHX_VIEW_SELECTOR);\n    return (\n      el.getAttribute(PHX_PARENT_ID) === this.id ||\n      (parentViewEl && parentViewEl.id === this.id) ||\n      (!parentViewEl && this.isDead)\n    );\n  }\n\n  submitForm(form, targetCtx, phxEvent, submitter, opts = {}) {\n    DOM.putPrivate(form, PHX_HAS_SUBMITTED, true);\n    const inputs = Array.from(form.elements);\n    inputs.forEach((input) => DOM.putPrivate(input, PHX_HAS_SUBMITTED, true));\n    this.liveSocket.blurActiveElement(this);\n    this.pushFormSubmit(form, targetCtx, phxEvent, submitter, opts, () => {\n      this.liveSocket.restorePreviouslyActiveFocus();\n    });\n  }\n\n  binding(kind) {\n    return this.liveSocket.binding(kind);\n  }\n\n  // phx-portal\n  pushPortalElementId(id) {\n    this.portalElementIds.add(id);\n  }\n\n  dropPortalElementId(id) {\n    this.portalElementIds.delete(id);\n  }\n\n  destroyPortalElements() {\n    this.portalElementIds.forEach((id) => {\n      const el = document.getElementById(id);\n      if (el) {\n        el.remove();\n      }\n    });\n  }\n}\n", "import {\n  BINDING_PREFIX,\n  CONSECUTIVE_RELOADS,\n  DEFAULTS,\n  FAILSAFE_JITTER,\n  LOADER_TIMEOUT,\n  DISCONNECTED_TIMEOUT,\n  MAX_RELOADS,\n  PHX_DEBOUNCE,\n  PHX_DROP_TARGET,\n  PHX_HAS_FOCUSED,\n  PHX_KEY,\n  PHX_LINK_STATE,\n  PHX_LIVE_LINK,\n  PHX_LV_DEBUG,\n  PHX_LV_LATENCY_SIM,\n  PHX_LV_PROFILE,\n  PHX_LV_HISTORY_POSITION,\n  PHX_MAIN,\n  PHX_PARENT_ID,\n  PHX_VIEW_SELECTOR,\n  PHX_ROOT_ID,\n  PHX_THROTTLE,\n  PHX_TRACK_UPLOADS,\n  PHX_SESSION,\n  RELOAD_JITTER_MIN,\n  RELOAD_JITTER_MAX,\n  PHX_REF_SRC,\n  PHX_RELOAD_STATUS,\n  PHX_RUNTIME_HOOK,\n} from \"./constants\";\n\nimport {\n  clone,\n  closestPhxBinding,\n  closure,\n  debug,\n  maybe,\n  logError,\n} from \"./utils\";\n\nimport Browser from \"./browser\";\nimport DOM from \"./dom\";\nimport Hooks from \"./hooks\";\nimport LiveUploader from \"./live_uploader\";\nimport View from \"./view\";\nimport JS from \"./js\";\nimport jsCommands from \"./js_commands\";\n\nexport const isUsedInput = (el) => DOM.isUsedInput(el);\n\nexport default class LiveSocket {\n  constructor(url, phxSocket, opts = {}) {\n    this.unloaded = false;\n    if (!phxSocket || phxSocket.constructor.name === \"Object\") {\n      throw new Error(`\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\n\n          import {Socket} from \"phoenix\"\n          import {LiveSocket} from \"phoenix_live_view\"\n          let liveSocket = new LiveSocket(\"/live\", Socket, {...})\n      `);\n    }\n    this.socket = new phxSocket(url, opts);\n    this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\n    this.opts = opts;\n    this.params = closure(opts.params || {});\n    this.viewLogger = opts.viewLogger;\n    this.metadataCallbacks = opts.metadata || {};\n    this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});\n    this.prevActive = null;\n    this.silenced = false;\n    this.main = null;\n    this.outgoingMainEl = null;\n    this.clickStartedAtTarget = null;\n    this.linkRef = 1;\n    this.roots = {};\n    this.href = window.location.href;\n    this.pendingLink = null;\n    this.currentLocation = clone(window.location);\n    this.hooks = opts.hooks || {};\n    this.uploaders = opts.uploaders || {};\n    this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;\n    this.disconnectedTimeout = opts.disconnectedTimeout || DISCONNECTED_TIMEOUT;\n    this.reloadWithJitterTimer = null;\n    this.maxReloads = opts.maxReloads || MAX_RELOADS;\n    this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;\n    this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;\n    this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;\n    this.localStorage = opts.localStorage || window.localStorage;\n    this.sessionStorage = opts.sessionStorage || window.sessionStorage;\n    this.boundTopLevelEvents = false;\n    this.boundEventNames = new Set();\n    this.blockPhxChangeWhileComposing =\n      opts.blockPhxChangeWhileComposing || false;\n    this.serverCloseRef = null;\n    this.domCallbacks = Object.assign(\n      {\n        jsQuerySelectorAll: null,\n        onPatchStart: closure(),\n        onPatchEnd: closure(),\n        onNodeAdded: closure(),\n        onBeforeElUpdated: closure(),\n      },\n      opts.dom || {},\n    );\n    this.transitions = new TransitionSet();\n    this.currentHistoryPosition =\n      parseInt(this.sessionStorage.getItem(PHX_LV_HISTORY_POSITION)) || 0;\n    window.addEventListener(\"pagehide\", (_e) => {\n      this.unloaded = true;\n    });\n    this.socket.onOpen(() => {\n      if (this.isUnloaded()) {\n        // reload page if being restored from back/forward cache and browser does not emit \"pageshow\"\n        window.location.reload();\n      }\n    });\n  }\n\n  // public\n\n  version() {\n    return LV_VSN;\n  }\n\n  isProfileEnabled() {\n    return this.sessionStorage.getItem(PHX_LV_PROFILE) === \"true\";\n  }\n\n  isDebugEnabled() {\n    return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"true\";\n  }\n\n  isDebugDisabled() {\n    return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"false\";\n  }\n\n  enableDebug() {\n    this.sessionStorage.setItem(PHX_LV_DEBUG, \"true\");\n  }\n\n  enableProfiling() {\n    this.sessionStorage.setItem(PHX_LV_PROFILE, \"true\");\n  }\n\n  disableDebug() {\n    this.sessionStorage.setItem(PHX_LV_DEBUG, \"false\");\n  }\n\n  disableProfiling() {\n    this.sessionStorage.removeItem(PHX_LV_PROFILE);\n  }\n\n  enableLatencySim(upperBoundMs) {\n    this.enableDebug();\n    console.log(\n      \"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\",\n    );\n    this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);\n  }\n\n  disableLatencySim() {\n    this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);\n  }\n\n  getLatencySim() {\n    const str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);\n    return str ? parseInt(str) : null;\n  }\n\n  getSocket() {\n    return this.socket;\n  }\n\n  connect() {\n    // enable debug by default if on localhost and not explicitly disabled\n    if (window.location.hostname === \"localhost\" && !this.isDebugDisabled()) {\n      this.enableDebug();\n    }\n    const doConnect = () => {\n      this.resetReloadStatus();\n      if (this.joinRootViews()) {\n        this.bindTopLevelEvents();\n        this.socket.connect();\n      } else if (this.main) {\n        this.socket.connect();\n      } else {\n        this.bindTopLevelEvents({ dead: true });\n      }\n      this.joinDeadView();\n    };\n    if (\n      [\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0\n    ) {\n      doConnect();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", () => doConnect());\n    }\n  }\n\n  disconnect(callback) {\n    clearTimeout(this.reloadWithJitterTimer);\n    // remove the socket close listener to avoid trying to handle\n    // a server close event when it is actually caused by us disconnecting\n    if (this.serverCloseRef) {\n      this.socket.off(this.serverCloseRef);\n      this.serverCloseRef = null;\n    }\n    this.socket.disconnect(callback);\n  }\n\n  replaceTransport(transport) {\n    clearTimeout(this.reloadWithJitterTimer);\n    this.socket.replaceTransport(transport);\n    this.connect();\n  }\n\n  execJS(el, encodedJS, eventType = null) {\n    const e = new CustomEvent(\"phx:exec\", { detail: { sourceElement: el } });\n    this.owner(el, (view) => JS.exec(e, eventType, encodedJS, view, el));\n  }\n\n  /**\n   * Returns an object with methods to manipluate the DOM and execute JavaScript.\n   * The applied changes integrate with server DOM patching.\n   *\n   * @returns {import(\"./js_commands\").LiveSocketJSCommands}\n   */\n  js() {\n    return jsCommands(this, \"js\");\n  }\n\n  // private\n\n  unload() {\n    if (this.unloaded) {\n      return;\n    }\n    if (this.main && this.isConnected()) {\n      this.log(this.main, \"socket\", () => [\"disconnect for page nav\"]);\n    }\n    this.unloaded = true;\n    this.destroyAllViews();\n    this.disconnect();\n  }\n\n  triggerDOM(kind, args) {\n    this.domCallbacks[kind](...args);\n  }\n\n  time(name, func) {\n    if (!this.isProfileEnabled() || !console.time) {\n      return func();\n    }\n    console.time(name);\n    const result = func();\n    console.timeEnd(name);\n    return result;\n  }\n\n  log(view, kind, msgCallback) {\n    if (this.viewLogger) {\n      const [msg, obj] = msgCallback();\n      this.viewLogger(view, kind, msg, obj);\n    } else if (this.isDebugEnabled()) {\n      const [msg, obj] = msgCallback();\n      debug(view, kind, msg, obj);\n    }\n  }\n\n  requestDOMUpdate(callback) {\n    this.transitions.after(callback);\n  }\n\n  asyncTransition(promise) {\n    this.transitions.addAsyncTransition(promise);\n  }\n\n  transition(time, onStart, onDone = function () {}) {\n    this.transitions.addTransition(time, onStart, onDone);\n  }\n\n  onChannel(channel, event, cb) {\n    channel.on(event, (data) => {\n      const latency = this.getLatencySim();\n      if (!latency) {\n        cb(data);\n      } else {\n        setTimeout(() => cb(data), latency);\n      }\n    });\n  }\n\n  reloadWithJitter(view, log) {\n    clearTimeout(this.reloadWithJitterTimer);\n    this.disconnect();\n    const minMs = this.reloadJitterMin;\n    const maxMs = this.reloadJitterMax;\n    let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\n    const tries = Browser.updateLocal(\n      this.localStorage,\n      window.location.pathname,\n      CONSECUTIVE_RELOADS,\n      0,\n      (count) => count + 1,\n    );\n    if (tries >= this.maxReloads) {\n      afterMs = this.failsafeJitter;\n    }\n    this.reloadWithJitterTimer = setTimeout(() => {\n      // if view has recovered, such as transport replaced, then cancel\n      if (view.isDestroyed() || view.isConnected()) {\n        return;\n      }\n      view.destroy();\n      log\n        ? log()\n        : this.log(view, \"join\", () => [\n            `encountered ${tries} consecutive reloads`,\n          ]);\n      if (tries >= this.maxReloads) {\n        this.log(view, \"join\", () => [\n          `exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`,\n        ]);\n      }\n      if (this.hasPendingLink()) {\n        window.location = this.pendingLink;\n      } else {\n        window.location.reload();\n      }\n    }, afterMs);\n  }\n\n  getHookDefinition(name) {\n    if (!name) {\n      return;\n    }\n    return (\n      this.maybeInternalHook(name) ||\n      this.hooks[name] ||\n      this.maybeRuntimeHook(name)\n    );\n  }\n\n  maybeInternalHook(name) {\n    return name && name.startsWith(\"Phoenix.\") && Hooks[name.split(\".\")[1]];\n  }\n\n  maybeRuntimeHook(name) {\n    const runtimeHook = document.querySelector(\n      `script[${PHX_RUNTIME_HOOK}=\"${CSS.escape(name)}\"]`,\n    );\n    if (!runtimeHook) {\n      return;\n    }\n    let callbacks = window[`phx_hook_${name}`];\n    if (!callbacks || typeof callbacks !== \"function\") {\n      logError(\"a runtime hook must be a function\", runtimeHook);\n      return;\n    }\n    const hookDefiniton = callbacks();\n    if (\n      hookDefiniton &&\n      (typeof hookDefiniton === \"object\" || typeof hookDefiniton === \"function\")\n    ) {\n      return hookDefiniton;\n    }\n    logError(\n      \"runtime hook must return an object with hook callbacks or an instance of ViewHook\",\n      runtimeHook,\n    );\n  }\n\n  isUnloaded() {\n    return this.unloaded;\n  }\n\n  isConnected() {\n    return this.socket.isConnected();\n  }\n\n  getBindingPrefix() {\n    return this.bindingPrefix;\n  }\n\n  binding(kind) {\n    return `${this.getBindingPrefix()}${kind}`;\n  }\n\n  channel(topic, params) {\n    return this.socket.channel(topic, params);\n  }\n\n  joinDeadView() {\n    const body = document.body;\n    if (\n      body &&\n      !this.isPhxView(body) &&\n      !this.isPhxView(document.firstElementChild)\n    ) {\n      const view = this.newRootView(body);\n      view.setHref(this.getHref());\n      view.joinDead();\n      if (!this.main) {\n        this.main = view;\n      }\n      window.requestAnimationFrame(() => {\n        view.execNewMounted();\n        // restore scroll position when navigating from an external / non-live page\n        this.maybeScroll(history.state?.scroll);\n      });\n    }\n  }\n\n  joinRootViews() {\n    let rootsFound = false;\n    DOM.all(\n      document,\n      `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`,\n      (rootEl) => {\n        if (!this.getRootById(rootEl.id)) {\n          const view = this.newRootView(rootEl);\n          // stickies cannot be mounted at the router and therefore should not\n          // get a href set on them\n          if (!DOM.isPhxSticky(rootEl)) {\n            view.setHref(this.getHref());\n          }\n          view.join();\n          if (rootEl.hasAttribute(PHX_MAIN)) {\n            this.main = view;\n          }\n        }\n        rootsFound = true;\n      },\n    );\n    return rootsFound;\n  }\n\n  redirect(to, flash, reloadToken) {\n    if (reloadToken) {\n      Browser.setCookie(PHX_RELOAD_STATUS, reloadToken, 60);\n    }\n    this.unload();\n    Browser.redirect(to, flash);\n  }\n\n  replaceMain(\n    href,\n    flash,\n    callback = null,\n    linkRef = this.setPendingLink(href),\n  ) {\n    const liveReferer = this.currentLocation.href;\n    this.outgoingMainEl = this.outgoingMainEl || this.main.el;\n\n    const stickies = DOM.findPhxSticky(document) || [];\n    const removeEls = DOM.all(\n      this.outgoingMainEl,\n      `[${this.binding(\"remove\")}]`,\n    ).filter((el) => !DOM.isChildOfAny(el, stickies));\n\n    const newMainEl = DOM.cloneNode(this.outgoingMainEl, \"\");\n    this.main.showLoader(this.loaderTimeout);\n    this.main.destroy();\n\n    this.main = this.newRootView(newMainEl, flash, liveReferer);\n    this.main.setRedirect(href);\n    this.transitionRemoves(removeEls);\n    this.main.join((joinCount, onDone) => {\n      if (joinCount === 1 && this.commitPendingLink(linkRef)) {\n        this.requestDOMUpdate(() => {\n          // remove phx-remove els right before we replace the main element\n          removeEls.forEach((el) => el.remove());\n          stickies.forEach((el) => newMainEl.appendChild(el));\n          this.outgoingMainEl.replaceWith(newMainEl);\n          this.outgoingMainEl = null;\n          callback && callback(linkRef);\n          onDone();\n        });\n      }\n    });\n  }\n\n  transitionRemoves(elements, callback) {\n    const removeAttr = this.binding(\"remove\");\n    const silenceEvents = (e) => {\n      e.preventDefault();\n      e.stopImmediatePropagation();\n    };\n    elements.forEach((el) => {\n      // prevent all listeners we care about from bubbling to window\n      // since we are removing the element\n      for (const event of this.boundEventNames) {\n        el.addEventListener(event, silenceEvents, true);\n      }\n      this.execJS(el, el.getAttribute(removeAttr), \"remove\");\n    });\n    // remove the silenced listeners when transitions are done incase the element is re-used\n    // and call caller's callback as soon as we are done with transitions\n    this.requestDOMUpdate(() => {\n      elements.forEach((el) => {\n        for (const event of this.boundEventNames) {\n          el.removeEventListener(event, silenceEvents, true);\n        }\n      });\n      callback && callback();\n    });\n  }\n\n  isPhxView(el) {\n    return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;\n  }\n\n  newRootView(el, flash, liveReferer) {\n    const view = new View(el, this, null, flash, liveReferer);\n    this.roots[view.id] = view;\n    return view;\n  }\n\n  owner(childEl, callback) {\n    let view;\n    const viewEl = DOM.closestViewEl(childEl);\n    if (viewEl) {\n      // it can happen that we find a view that is already destroyed;\n      // in that case we DO NOT want to fallback to the main element\n      view = this.getViewByEl(viewEl);\n    } else {\n      view = this.main;\n    }\n    return view && callback ? callback(view) : view;\n  }\n\n  withinOwners(childEl, callback) {\n    this.owner(childEl, (view) => callback(view, childEl));\n  }\n\n  getViewByEl(el) {\n    const rootId = el.getAttribute(PHX_ROOT_ID);\n    return maybe(this.getRootById(rootId), (root) =>\n      root.getDescendentByEl(el),\n    );\n  }\n\n  getRootById(id) {\n    return this.roots[id];\n  }\n\n  destroyAllViews() {\n    for (const id in this.roots) {\n      this.roots[id].destroy();\n      delete this.roots[id];\n    }\n    this.main = null;\n  }\n\n  destroyViewByEl(el) {\n    const root = this.getRootById(el.getAttribute(PHX_ROOT_ID));\n    if (root && root.id === el.id) {\n      root.destroy();\n      delete this.roots[root.id];\n    } else if (root) {\n      root.destroyDescendent(el.id);\n    }\n  }\n\n  getActiveElement() {\n    return document.activeElement;\n  }\n\n  dropActiveElement(view) {\n    if (this.prevActive && view.ownsElement(this.prevActive)) {\n      this.prevActive = null;\n    }\n  }\n\n  restorePreviouslyActiveFocus() {\n    if (\n      this.prevActive &&\n      this.prevActive !== document.body &&\n      this.prevActive instanceof HTMLElement\n    ) {\n      this.prevActive.focus();\n    }\n  }\n\n  blurActiveElement() {\n    this.prevActive = this.getActiveElement();\n    if (\n      this.prevActive !== document.body &&\n      this.prevActive instanceof HTMLElement\n    ) {\n      this.prevActive.blur();\n    }\n  }\n\n  /**\n   * @param {{dead?: boolean}} [options={}]\n   */\n  bindTopLevelEvents({ dead } = {}) {\n    if (this.boundTopLevelEvents) {\n      return;\n    }\n\n    this.boundTopLevelEvents = true;\n    // enter failsafe reload if server has gone away intentionally, such as \"disconnect\" broadcast\n    this.serverCloseRef = this.socket.onClose((event) => {\n      // failsafe reload if normal closure and we still have a main LV\n      if (event && event.code === 1000 && this.main) {\n        return this.reloadWithJitter(this.main);\n      }\n    });\n    document.body.addEventListener(\"click\", function () {}); // ensure all click events bubble for mobile Safari\n    window.addEventListener(\n      \"pageshow\",\n      (e) => {\n        if (e.persisted) {\n          // reload page if being restored from back/forward cache\n          this.getSocket().disconnect();\n          this.withPageLoading({ to: window.location.href, kind: \"redirect\" });\n          window.location.reload();\n        }\n      },\n      true,\n    );\n    if (!dead) {\n      this.bindNav();\n    }\n    this.bindClicks();\n    if (!dead) {\n      this.bindForms();\n    }\n    this.bind(\n      { keyup: \"keyup\", keydown: \"keydown\" },\n      (e, type, view, targetEl, phxEvent, _phxTarget) => {\n        const matchKey = targetEl.getAttribute(this.binding(PHX_KEY));\n        const pressedKey = e.key && e.key.toLowerCase(); // chrome clicked autocompletes send a keydown without key\n        if (matchKey && matchKey.toLowerCase() !== pressedKey) {\n          return;\n        }\n\n        const data = { key: e.key, ...this.eventMeta(type, e, targetEl) };\n        JS.exec(e, type, phxEvent, view, targetEl, [\"push\", { data }]);\n      },\n    );\n    this.bind(\n      { blur: \"focusout\", focus: \"focusin\" },\n      (e, type, view, targetEl, phxEvent, phxTarget) => {\n        if (!phxTarget) {\n          const data = { key: e.key, ...this.eventMeta(type, e, targetEl) };\n          JS.exec(e, type, phxEvent, view, targetEl, [\"push\", { data }]);\n        }\n      },\n    );\n    this.bind(\n      { blur: \"blur\", focus: \"focus\" },\n      (e, type, view, targetEl, phxEvent, phxTarget) => {\n        // blur and focus are triggered on document and window. Discard one to avoid dups\n        if (phxTarget === \"window\") {\n          const data = this.eventMeta(type, e, targetEl);\n          JS.exec(e, type, phxEvent, view, targetEl, [\"push\", { data }]);\n        }\n      },\n    );\n    this.on(\"dragover\", (e) => e.preventDefault());\n    this.on(\"drop\", (e) => {\n      e.preventDefault();\n      const dropTargetId = maybe(\n        closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)),\n        (trueTarget) => {\n          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));\n        },\n      );\n      const dropTarget = dropTargetId && document.getElementById(dropTargetId);\n      const files = Array.from(e.dataTransfer.files || []);\n      if (\n        !dropTarget ||\n        !(dropTarget instanceof HTMLInputElement) ||\n        dropTarget.disabled ||\n        files.length === 0 ||\n        !(dropTarget.files instanceof FileList)\n      ) {\n        return;\n      }\n\n      LiveUploader.trackFiles(dropTarget, files, e.dataTransfer);\n      dropTarget.dispatchEvent(new Event(\"input\", { bubbles: true }));\n    });\n    this.on(PHX_TRACK_UPLOADS, (e) => {\n      const uploadTarget = e.target;\n      if (!DOM.isUploadInput(uploadTarget)) {\n        return;\n      }\n      const files = Array.from(e.detail.files || []).filter(\n        (f) => f instanceof File || f instanceof Blob,\n      );\n      LiveUploader.trackFiles(uploadTarget, files);\n      uploadTarget.dispatchEvent(new Event(\"input\", { bubbles: true }));\n    });\n  }\n\n  eventMeta(eventName, e, targetEl) {\n    const callback = this.metadataCallbacks[eventName];\n    return callback ? callback(e, targetEl) : {};\n  }\n\n  setPendingLink(href) {\n    this.linkRef++;\n    this.pendingLink = href;\n    this.resetReloadStatus();\n    return this.linkRef;\n  }\n\n  // anytime we are navigating or connecting, drop reload cookie in case\n  // we issue the cookie but the next request was interrupted and the server never dropped it\n  resetReloadStatus() {\n    Browser.deleteCookie(PHX_RELOAD_STATUS);\n  }\n\n  commitPendingLink(linkRef) {\n    if (this.linkRef !== linkRef) {\n      return false;\n    } else {\n      this.href = this.pendingLink;\n      this.pendingLink = null;\n      return true;\n    }\n  }\n\n  getHref() {\n    return this.href;\n  }\n\n  hasPendingLink() {\n    return !!this.pendingLink;\n  }\n\n  bind(events, callback) {\n    for (const event in events) {\n      const browserEventName = events[event];\n\n      this.on(browserEventName, (e) => {\n        const binding = this.binding(event);\n        const windowBinding = this.binding(`window-${event}`);\n        const targetPhxEvent =\n          e.target.getAttribute && e.target.getAttribute(binding);\n        if (targetPhxEvent) {\n          this.debounce(e.target, e, browserEventName, () => {\n            this.withinOwners(e.target, (view) => {\n              callback(e, event, view, e.target, targetPhxEvent, null);\n            });\n          });\n        } else {\n          DOM.all(document, `[${windowBinding}]`, (el) => {\n            const phxEvent = el.getAttribute(windowBinding);\n            this.debounce(el, e, browserEventName, () => {\n              this.withinOwners(el, (view) => {\n                callback(e, event, view, el, phxEvent, \"window\");\n              });\n            });\n          });\n        }\n      });\n    }\n  }\n\n  bindClicks() {\n    this.on(\"mousedown\", (e) => (this.clickStartedAtTarget = e.target));\n    this.bindClick(\"click\", \"click\");\n  }\n\n  bindClick(eventName, bindingName) {\n    const click = this.binding(bindingName);\n    window.addEventListener(\n      eventName,\n      (e) => {\n        let target = null;\n        // a synthetic click event (detail 0) will not have caused a mousedown event,\n        // therefore the clickStartedAtTarget is stale\n        if (e.detail === 0) this.clickStartedAtTarget = e.target;\n        const clickStartedAtTarget = this.clickStartedAtTarget || e.target;\n        // when searching the target for the click event, we always want to\n        // use the actual event target, see #3372\n        target = closestPhxBinding(e.target, click);\n        this.dispatchClickAway(e, clickStartedAtTarget);\n        this.clickStartedAtTarget = null;\n        const phxEvent = target && target.getAttribute(click);\n        if (!phxEvent) {\n          if (DOM.isNewPageClick(e, window.location)) {\n            this.unload();\n          }\n          return;\n        }\n\n        if (target.getAttribute(\"href\") === \"#\") {\n          e.preventDefault();\n        }\n\n        // noop if we are in the middle of awaiting an ack for this el already\n        if (target.hasAttribute(PHX_REF_SRC)) {\n          return;\n        }\n\n        this.debounce(target, e, \"click\", () => {\n          this.withinOwners(target, (view) => {\n            JS.exec(e, \"click\", phxEvent, view, target, [\n              \"push\",\n              { data: this.eventMeta(\"click\", e, target) },\n            ]);\n          });\n        });\n      },\n      false,\n    );\n  }\n\n  dispatchClickAway(e, clickStartedAt) {\n    const phxClickAway = this.binding(\"click-away\");\n    DOM.all(document, `[${phxClickAway}]`, (el) => {\n      if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {\n        this.withinOwners(el, (view) => {\n          const phxEvent = el.getAttribute(phxClickAway);\n          if (JS.isVisible(el) && JS.isInViewport(el)) {\n            JS.exec(e, \"click\", phxEvent, view, el, [\n              \"push\",\n              { data: this.eventMeta(\"click\", e, e.target) },\n            ]);\n          }\n        });\n      }\n    });\n  }\n\n  bindNav() {\n    if (!Browser.canPushState()) {\n      return;\n    }\n    if (history.scrollRestoration) {\n      history.scrollRestoration = \"manual\";\n    }\n    let scrollTimer = null;\n    window.addEventListener(\"scroll\", (_e) => {\n      clearTimeout(scrollTimer);\n      scrollTimer = setTimeout(() => {\n        Browser.updateCurrentState((state) =>\n          Object.assign(state, { scroll: window.scrollY }),\n        );\n      }, 100);\n    });\n    window.addEventListener(\n      \"popstate\",\n      (event) => {\n        if (!this.registerNewLocation(window.location)) {\n          return;\n        }\n        const { type, backType, id, scroll, position } = event.state || {};\n        const href = window.location.href;\n\n        // Compare positions to determine direction\n        const isForward = position > this.currentHistoryPosition;\n        const navType = isForward ? type : backType || type;\n\n        // Update current position\n        this.currentHistoryPosition = position || 0;\n        this.sessionStorage.setItem(\n          PHX_LV_HISTORY_POSITION,\n          this.currentHistoryPosition.toString(),\n        );\n\n        DOM.dispatchEvent(window, \"phx:navigate\", {\n          detail: {\n            href,\n            patch: navType === \"patch\",\n            pop: true,\n            direction: isForward ? \"forward\" : \"backward\",\n          },\n        });\n        this.requestDOMUpdate(() => {\n          const callback = () => {\n            this.maybeScroll(scroll);\n          };\n          if (\n            this.main.isConnected() &&\n            navType === \"patch\" &&\n            id === this.main.id\n          ) {\n            this.main.pushLinkPatch(event, href, null, callback);\n          } else {\n            this.replaceMain(href, null, callback);\n          }\n        });\n      },\n      false,\n    );\n    window.addEventListener(\n      \"click\",\n      (e) => {\n        const target = closestPhxBinding(e.target, PHX_LIVE_LINK);\n        const type = target && target.getAttribute(PHX_LIVE_LINK);\n        if (!type || !this.isConnected() || !this.main || DOM.wantsNewTab(e)) {\n          return;\n        }\n\n        // When wrapping an SVG element in an anchor tag, the href can be an SVGAnimatedString\n        const href =\n          target.href instanceof SVGAnimatedString\n            ? target.href.baseVal\n            : target.href;\n\n        const linkState = target.getAttribute(PHX_LINK_STATE);\n        e.preventDefault();\n        e.stopImmediatePropagation(); // do not bubble click to regular phx-click bindings\n        if (this.pendingLink === href) {\n          return;\n        }\n\n        this.requestDOMUpdate(() => {\n          if (type === \"patch\") {\n            this.pushHistoryPatch(e, href, linkState, target);\n          } else if (type === \"redirect\") {\n            this.historyRedirect(e, href, linkState, null, target);\n          } else {\n            throw new Error(\n              `expected ${PHX_LIVE_LINK} to be \"patch\" or \"redirect\", got: ${type}`,\n            );\n          }\n          const phxClick = target.getAttribute(this.binding(\"click\"));\n          if (phxClick) {\n            this.requestDOMUpdate(() => this.execJS(target, phxClick, \"click\"));\n          }\n        });\n      },\n      false,\n    );\n  }\n\n  maybeScroll(scroll) {\n    if (typeof scroll === \"number\") {\n      requestAnimationFrame(() => {\n        window.scrollTo(0, scroll);\n      }); // the body needs to render before we scroll.\n    }\n  }\n\n  dispatchEvent(event, payload = {}) {\n    DOM.dispatchEvent(window, `phx:${event}`, { detail: payload });\n  }\n\n  dispatchEvents(events) {\n    events.forEach(([event, payload]) => this.dispatchEvent(event, payload));\n  }\n\n  withPageLoading(info, callback) {\n    DOM.dispatchEvent(window, \"phx:page-loading-start\", { detail: info });\n    const done = () =>\n      DOM.dispatchEvent(window, \"phx:page-loading-stop\", { detail: info });\n    return callback ? callback(done) : done;\n  }\n\n  pushHistoryPatch(e, href, linkState, targetEl) {\n    if (!this.isConnected() || !this.main.isMain()) {\n      return Browser.redirect(href);\n    }\n\n    this.withPageLoading({ to: href, kind: \"patch\" }, (done) => {\n      this.main.pushLinkPatch(e, href, targetEl, (linkRef) => {\n        this.historyPatch(href, linkState, linkRef);\n        done();\n      });\n    });\n  }\n\n  historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {\n    if (!this.commitPendingLink(linkRef)) {\n      return;\n    }\n\n    // Increment position for new state\n    this.currentHistoryPosition++;\n    this.sessionStorage.setItem(\n      PHX_LV_HISTORY_POSITION,\n      this.currentHistoryPosition.toString(),\n    );\n\n    // store the type for back navigation\n    Browser.updateCurrentState((state) => ({ ...state, backType: \"patch\" }));\n\n    Browser.pushState(\n      linkState,\n      {\n        type: \"patch\",\n        id: this.main.id,\n        position: this.currentHistoryPosition,\n      },\n      href,\n    );\n\n    DOM.dispatchEvent(window, \"phx:navigate\", {\n      detail: { patch: true, href, pop: false, direction: \"forward\" },\n    });\n    this.registerNewLocation(window.location);\n  }\n\n  historyRedirect(e, href, linkState, flash, targetEl) {\n    const clickLoading = targetEl && e.isTrusted && e.type !== \"popstate\";\n    if (clickLoading) {\n      targetEl.classList.add(\"phx-click-loading\");\n    }\n    if (!this.isConnected() || !this.main.isMain()) {\n      return Browser.redirect(href, flash);\n    }\n\n    // convert to full href if only path prefix\n    if (/^\\/$|^\\/[^\\/]+.*$/.test(href)) {\n      const { protocol, host } = window.location;\n      href = `${protocol}//${host}${href}`;\n    }\n    const scroll = window.scrollY;\n    this.withPageLoading({ to: href, kind: \"redirect\" }, (done) => {\n      this.replaceMain(href, flash, (linkRef) => {\n        if (linkRef === this.linkRef) {\n          // Increment position for new state\n          this.currentHistoryPosition++;\n          this.sessionStorage.setItem(\n            PHX_LV_HISTORY_POSITION,\n            this.currentHistoryPosition.toString(),\n          );\n\n          // store the type for back navigation\n          Browser.updateCurrentState((state) => ({\n            ...state,\n            backType: \"redirect\",\n          }));\n\n          Browser.pushState(\n            linkState,\n            {\n              type: \"redirect\",\n              id: this.main.id,\n              scroll: scroll,\n              position: this.currentHistoryPosition,\n            },\n            href,\n          );\n\n          DOM.dispatchEvent(window, \"phx:navigate\", {\n            detail: { href, patch: false, pop: false, direction: \"forward\" },\n          });\n          this.registerNewLocation(window.location);\n        }\n        // explicitly undo click-loading class\n        // (in case it originated in a sticky live view, otherwise it would be removed anyway)\n        if (clickLoading) {\n          targetEl.classList.remove(\"phx-click-loading\");\n        }\n        done();\n      });\n    });\n  }\n\n  registerNewLocation(newLocation) {\n    const { pathname, search } = this.currentLocation;\n    if (pathname + search === newLocation.pathname + newLocation.search) {\n      return false;\n    } else {\n      this.currentLocation = clone(newLocation);\n      return true;\n    }\n  }\n\n  bindForms() {\n    let iterations = 0;\n    let externalFormSubmitted = false;\n\n    // disable forms on submit that track phx-change but perform external submit\n    this.on(\"submit\", (e) => {\n      const phxSubmit = e.target.getAttribute(this.binding(\"submit\"));\n      const phxChange = e.target.getAttribute(this.binding(\"change\"));\n      if (!externalFormSubmitted && phxChange && !phxSubmit) {\n        externalFormSubmitted = true;\n        e.preventDefault();\n        this.withinOwners(e.target, (view) => {\n          view.disableForm(e.target);\n          // safari needs next tick\n          window.requestAnimationFrame(() => {\n            if (DOM.isUnloadableFormSubmit(e)) {\n              this.unload();\n            }\n            e.target.submit();\n          });\n        });\n      }\n    });\n\n    this.on(\"submit\", (e) => {\n      const phxEvent = e.target.getAttribute(this.binding(\"submit\"));\n      if (!phxEvent) {\n        if (DOM.isUnloadableFormSubmit(e)) {\n          this.unload();\n        }\n        return;\n      }\n      e.preventDefault();\n      e.target.disabled = true;\n      this.withinOwners(e.target, (view) => {\n        JS.exec(e, \"submit\", phxEvent, view, e.target, [\n          \"push\",\n          { submitter: e.submitter },\n        ]);\n      });\n    });\n\n    for (const type of [\"change\", \"input\"]) {\n      this.on(type, (e) => {\n        if (\n          e instanceof CustomEvent &&\n          (e.target instanceof HTMLInputElement ||\n            e.target instanceof HTMLSelectElement ||\n            e.target instanceof HTMLTextAreaElement) &&\n          e.target.form === undefined\n        ) {\n          // throw on invalid JS.dispatch target and noop if CustomEvent triggered outside JS.dispatch\n          if (e.detail && e.detail.dispatcher) {\n            throw new Error(\n              `dispatching a custom ${type} event is only supported on input elements inside a form`,\n            );\n          }\n          return;\n        }\n        const phxChange = this.binding(\"change\");\n        const input = e.target;\n        if (this.blockPhxChangeWhileComposing && e.isComposing) {\n          const key = `composition-listener-${type}`;\n          if (!DOM.private(input, key)) {\n            DOM.putPrivate(input, key, true);\n            input.addEventListener(\n              \"compositionend\",\n              () => {\n                // trigger a new input/change event\n                input.dispatchEvent(new Event(type, { bubbles: true }));\n                DOM.deletePrivate(input, key);\n              },\n              { once: true },\n            );\n          }\n          return;\n        }\n        const inputEvent = input.getAttribute(phxChange);\n        const formEvent = input.form && input.form.getAttribute(phxChange);\n        const phxEvent = inputEvent || formEvent;\n        if (!phxEvent) {\n          return;\n        }\n        if (\n          input.type === \"number\" &&\n          input.validity &&\n          input.validity.badInput\n        ) {\n          return;\n        }\n\n        const dispatcher = inputEvent ? input : input.form;\n        const currentIterations = iterations;\n        iterations++;\n        const { at: at, type: lastType } =\n          DOM.private(input, \"prev-iteration\") || {};\n        // Browsers should always fire at least one \"input\" event before every \"change\"\n        // Ignore \"change\" events, unless there was no prior \"input\" event.\n        // This could happen if user code triggers a \"change\" event, or if the browser is non-conforming.\n        if (\n          at === currentIterations - 1 &&\n          type === \"change\" &&\n          lastType === \"input\"\n        ) {\n          return;\n        }\n\n        DOM.putPrivate(input, \"prev-iteration\", {\n          at: currentIterations,\n          type: type,\n        });\n\n        this.debounce(input, e, type, () => {\n          this.withinOwners(dispatcher, (view) => {\n            DOM.putPrivate(input, PHX_HAS_FOCUSED, true);\n            JS.exec(e, \"change\", phxEvent, view, input, [\n              \"push\",\n              { _target: e.target.name, dispatcher: dispatcher },\n            ]);\n          });\n        });\n      });\n    }\n    this.on(\"reset\", (e) => {\n      const form = e.target;\n      DOM.resetForm(form);\n      const input = Array.from(form.elements).find((el) => el.type === \"reset\");\n      if (input) {\n        // wait until next tick to get updated input value\n        window.requestAnimationFrame(() => {\n          input.dispatchEvent(\n            new Event(\"input\", { bubbles: true, cancelable: false }),\n          );\n        });\n      }\n    });\n  }\n\n  debounce(el, event, eventType, callback) {\n    if (eventType === \"blur\" || eventType === \"focusout\") {\n      return callback();\n    }\n\n    const phxDebounce = this.binding(PHX_DEBOUNCE);\n    const phxThrottle = this.binding(PHX_THROTTLE);\n    const defaultDebounce = this.defaults.debounce.toString();\n    const defaultThrottle = this.defaults.throttle.toString();\n\n    this.withinOwners(el, (view) => {\n      const asyncFilter = () =>\n        !view.isDestroyed() && document.body.contains(el);\n      DOM.debounce(\n        el,\n        event,\n        phxDebounce,\n        defaultDebounce,\n        phxThrottle,\n        defaultThrottle,\n        asyncFilter,\n        () => {\n          callback();\n        },\n      );\n    });\n  }\n\n  silenceEvents(callback) {\n    this.silenced = true;\n    callback();\n    this.silenced = false;\n  }\n\n  on(event, callback) {\n    this.boundEventNames.add(event);\n    window.addEventListener(event, (e) => {\n      if (!this.silenced) {\n        callback(e);\n      }\n    });\n  }\n\n  jsQuerySelectorAll(sourceEl, query, defaultQuery) {\n    const all = this.domCallbacks.jsQuerySelectorAll;\n    return all ? all(sourceEl, query, defaultQuery) : defaultQuery();\n  }\n}\n\nclass TransitionSet {\n  constructor() {\n    this.transitions = new Set();\n    this.promises = new Set();\n    this.pendingOps = [];\n  }\n\n  reset() {\n    this.transitions.forEach((timer) => {\n      clearTimeout(timer);\n      this.transitions.delete(timer);\n    });\n    this.promises.clear();\n    this.flushPendingOps();\n  }\n\n  after(callback) {\n    if (this.size() === 0) {\n      callback();\n    } else {\n      this.pushPendingOp(callback);\n    }\n  }\n\n  addTransition(time, onStart, onDone) {\n    onStart();\n    const timer = setTimeout(() => {\n      this.transitions.delete(timer);\n      onDone();\n      this.flushPendingOps();\n    }, time);\n    this.transitions.add(timer);\n  }\n\n  addAsyncTransition(promise) {\n    this.promises.add(promise);\n    promise.then(() => {\n      this.promises.delete(promise);\n      this.flushPendingOps();\n    });\n  }\n\n  pushPendingOp(op) {\n    this.pendingOps.push(op);\n  }\n\n  size() {\n    return this.transitions.size + this.promises.size;\n  }\n\n  flushPendingOps() {\n    if (this.size() > 0) {\n      return;\n    }\n    const op = this.pendingOps.shift();\n    if (op) {\n      op();\n      this.flushPendingOps();\n    }\n  }\n}\n", "/*\n================================================================================\nPhoenix LiveView JavaScript Client\n================================================================================\n\nSee the hexdocs at `https://hexdocs.pm/phoenix_live_view` for documentation.\n*/\n\nimport OriginalLiveSocket, { isUsedInput } from \"./live_socket\";\nimport DOM from \"./dom\";\nimport { ViewHook } from \"./view_hook\";\nimport View from \"./view\";\n\nimport type { LiveSocketJSCommands } from \"./js_commands\";\nimport type { Hook, HooksOptions } from \"./view_hook\";\nimport type { Socket as PhoenixSocket } from \"phoenix\";\n\n/**\n * Options for configuring the LiveSocket instance.\n */\nexport interface LiveSocketOptions {\n  /**\n   * Defaults for phx-debounce and phx-throttle.\n   */\n  defaults?: {\n    /** The millisecond phx-debounce time. Defaults 300 */\n    debounce?: number;\n    /** The millisecond phx-throttle time. Defaults 300 */\n    throttle?: number;\n  };\n  /**\n   * An object or function for passing connect params.\n   * The function receives the element associated with a given LiveView. For example:\n   *\n   *     (el) => {view: el.getAttribute(\"data-my-view-name\", token: window.myToken}\n   *\n   */\n  params?:\n    | ((el: HTMLElement) => { [key: string]: any })\n    | { [key: string]: any };\n  /**\n   * The optional prefix to use for all phx DOM annotations.\n   *\n   * Defaults to \"phx-\".\n   */\n  bindingPrefix?: string;\n  /**\n   * Callbacks for LiveView hooks.\n   *\n   * See [Client hooks via `phx-hook`](https://hexdocs.pm/phoenix_live_view/js-interop.html#client-hooks-via-phx-hook) for more information.\n   */\n  hooks?: HooksOptions;\n  /** Callbacks for LiveView uploaders. */\n  uploaders?: { [key: string]: any }; // TODO: define more specifically\n  /** Delay in milliseconds before applying loading states. */\n  loaderTimeout?: number;\n  /** Delay in milliseconds before executing phx-disconnected commands. */\n  disconnectedTimeout?: number;\n  /** Maximum reloads before entering failsafe mode. */\n  maxReloads?: number;\n  /** Minimum time between normal reload attempts. */\n  reloadJitterMin?: number;\n  /** Maximum time between normal reload attempts. */\n  reloadJitterMax?: number;\n  /** Time between reload attempts in failsafe mode. */\n  failsafeJitter?: number;\n  /**\n   * Function to log debug information. For example:\n   *\n   *     (view, kind, msg, obj) => console.log(`${view.id} ${kind}: ${msg} - `, obj)\n   */\n  viewLogger?: (view: View, kind: string, msg: string, obj: any) => void;\n  /**\n   * Object mapping event names to functions for populating event metadata.\n   *\n   *     metadata: {\n   *       click: (e, el) => {\n   *         return {\n   *           ctrlKey: e.ctrlKey,\n   *           metaKey: e.metaKey,\n   *           detail: e.detail || 1,\n   *         }\n   *       },\n   *       keydown: (e, el) => {\n   *         return {\n   *           key: e.key,\n   *           ctrlKey: e.ctrlKey,\n   *           metaKey: e.metaKey,\n   *           shiftKey: e.shiftKey\n   *         }\n   *       }\n   *     }\n   *\n   */\n  metadata?: { [eventName: string]: (e: Event, el: HTMLElement) => object };\n  /**\n   * An optional Storage compatible object\n   * Useful when LiveView won't have access to `sessionStorage`. For example, This could\n   * happen if a site loads a cross-domain LiveView in an iframe.\n   *\n   * Example usage:\n   *\n   *     class InMemoryStorage {\n   *       constructor() { this.storage = {} }\n   *       getItem(keyName) { return this.storage[keyName] || null }\n   *       removeItem(keyName) { delete this.storage[keyName] }\n   *       setItem(keyName, keyValue) { this.storage[keyName] = keyValue }\n   *     }\n   */\n  sessionStorage?: Storage;\n  /**\n   * An optional Storage compatible object\n   * Useful when LiveView won't have access to `localStorage`.\n   *\n   * See `sessionStorage` for an example.\n   */\n  localStorage?: Storage;\n  /**\n   * If set to `true`, `phx-change` events will be blocked (will not fire)\n   * while the user is composing input using an IME (Input Method Editor).\n   * This is determined by the `e.isComposing` property on keyboard events,\n   * which is `true` when the user is in the process of entering composed characters (for example,\n   * when typing Japanese or Chinese using romaji or pinyin input methods).\n   * By default, `phx-change` will not be blocked during a composition session,\n   * but note that there were issues reported in older versions of Safari,\n   * where a LiveView patch to the input caused unexpected behavior.\n   *\n   * For more information, see\n   * - https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/isComposing\n   * - https://github.com/phoenixframework/phoenix_live_view/issues/3322\n   *\n   * Defaults to `false`.\n   */\n  blockPhxChangeWhileComposing?: boolean;\n  /** DOM callbacks. */\n  dom?: {\n    /**\n     * An optional function to modify the behavior of querying elements in JS commands.\n     * @param sourceEl - The source element, e.g. the button that was clicked.\n     * @param query - The query value.\n     * @param defaultQuery - A default query function that can be used if no custom query should be applied.\n     * @returns A list of DOM elements.\n     */\n    jsQuerySelectorAll?: (\n      sourceEl: HTMLElement,\n      query: string,\n      defaultQuery: () => Element[],\n    ) => Element[];\n    /**\n     * Called immediately before a DOM patch is applied.\n     */\n    onPatchStart?: (container: HTMLElement) => void;\n    /**\n     * Called immediately after a DOM patch is applied.\n     */\n    onPatchEnd?: (container: HTMLElement) => void;\n    /**\n     * Called when a new DOM node is added.\n     */\n    onNodeAdded?: (node: Node) => void;\n    /**\n     * Called before an element is updated.\n     */\n    onBeforeElUpdated?: (fromEl: Element, toEl: Element) => void;\n  };\n  /** Allow passthrough of other options to the Phoenix Socket constructor. */\n  [key: string]: any;\n}\n\n/**\n * Interface describing the public API of a LiveSocket instance.\n */\nexport interface LiveSocketInstanceInterface {\n  /**\n   * Returns the version of the LiveView client.\n   */\n  version(): string;\n  /**\n   * Returns true if profiling is enabled. See `enableProfiling` and `disableProfiling`.\n   */\n  isProfileEnabled(): boolean;\n  /**\n   * Returns true if debugging is enabled. See `enableDebug` and `disableDebug`.\n   */\n  isDebugEnabled(): boolean;\n  /**\n   * Returns true if debugging is disabled. See `enableDebug` and `disableDebug`.\n   */\n  isDebugDisabled(): boolean;\n  /**\n   * Enables debugging.\n   *\n   * When debugging is enabled, the LiveView client will log debug information to the console.\n   * See [Debugging client events](https://hexdocs.pm/phoenix_live_view/js-interop.html#debugging-client-events) for more information.\n   */\n  enableDebug(): void;\n  /**\n   * Enables profiling.\n   *\n   * When profiling is enabled, the LiveView client will log profiling information to the console.\n   */\n  enableProfiling(): void;\n  /**\n   * Disables debugging.\n   */\n  disableDebug(): void;\n  /**\n   * Disables profiling.\n   */\n  disableProfiling(): void;\n  /**\n   * Enables latency simulation.\n   *\n   * When latency simulation is enabled, the LiveView client will add a delay to requests and responses from the server.\n   * See [Simulating Latency](https://hexdocs.pm/phoenix_live_view/js-interop.html#simulating-latency) for more information.\n   */\n  enableLatencySim(upperBoundMs: number): void;\n  /**\n   * Disables latency simulation.\n   */\n  disableLatencySim(): void;\n  /**\n   * Returns the current latency simulation upper bound.\n   */\n  getLatencySim(): number | null;\n  /**\n   * Returns the Phoenix Socket instance.\n   */\n  getSocket(): PhoenixSocket;\n  /**\n   * Connects to the LiveView server.\n   */\n  connect(): void;\n  /**\n   * Disconnects from the LiveView server.\n   */\n  disconnect(callback?: () => void): void;\n  /**\n   * Can be used to replace the transport used by the underlying Phoenix Socket.\n   */\n  replaceTransport(transport: any): void;\n  /**\n   * Executes an encoded JS command, targeting the given element.\n   *\n   * See [`Phoenix.LiveView.JS`](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html) for more information.\n   */\n  execJS(el: HTMLElement, encodedJS: string, eventType?: string | null): void;\n  /**\n   * Returns an object with methods to manipluate the DOM and execute JavaScript.\n   * The applied changes integrate with server DOM patching.\n   *\n   * See [JavaScript interoperability](https://hexdocs.pm/phoenix_live_view/js-interop.html) for more information.\n   */\n  js(): LiveSocketJSCommands;\n}\n\n/**\n * Interface describing the LiveSocket constructor.\n */\nexport interface LiveSocketConstructor {\n  /**\n   * Creates a new LiveSocket instance.\n   *\n   * @param endpoint - The string WebSocket endpoint, ie, `\"wss://example.com/live\"`,\n   *                                               `\"/live\"` (inherited host & protocol)\n   * @param socket - the required Phoenix Socket class imported from \"phoenix\". For example:\n   *\n   *     import {Socket} from \"phoenix\"\n   *     import {LiveSocket} from \"phoenix_live_view\"\n   *     let liveSocket = new LiveSocket(\"/live\", Socket, {...})\n   *\n   * @param opts - Optional configuration.\n   */\n  new (\n    endpoint: string,\n    socket: typeof PhoenixSocket,\n    opts?: LiveSocketOptions,\n  ): LiveSocketInstanceInterface;\n}\n\n// because LiveSocket is in JS (for now), we cast it to our defined TypeScript constructor.\nconst LiveSocket = OriginalLiveSocket as unknown as LiveSocketConstructor;\n\n/** Creates a hook instance for the given element and callbacks.\n *\n * @param el - The element to associate with the hook.\n * @param callbacks - The list of hook callbacks, such as mounted,\n *   updated, destroyed, etc.\n *\n * *Note*: `createHook` must be called from the `connectedCallback` lifecycle\n * which is triggered after the element has been added to the DOM. If you try\n * to call `createHook` from the constructor, an error will be logged.\n *\n * @example\n *\n * class MyComponent extends HTMLElement {\n *   connectedCallback(){\n *     let onLiveViewMounted = () => this.hook.pushEvent(...))\n *     this.hook = createHook(this, {mounted: onLiveViewMounted})\n *   }\n * }\n *\n * @returns Returns the Hook instance for the custom element.\n */\nfunction createHook(el: HTMLElement, callbacks: Hook): ViewHook {\n  let existingHook = DOM.getCustomElHook(el);\n  if (existingHook) {\n    return existingHook;\n  }\n\n  let hook = new ViewHook(View.closestView(el), el, callbacks);\n  DOM.putCustomElHook(el, hook);\n  return hook;\n}\n\nexport { LiveSocket, isUsedInput, createHook, ViewHook, Hook, HooksOptions };\n", "// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\nvar sides = [\"top\", \"right\", \"bottom\", \"left\"];\nvar alignments = [\"start\", \"end\"];\nvar placements = /* @__PURE__ */ sides.reduce(\n  (acc, side) =>\n    acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]),\n  [],\n);\nvar min = Math.min;\nvar max = Math.max;\nvar round = Math.round;\nvar floor = Math.floor;\nvar createCoords = (v) => ({\n  x: v,\n  y: v,\n});\nvar oppositeSideMap = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\",\n};\nvar oppositeAlignmentMap = {\n  start: \"end\",\n  end: \"start\",\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n  return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n  return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction getSideAxis(placement) {\n  return [\"top\", \"bottom\"].includes(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide =\n    alignmentAxis === \"x\"\n      ? alignment === (rtl ? \"end\" : \"start\")\n        ? \"right\"\n        : \"left\"\n      : alignment === \"start\"\n        ? \"bottom\"\n        : \"top\";\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [\n    getOppositeAlignmentPlacement(placement),\n    oppositePlacement,\n    getOppositeAlignmentPlacement(oppositePlacement),\n  ];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(\n    /start|end/g,\n    (alignment) => oppositeAlignmentMap[alignment],\n  );\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = [\"left\", \"right\"];\n  const rl = [\"right\", \"left\"];\n  const tb = [\"top\", \"bottom\"];\n  const bt = [\"bottom\", \"top\"];\n  switch (side) {\n    case \"top\":\n    case \"bottom\":\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case \"left\":\n    case \"right\":\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === \"start\", rtl);\n  if (alignment) {\n    list = list.map((side) => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(\n    /left|right|bottom|top/g,\n    (side) => oppositeSideMap[side],\n  );\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding,\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== \"number\"\n    ? expandPaddingObject(padding)\n    : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding,\n      };\n}\nfunction rectToClientRect(rect) {\n  const { x, y, width, height } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y,\n  };\n}\n\n// node_modules/@floating-ui/core/dist/floating-ui.core.mjs\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let { reference, floating } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === \"y\";\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height,\n      };\n      break;\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height,\n      };\n      break;\n    case \"right\":\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY,\n      };\n      break;\n    case \"left\":\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY,\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y,\n      };\n  }\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case \"end\":\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\nvar computePosition = async (reference, floating, config) => {\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2,\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform2.isRTL == null\n    ? void 0\n    : platform2.isRTL(floating));\n  let rects = await platform2.getElementRects({\n    reference,\n    floating,\n    strategy,\n  });\n  let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const { name, fn } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset,\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: platform2,\n      elements: {\n        reference,\n        floating,\n      },\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data,\n      },\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === \"object\") {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects =\n            reset.rects === true\n              ? await platform2.getElementRects({\n                  reference,\n                  floating,\n                  strategy,\n                })\n              : reset.rects;\n        }\n        ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData,\n  };\n};\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const { x, y, platform: platform2, rects, elements, strategy } = state;\n  const {\n    boundary = \"clippingAncestors\",\n    rootBoundary = \"viewport\",\n    elementContext = \"floating\",\n    altBoundary = false,\n    padding = 0,\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(\n    await platform2.getClippingRect({\n      element: (\n        (_await$platform$isEle = await (platform2.isElement == null\n          ? void 0\n          : platform2.isElement(element))) != null\n          ? _await$platform$isEle\n          : true\n      )\n        ? element\n        : element.contextElement ||\n          (await (platform2.getDocumentElement == null\n            ? void 0\n            : platform2.getDocumentElement(elements.floating))),\n      boundary,\n      rootBoundary,\n      strategy,\n    }),\n  );\n  const rect =\n    elementContext === \"floating\"\n      ? {\n          x,\n          y,\n          width: rects.floating.width,\n          height: rects.floating.height,\n        }\n      : rects.reference;\n  const offsetParent = await (platform2.getOffsetParent == null\n    ? void 0\n    : platform2.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform2.isElement == null\n    ? void 0\n    : platform2.isElement(offsetParent)))\n    ? (await (platform2.getScale == null\n        ? void 0\n        : platform2.getScale(offsetParent))) || {\n        x: 1,\n        y: 1,\n      }\n    : {\n        x: 1,\n        y: 1,\n      };\n  const elementClientRect = rectToClientRect(\n    platform2.convertOffsetParentRelativeRectToViewportRelativeRect\n      ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({\n          elements,\n          rect,\n          offsetParent,\n          strategy,\n        })\n      : rect,\n  );\n  return {\n    top:\n      (clippingClientRect.top - elementClientRect.top + paddingObject.top) /\n      offsetScale.y,\n    bottom:\n      (elementClientRect.bottom -\n        clippingClientRect.bottom +\n        paddingObject.bottom) /\n      offsetScale.y,\n    left:\n      (clippingClientRect.left - elementClientRect.left + paddingObject.left) /\n      offsetScale.x,\n    right:\n      (elementClientRect.right -\n        clippingClientRect.right +\n        paddingObject.right) /\n      offsetScale.x,\n  };\n}\nvar arrow = (options) => ({\n  name: \"arrow\",\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform: platform2,\n      elements,\n      middlewareData,\n    } = state;\n    const { element, padding = 0 } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y,\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform2.getDimensions(element);\n    const isYAxis = axis === \"y\";\n    const minProp = isYAxis ? \"top\" : \"left\";\n    const maxProp = isYAxis ? \"bottom\" : \"right\";\n    const clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n    const endDiff =\n      rects.reference[length] +\n      rects.reference[axis] -\n      coords[axis] -\n      rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform2.getOffsetParent == null\n      ? void 0\n      : platform2.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n    if (\n      !clientSize ||\n      !(await (platform2.isElement == null\n        ? void 0\n        : platform2.isElement(arrowOffsetParent)))\n    ) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n    const largestPossiblePadding =\n      clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n    const min$1 = minPadding;\n    const max2 = clientSize - arrowDimensions[length] - maxPadding;\n    const center =\n      clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset3 = clamp(min$1, center, max2);\n    const shouldAddOffset =\n      !middlewareData.arrow &&\n      getAlignment(placement) != null &&\n      center !== offset3 &&\n      rects.reference[length] / 2 -\n        (center < min$1 ? minPadding : maxPadding) -\n        arrowDimensions[length] / 2 <\n        0;\n    const alignmentOffset = shouldAddOffset\n      ? center < min$1\n        ? center - min$1\n        : center - max2\n      : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset3,\n        centerOffset: center - offset3 - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset,\n        }),\n      },\n      reset: shouldAddOffset,\n    };\n  },\n});\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment\n    ? [\n        ...allowedPlacements.filter(\n          (placement) => getAlignment(placement) === alignment,\n        ),\n        ...allowedPlacements.filter(\n          (placement) => getAlignment(placement) !== alignment,\n        ),\n      ]\n    : allowedPlacements.filter((placement) => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter((placement) => {\n    if (alignment) {\n      return (\n        getAlignment(placement) === alignment ||\n        (autoAlignment\n          ? getOppositeAlignmentPlacement(placement) !== placement\n          : false)\n      );\n    }\n    return true;\n  });\n}\nvar autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"autoPlacement\",\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform: platform2,\n        elements,\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 =\n        alignment !== void 0 || allowedPlacements === placements\n          ? getPlacementList(\n              alignment || null,\n              autoAlignment,\n              allowedPlacements,\n            )\n          : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex =\n        ((_middlewareData$autoP = middlewareData.autoPlacement) == null\n          ? void 0\n          : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(\n        currentPlacement,\n        rects,\n        await (platform2.isRTL == null\n          ? void 0\n          : platform2.isRTL(elements.floating)),\n      );\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0],\n          },\n        };\n      }\n      const currentOverflows = [\n        overflow[getSide(currentPlacement)],\n        overflow[alignmentSides[0]],\n        overflow[alignmentSides[1]],\n      ];\n      const allOverflows = [\n        ...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null\n          ? void 0\n          : _middlewareData$autoP2.overflows) || []),\n        {\n          placement: currentPlacement,\n          overflows: currentOverflows,\n        },\n      ];\n      const nextPlacement = placements$1[currentIndex + 1];\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows,\n          },\n          reset: {\n            placement: nextPlacement,\n          },\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows\n        .map((d) => {\n          const alignment2 = getAlignment(d.placement);\n          return [\n            d.placement,\n            alignment2 && crossAxis\n              ? // Check along the mainAxis and main crossAxis side.\n                d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0)\n              : // Check only the mainAxis.\n                d.overflows[0],\n            d.overflows,\n          ];\n        })\n        .sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(\n        (d) =>\n          d[2]\n            .slice(\n              0,\n              // Aligned placements should not check their opposite crossAxis\n              // side.\n              getAlignment(d[0]) ? 2 : 3,\n            )\n            .every((v) => v <= 0),\n      );\n      const resetPlacement =\n        ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null\n          ? void 0\n          : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows,\n          },\n          reset: {\n            placement: resetPlacement,\n          },\n        };\n      }\n      return {};\n    },\n  };\n};\nvar flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"flip\",\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform: platform2,\n        elements,\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = \"bestFit\",\n        fallbackAxisSideDirection = \"none\",\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      if (\n        (_middlewareData$arrow = middlewareData.arrow) != null &&\n        _middlewareData$arrow.alignmentOffset\n      ) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform2.isRTL == null\n        ? void 0\n        : platform2.isRTL(elements.floating));\n      const fallbackPlacements =\n        specifiedFallbackPlacements ||\n        (isBasePlacement || !flipAlignment\n          ? [getOppositePlacement(initialPlacement)]\n          : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== \"none\";\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(\n          ...getOppositeAxisPlacements(\n            initialPlacement,\n            flipAlignment,\n            fallbackAxisSideDirection,\n            rtl,\n          ),\n        );\n      }\n      const placements2 = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData =\n        ((_middlewareData$flip = middlewareData.flip) == null\n          ? void 0\n          : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides2 = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);\n      }\n      overflowsData = [\n        ...overflowsData,\n        {\n          placement,\n          overflows,\n        },\n      ];\n      if (!overflows.every((side2) => side2 <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex =\n          (((_middlewareData$flip2 = middlewareData.flip) == null\n            ? void 0\n            : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements2[nextIndex];\n        if (nextPlacement) {\n          var _overflowsData$;\n          const ignoreCrossAxisOverflow =\n            checkCrossAxis === \"alignment\"\n              ? initialSideAxis !== getSideAxis(nextPlacement)\n              : false;\n          const hasInitialMainAxisOverflow =\n            ((_overflowsData$ = overflowsData[0]) == null\n              ? void 0\n              : _overflowsData$.overflows[0]) > 0;\n          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData,\n              },\n              reset: {\n                placement: nextPlacement,\n              },\n            };\n          }\n        }\n        let resetPlacement =\n          (_overflowsData$filter = overflowsData\n            .filter((d) => d.overflows[0] <= 0)\n            .sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null\n            ? void 0\n            : _overflowsData$filter.placement;\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case \"bestFit\": {\n              var _overflowsData$filter2;\n              const placement2 =\n                (_overflowsData$filter2 = overflowsData\n                  .filter((d) => {\n                    if (hasFallbackAxisSideDirection) {\n                      const currentSideAxis = getSideAxis(d.placement);\n                      return (\n                        currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal\n                        // reading directions favoring greater width.\n                        currentSideAxis === \"y\"\n                      );\n                    }\n                    return true;\n                  })\n                  .map((d) => [\n                    d.placement,\n                    d.overflows\n                      .filter((overflow2) => overflow2 > 0)\n                      .reduce((acc, overflow2) => acc + overflow2, 0),\n                  ])\n                  .sort((a, b) => a[1] - b[1])[0]) == null\n                  ? void 0\n                  : _overflowsData$filter2[0];\n              if (placement2) {\n                resetPlacement = placement2;\n              }\n              break;\n            }\n            case \"initialPlacement\":\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement,\n            },\n          };\n        }\n      }\n      return {};\n    },\n  };\n};\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width,\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some((side) => overflow[side] >= 0);\n}\nvar hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"hide\",\n    options,\n    async fn(state) {\n      const { rects } = state;\n      const { strategy = \"referenceHidden\", ...detectOverflowOptions } =\n        evaluate(options, state);\n      switch (strategy) {\n        case \"referenceHidden\": {\n          const overflow = await detectOverflow(state, {\n            ...detectOverflowOptions,\n            elementContext: \"reference\",\n          });\n          const offsets = getSideOffsets(overflow, rects.reference);\n          return {\n            data: {\n              referenceHiddenOffsets: offsets,\n              referenceHidden: isAnySideFullyClipped(offsets),\n            },\n          };\n        }\n        case \"escaped\": {\n          const overflow = await detectOverflow(state, {\n            ...detectOverflowOptions,\n            altBoundary: true,\n          });\n          const offsets = getSideOffsets(overflow, rects.floating);\n          return {\n            data: {\n              escapedOffsets: offsets,\n              escaped: isAnySideFullyClipped(offsets),\n            },\n          };\n        }\n        default: {\n          return {};\n        }\n      }\n    },\n  };\n};\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map((rect) => rect.left));\n  const minY = min(...rects.map((rect) => rect.top));\n  const maxX = max(...rects.map((rect) => rect.right));\n  const maxY = max(...rects.map((rect) => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));\n}\nvar inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"inline\",\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform: platform2,\n        strategy,\n      } = state;\n      const { padding = 2, x, y } = evaluate(options, state);\n      const nativeClientRects = Array.from(\n        (await (platform2.getClientRects == null\n          ? void 0\n          : platform2.getClientRects(elements.reference))) || [],\n      );\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect2() {\n        if (\n          clientRects.length === 2 &&\n          clientRects[0].left > clientRects[1].right &&\n          x != null &&\n          y != null\n        ) {\n          return (\n            clientRects.find(\n              (rect) =>\n                x > rect.left - paddingObject.left &&\n                x < rect.right + paddingObject.right &&\n                y > rect.top - paddingObject.top &&\n                y < rect.bottom + paddingObject.bottom,\n            ) || fallback\n          );\n        }\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === \"y\") {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === \"top\";\n            const top2 = firstRect.top;\n            const bottom2 = lastRect.bottom;\n            const left2 = isTop ? firstRect.left : lastRect.left;\n            const right2 = isTop ? firstRect.right : lastRect.right;\n            const width2 = right2 - left2;\n            const height2 = bottom2 - top2;\n            return {\n              top: top2,\n              bottom: bottom2,\n              left: left2,\n              right: right2,\n              width: width2,\n              height: height2,\n              x: left2,\n              y: top2,\n            };\n          }\n          const isLeftSide = getSide(placement) === \"left\";\n          const maxRight = max(...clientRects.map((rect) => rect.right));\n          const minLeft = min(...clientRects.map((rect) => rect.left));\n          const measureRects = clientRects.filter((rect) =>\n            isLeftSide ? rect.left === minLeft : rect.right === maxRight,\n          );\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top,\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform2.getElementRects({\n        reference: {\n          getBoundingClientRect: getBoundingClientRect2,\n        },\n        floating: elements.floating,\n        strategy,\n      });\n      if (\n        rects.reference.x !== resetRects.reference.x ||\n        rects.reference.y !== resetRects.reference.y ||\n        rects.reference.width !== resetRects.reference.width ||\n        rects.reference.height !== resetRects.reference.height\n      ) {\n        return {\n          reset: {\n            rects: resetRects,\n          },\n        };\n      }\n      return {};\n    },\n  };\n};\nasync function convertValueToCoords(state, options) {\n  const { placement, platform: platform2, elements } = state;\n  const rtl = await (platform2.isRTL == null\n    ? void 0\n    : platform2.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === \"y\";\n  const mainAxisMulti = [\"left\", \"top\"].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n  let { mainAxis, crossAxis, alignmentAxis } =\n    typeof rawValue === \"number\"\n      ? {\n          mainAxis: rawValue,\n          crossAxis: 0,\n          alignmentAxis: null,\n        }\n      : {\n          mainAxis: rawValue.mainAxis || 0,\n          crossAxis: rawValue.crossAxis || 0,\n          alignmentAxis: rawValue.alignmentAxis,\n        };\n  if (alignment && typeof alignmentAxis === \"number\") {\n    crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical\n    ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti,\n      }\n    : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti,\n      };\n}\nvar offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: \"offset\",\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const { x, y, placement, middlewareData } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      if (\n        placement ===\n          ((_middlewareData$offse = middlewareData.offset) == null\n            ? void 0\n            : _middlewareData$offse.placement) &&\n        (_middlewareData$arrow = middlewareData.arrow) != null &&\n        _middlewareData$arrow.alignmentOffset\n      ) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement,\n        },\n      };\n    },\n  };\n};\nvar shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"shift\",\n    options,\n    async fn(state) {\n      const { x, y, placement } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: (_ref) => {\n            let { x: x2, y: y2 } = _ref;\n            return {\n              x: x2,\n              y: y2,\n            };\n          },\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y,\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n        const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n        const min2 = mainAxisCoord + overflow[minSide];\n        const max2 = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min2, mainAxisCoord, max2);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n        const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n        const min2 = crossAxisCoord + overflow[minSide];\n        const max2 = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min2, crossAxisCoord, max2);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord,\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis,\n          },\n        },\n      };\n    },\n  };\n};\nvar limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const { x, y, placement, rects, middlewareData } = state;\n      const {\n        offset: offset3 = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y,\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset3, state);\n      const computedOffset =\n        typeof rawOffset === \"number\"\n          ? {\n              mainAxis: rawOffset,\n              crossAxis: 0,\n            }\n          : {\n              mainAxis: 0,\n              crossAxis: 0,\n              ...rawOffset,\n            };\n      if (checkMainAxis) {\n        const len = mainAxis === \"y\" ? \"height\" : \"width\";\n        const limitMin =\n          rects.reference[mainAxis] -\n          rects.floating[len] +\n          computedOffset.mainAxis;\n        const limitMax =\n          rects.reference[mainAxis] +\n          rects.reference[len] -\n          computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === \"y\" ? \"width\" : \"height\";\n        const isOriginSide = [\"top\", \"left\"].includes(getSide(placement));\n        const limitMin =\n          rects.reference[crossAxis] -\n          rects.floating[len] +\n          (isOriginSide\n            ? ((_middlewareData$offse = middlewareData.offset) == null\n                ? void 0\n                : _middlewareData$offse[crossAxis]) || 0\n            : 0) +\n          (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax =\n          rects.reference[crossAxis] +\n          rects.reference[len] +\n          (isOriginSide\n            ? 0\n            : ((_middlewareData$offse2 = middlewareData.offset) == null\n                ? void 0\n                : _middlewareData$offse2[crossAxis]) || 0) -\n          (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord,\n      };\n    },\n  };\n};\nvar size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"size\",\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const { placement, rects, platform: platform2, elements } = state;\n      const { apply = () => {}, ...detectOverflowOptions } = evaluate(\n        options,\n        state,\n      );\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === \"y\";\n      const { width, height } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === \"top\" || side === \"bottom\") {\n        heightSide = side;\n        widthSide =\n          alignment ===\n          ((await (platform2.isRTL == null\n            ? void 0\n            : platform2.isRTL(elements.floating)))\n            ? \"start\"\n            : \"end\")\n            ? \"left\"\n            : \"right\";\n      } else {\n        widthSide = side;\n        heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(\n        height - overflow[heightSide],\n        maximumClippingHeight,\n      );\n      const overflowAvailableWidth = min(\n        width - overflow[widthSide],\n        maximumClippingWidth,\n      );\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (\n        (_state$middlewareData = state.middlewareData.shift) != null &&\n        _state$middlewareData.enabled.x\n      ) {\n        availableWidth = maximumClippingWidth;\n      }\n      if (\n        (_state$middlewareData2 = state.middlewareData.shift) != null &&\n        _state$middlewareData2.enabled.y\n      ) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth =\n            width -\n            2 *\n              (xMin !== 0 || xMax !== 0\n                ? xMin + xMax\n                : max(overflow.left, overflow.right));\n        } else {\n          availableHeight =\n            height -\n            2 *\n              (yMin !== 0 || yMax !== 0\n                ? yMin + yMax\n                : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight,\n      });\n      const nextDimensions = await platform2.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true,\n          },\n        };\n      }\n      return {};\n    },\n  };\n};\n\n// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\nfunction hasWindow() {\n  return typeof window !== \"undefined\";\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || \"\").toLowerCase();\n  }\n  return \"#document\";\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (\n    (node == null || (_node$ownerDocument = node.ownerDocument) == null\n      ? void 0\n      : _node$ownerDocument.defaultView) || window\n  );\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref =\n    (isNode(node) ? node.ownerDocument : node.document) || window.document) ==\n    null\n    ? void 0\n    : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return (\n    value instanceof HTMLElement ||\n    value instanceof getWindow(value).HTMLElement\n  );\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  return (\n    value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot\n  );\n}\nfunction isOverflowElement(element) {\n  const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n  return (\n    /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) &&\n    ![\"inline\", \"contents\"].includes(display)\n  );\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [\":popover-open\", \":modal\"].some((selector) => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss)\n    ? getComputedStyle(elementOrCss)\n    : elementOrCss;\n  return (\n    [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\"].some(\n      (value) => (css[value] ? css[value] !== \"none\" : false),\n    ) ||\n    (css.containerType ? css.containerType !== \"normal\" : false) ||\n    (!webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false)) ||\n    (!webkit && (css.filter ? css.filter !== \"none\" : false)) ||\n    [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\", \"filter\"].some(\n      (value) => (css.willChange || \"\").includes(value),\n    ) ||\n    [\"paint\", \"layout\", \"strict\", \"content\"].some((value) =>\n      (css.contain || \"\").includes(value),\n    )\n  );\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n  return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction isLastTraversableNode(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop,\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY,\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    (isShadowRoot(node) && node.host) || // Fallback.\n    getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody =\n    scrollableAncestor ===\n    ((_node$ownerDocument2 = node.ownerDocument) == null\n      ? void 0\n      : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(\n      win,\n      win.visualViewport || [],\n      isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],\n      frameElement && traverseIframes ? getOverflowAncestors(frameElement) : [],\n    );\n  }\n  return list.concat(\n    scrollableAncestor,\n    getOverflowAncestors(scrollableAncestor, [], traverseIframes),\n  );\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent)\n    ? win.frameElement\n    : null;\n}\n\n// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback =\n    round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback,\n  };\n}\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const { width, height, $ } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y,\n  };\n}\nvar noOffsets = /* @__PURE__ */ createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop,\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (\n    !floatingOffsetParent ||\n    (isFixed && floatingOffsetParent !== getWindow(element))\n  ) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(\n  element,\n  includeScale,\n  isFixedStrategy,\n  offsetParent,\n) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(\n    domElement,\n    isFixedStrategy,\n    offsetParent,\n  )\n    ? getVisualOffsets(domElement)\n    : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin =\n      offsetParent && isElement(offsetParent)\n        ? getWindow(offsetParent)\n        : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left =\n        iframeRect.left +\n        (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) *\n          iframeScale.x;\n      const top =\n        iframeRect.top +\n        (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y,\n  });\n}\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x =\n    htmlRect.left +\n    scroll.scrollLeft -\n    (ignoreScrollbarX\n      ? 0\n      : // RTL <body> scrollbar.\n        getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y,\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let { elements, rect, offsetParent, strategy } = _ref;\n  const isFixed = strategy === \"fixed\";\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || (topLayer && isFixed)) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0,\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {\n    if (\n      getNodeName(offsetParent) !== \"body\" ||\n      isOverflowElement(documentElement)\n    ) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset =\n    documentElement && !isOffsetParentAnElement && !isFixed\n      ? getHTMLOffset(documentElement, scroll, true)\n      : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x:\n      rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y,\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(\n    html.scrollWidth,\n    html.clientWidth,\n    body.scrollWidth,\n    body.clientWidth,\n  );\n  const height = max(\n    html.scrollHeight,\n    html.clientHeight,\n    body.scrollHeight,\n    body.clientHeight,\n  );\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === \"rtl\") {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y,\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || (visualViewportBased && strategy === \"fixed\")) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y,\n  };\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y,\n  };\n}\nfunction getClientRectFromClippingAncestor(\n  element,\n  clippingAncestor,\n  strategy,\n) {\n  let rect;\n  if (clippingAncestor === \"viewport\") {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === \"document\") {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height,\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (\n    parentNode === stopNode ||\n    !isElement(parentNode) ||\n    isLastTraversableNode(parentNode)\n  ) {\n    return false;\n  }\n  return (\n    getComputedStyle(parentNode).position === \"fixed\" ||\n    hasFixedPositionAncestor(parentNode, stopNode)\n  );\n}\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(\n    (el) => isElement(el) && getNodeName(el) !== \"body\",\n  );\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === \"fixed\";\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed\n      ? !currentNodeIsContaining && !currentContainingBlockComputedStyle\n      : (!currentNodeIsContaining &&\n          computedStyle.position === \"static\" &&\n          !!currentContainingBlockComputedStyle &&\n          [\"absolute\", \"fixed\"].includes(\n            currentContainingBlockComputedStyle.position,\n          )) ||\n        (isOverflowElement(currentNode) &&\n          !currentNodeIsContaining &&\n          hasFixedPositionAncestor(element, currentNode));\n    if (shouldDropCurrentNode) {\n      result = result.filter((ancestor) => ancestor !== currentNode);\n    } else {\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\nfunction getClippingRect(_ref) {\n  let { element, boundary, rootBoundary, strategy } = _ref;\n  const elementClippingAncestors =\n    boundary === \"clippingAncestors\"\n      ? isTopLayer(element)\n        ? []\n        : getClippingElementAncestors(element, this._c)\n      : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce(\n    (accRect, clippingAncestor) => {\n      const rect = getClientRectFromClippingAncestor(\n        element,\n        clippingAncestor,\n        strategy,\n      );\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    },\n    getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy),\n  );\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top,\n  };\n}\nfunction getDimensions(element) {\n  const { width, height } = getCssDimensions(element);\n  return {\n    width,\n    height,\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === \"fixed\";\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0,\n  };\n  const offsets = createCoords(0);\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {\n    if (\n      getNodeName(offsetParent) !== \"body\" ||\n      isOverflowElement(documentElement)\n    ) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(\n        offsetParent,\n        true,\n        isFixed,\n        offsetParent,\n      );\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset =\n    documentElement && !isOffsetParentAnElement && !isFixed\n      ? getHTMLOffset(documentElement, scroll)\n      : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height,\n  };\n}\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === \"static\";\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (\n    !isHTMLElement(element) ||\n    getComputedStyle(element).position === \"fixed\"\n  ) {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (\n    offsetParent &&\n    isTableElement(offsetParent) &&\n    isStaticPositioned(offsetParent)\n  ) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (\n    offsetParent &&\n    isLastTraversableNode(offsetParent) &&\n    isStaticPositioned(offsetParent) &&\n    !isContainingBlock(offsetParent)\n  ) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\nvar getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(\n      data.reference,\n      await getOffsetParentFn(data.floating),\n      data.strategy,\n    ),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height,\n    },\n  };\n};\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === \"rtl\";\n}\nvar platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL,\n};\nfunction rectsAreEqual(a, b) {\n  return (\n    a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height\n  );\n}\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const { left, top, width, height } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin =\n      -insetTop +\n      \"px \" +\n      -insetRight +\n      \"px \" +\n      -insetBottom +\n      \"px \" +\n      -insetLeft +\n      \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1,\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1e3);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (\n        ratio === 1 &&\n        !rectsAreEqual(\n          elementRectForRootMargin,\n          element.getBoundingClientRect(),\n        )\n      ) {\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument,\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === \"function\",\n    layoutShift = typeof IntersectionObserver === \"function\",\n    animationFrame = false,\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors =\n    ancestorScroll || ancestorResize\n      ? [\n          ...(referenceEl ? getOverflowAncestors(referenceEl) : []),\n          ...getOverflowAncestors(floating),\n        ]\n      : [];\n  ancestors.forEach((ancestor) => {\n    ancestorScroll &&\n      ancestor.addEventListener(\"scroll\", update, {\n        passive: true,\n      });\n    ancestorResize && ancestor.addEventListener(\"resize\", update);\n  });\n  const cleanupIo =\n    referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver((_ref) => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null ||\n            _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach((ancestor) => {\n      ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n      ancestorResize && ancestor.removeEventListener(\"resize\", update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null ||\n      _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\nvar detectOverflow2 = detectOverflow;\nvar offset2 = offset;\nvar autoPlacement2 = autoPlacement;\nvar shift2 = shift;\nvar flip2 = flip;\nvar size2 = size;\nvar hide2 = hide;\nvar arrow2 = arrow;\nvar inline2 = inline;\nvar limitShift2 = limitShift;\nvar computePosition2 = (reference, floating, options) => {\n  const cache = /* @__PURE__ */ new Map();\n  const mergedOptions = {\n    platform,\n    ...options,\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache,\n  };\n  return computePosition(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache,\n  });\n};\nexport {\n  arrow2 as arrow,\n  autoPlacement2 as autoPlacement,\n  autoUpdate,\n  computePosition2 as computePosition,\n  detectOverflow2 as detectOverflow,\n  flip2 as flip,\n  getOverflowAncestors,\n  hide2 as hide,\n  inline2 as inline,\n  limitShift2 as limitShift,\n  offset2 as offset,\n  platform,\n  shift2 as shift,\n  size2 as size,\n};\n", "import { ViewHook } from \"phoenix_live_view\";\nimport {\n  computePosition,\n  offset,\n  flip,\n  shift,\n  autoUpdate,\n} from \"@/vendor/floating-ui\";\n\nexport default class Popover extends ViewHook {\n  expanded = false;\n  name = \"popover\";\n  placement = \"bottom-start\";\n  currentIndex = -1;\n\n  #outside_listener;\n  #clear_floating;\n\n  mounted() {\n    // Initialize trigger and popup elements\n    this.trigger = this.el.querySelector(\n      \"[aria-haspopup='menu'],[aria-haspopup='listbox'],[role='combobox']\",\n    );\n    this.popup = this.el.querySelector(\"[role='menu'],[role='listbox']\");\n    this.search = this.el.querySelector(\"input[type='text'][role='combobox']\");\n\n    this.placement = this.el.dataset.placement || this.placement;\n\n    this.items = this.popup.querySelectorAll(\n      \"[role='option'],[role='menuitem']\",\n    );\n\n    this.refreshExpanded();\n\n    // Trigger click handler\n    this.trigger.addEventListener(\"click\", () => {\n      if (this.expanded) {\n        this.closePopover();\n      } else {\n        this.openPopover();\n      }\n\n      this.refreshExpanded();\n    });\n\n    // Keydown handler\n    this.el.addEventListener(\"keydown\", this.handleContainerKeyDown.bind(this));\n    this.trigger.addEventListener(\n      \"keydown\",\n      this.handleTriggerKeyDown.bind(this),\n    );\n\n    // Search input handler\n    this.search?.addEventListener(\"input\", this.handleSearchInput.bind(this));\n\n    // Click outside\n    this.#outside_listener = document.addEventListener(\"click\", (event) => {\n      if (!this.el.contains(event.target)) {\n        this.closePopover();\n      }\n    });\n\n    this.initFloatingUI();\n  }\n\n  updated() {\n    this.restoreExpanded();\n    this.refreshFloatingUI();\n  }\n\n  destroyed() {\n    if (this.#outside_listener) {\n      this.#outside_listener();\n    }\n\n    if (this.#clear_floating) {\n      this.#clear_floating();\n    }\n  }\n\n  handleSearchInput(event) {\n    const query = event.target.value.toLowerCase();\n    this.currentIndex = -1;\n    this.items.forEach((item) => {\n      const itemText = (item.dataset.label || item.textContent)\n        .trim()\n        .toLowerCase();\n      const matches = itemText.includes(query);\n      item.setAttribute(\"aria-hidden\", String(!matches));\n    });\n  }\n\n  handleTriggerKeyDown(event) {\n    if (event.key === \"ArrowDown\" && !this.expanded) {\n      event.preventDefault();\n      this.openPopover();\n    }\n    // if (event.key === \"Enter\" && !this.expanded) {\n    //   event.preventDefault();\n    //   this.closePopover();\n    // }\n  }\n\n  handleContainerKeyDown(event) {\n    if (!this.expanded) return;\n\n    switch (event.key) {\n      case \"Escape\":\n        event.preventDefault();\n        this.closePopover();\n        this.trigger.focus();\n        break;\n      case \"ArrowDown\":\n      case \"ArrowUp\":\n      case \"Home\":\n      case \"End\":\n        this.handleArrowNavigation(event);\n        break;\n      case \"Enter\":\n        if (this.currentIndex >= 0) {\n          const visibleItems = Array.from(this.items).filter(\n            (item) => item.style.display !== \"none\",\n          );\n          const currentItem = visibleItems[this.currentIndex];\n          if (currentItem) {\n            // event.preventDefault();\n            // currentItem.click();\n            // this.toggle(false);\n          }\n        }\n        break;\n      case \"Tab\":\n        this.closePopover();\n        break;\n    }\n  }\n\n  handleArrowNavigation(event) {\n    if (!this.expanded) return;\n\n    const visibleItems = Array.from(this.items).filter(\n      (item) =>\n        item.style.display !== \"none\" &&\n        item.getAttribute(\"aria-disabled\") !== \"true\" &&\n        item.getAttribute(\"aria-hidden\") !== \"true\",\n    );\n    const itemCount = visibleItems.length;\n    if (itemCount === 0) return;\n\n    event.preventDefault();\n\n    let newIndex = this.currentIndex;\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        newIndex = (this.currentIndex + 1) % itemCount;\n        break;\n      case \"ArrowUp\":\n        newIndex = (this.currentIndex - 1 + itemCount) % itemCount;\n        break;\n      case \"Home\":\n        newIndex = 0;\n        break;\n      case \"End\":\n        newIndex = itemCount - 1;\n        break;\n    }\n\n    visibleItems.forEach((item, index) => {\n      if (index === newIndex) {\n        item.setAttribute(\"aria-selected\", \"true\");\n        if (!this.search || true) {\n          // use another dataset for active state\n          item.setAttribute(\"tabindex\", \"0\");\n          item.focus();\n        }\n        // item.setAttribute(\"data-highlighted\", \"true\");\n        item.scrollIntoView({ block: \"nearest\" });\n      } else {\n        item.removeAttribute(\"aria-selected\");\n        // item.removeAttribute(\"data-highlighted\");\n        if (!this.search || true) {\n          item.setAttribute(\"tabindex\", \"-1\");\n        }\n      }\n    });\n\n    this.currentIndex = newIndex;\n  }\n\n  initFloatingUI() {\n    if (this.#clear_floating) {\n      this.#clear_floating();\n    }\n    if (!this.trigger || !this.popup) {\n      return;\n    }\n    this.#clear_floating = autoUpdate(this.trigger, this.popup, () => {\n      this.refreshFloatingUI();\n    });\n  }\n\n  refreshFloatingUI() {\n    computePosition(this.trigger, this.popup, {\n      placement: this.placement,\n      middleware: [offset(8), flip(), shift()],\n    }).then(({ x, y }) => {\n      Object.assign(this.popup.style, {\n        left: `${x}px`,\n        top: `${y}px`,\n      });\n    });\n  }\n\n  closePopover() {\n    this.trigger?.setAttribute(\"aria-expanded\", \"false\");\n    this.popup?.setAttribute(\"aria-hidden\", \"true\");\n\n    if (this.search) {\n      this.search.value = \"\";\n    }\n\n    this.expanded = false;\n    this.currentIndex = -1;\n  }\n\n  openPopover() {\n    this.trigger?.setAttribute(\"aria-expanded\", \"true\");\n    this.popup?.setAttribute(\"aria-hidden\", \"false\");\n\n    if (this.search) {\n      this.search.focus();\n    }\n\n    this.expanded = true;\n  }\n\n  log(msg, data) {\n    console.log(`${this.name}: ${msg}`, data);\n  }\n\n  refreshExpanded() {\n    this.expanded = this.trigger?.getAttribute(\"aria-expanded\") == \"true\";\n  }\n\n  restoreExpanded() {\n    if (this.expanded) {\n      this.openPopover();\n    } else {\n      this.closePopover();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["Hooks", "doc", "isEmpty", "file", "morphAttrs", "morphdom", "childrenOnly", "getComputedStyle", "top", "Hooks"]
}
